# 01-渲染流程：重排（Reflow）与重绘（Repaint）

我们在“关键渲染路径”一章中已经了解了浏览器渲染页面的基本流程。当页面元素的样式或结构发生变化时，浏览器需要重新执行这个流程的一部分，这些后续的更新操作是影响前端性能的关键。

我们可以将这些更新操作按其对性能的影响，从高到低分为三个层次：**布局 (Layout)**、**绘制 (Paint)** 和 **合成 (Composite)**。性能优化的核心目标就是：**尽可能地将操作限制在“合成”层，避免“绘制”，极力规避“布局”**。

## 1. 概念定义

### a. 布局 (Layout / Reflow)

*   **定义**：当 DOM 的**几何属性**（如宽度、高度、位置、边距等）发生变化，导致浏览器需要**重新计算元素的几何信息**，并重新构建页面布局的过程，就称为布局（也称重排 Reflow）。
*   **核心**：任何会改变元素在文档流中**位置**和**尺寸**的操作，都可能触发布局。

### b. 绘制 (Paint / Repaint)

*   **定义**：当 DOM 的**外观属性**（如颜色、背景、阴影等）发生变化，但**不影响其几何属性**时，浏览器需要**重新将元素绘制成像素**的过程，就称为绘制（也称重绘 Repaint）。
*   **核心**：只改变视觉效果，不改变几何布局。

### c. 合成 (Composite)

*   **定义**：当一个元素被提升到独立的**图层 (Layer)** 后，如果它发生的变更既不影响布局也不影响绘制（通常是 `transform` 和 `opacity` 属性的改变），浏览器就会跳过布局和绘制，直接在 GPU 中将多个图层合并，生成最终的屏幕图像。这个过程就是合成。
*   **核心**：不涉及主线程的布局和绘制计算，性能开销最低。

## 2. 关系：性能开销金字塔

**布局 (Layout) 的成本远高于绘制 (Paint)，而绘制的成本又远高于合成 (Composite)。**

它们的关系可以看作一个金字塔：
1.  **布局 (Layout)**：如果你移动了房间里的一个大沙发，你需要重新规划整个房间的布局。
2.  **绘制 (Paint)**：布局改变后，沙发的新旧位置的地板都需要重新“画”出来。
3.  **合成 (Composite)**：如果你只是通过魔法让沙发悬浮起来并移动，它没有挤占任何新的地面空间，也无需重新粉刷地板，只需要最后把它和其他东西的影像合并起来即可。

因此，**一次布局必定会触发绘制和合成**。反之，一次绘制不一定会触发布局，但通常会触发合成。而一次合成，则不会触发布局和绘制。

## 3. 触发条件

*   **查询实用工具**：对于任何一个 CSS 属性，想知道修改它会触发哪个流程，可以查询 **CSS Triggers** ([https://csstriggers.com/](https://csstriggers.com/)) 网站。

### a. 触发布局 (Layout) 的常见操作

*   **页面首次渲染**：这是最大规模的一次布局。
*   **添加或删除可见的 DOM 节点**。
*   **元素尺寸或位置的改变**：修改 `width`, `height`, `margin`, `padding`, `border`, `left`, `top` 等属性。
*   **内容改变**：例如，文本数量的增减，导致元素尺寸变化。
*   **浏览器窗口尺寸改变（resize）**。
*   **获取布局信息**：这是一个非常关键且容易被忽略的点。当你读取某些需要即时计算的 DOM 属性时，浏览器为了返回最精确的值，会强制提前执行布局流程。
    *   常见的属性包括：`offsetTop`, `offsetLeft`, `offsetWidth`, `offsetHeight`, `scrollTop`, `scrollLeft`, `scrollWidth`, `scrollHeight` 等。
    *   调用 `getComputedStyle()` 或 `getBoundingClientRect()` 方法。

### b. 仅触发绘制 (Paint) 的常见操作

*   修改 `color`, `background-color`, `border-color`, `outline-style`, `visibility`, `text-decoration` 等不影响几何布局的样式。

### c. 仅触发合成 (Composite) 的常见操作

*   通常只有 `transform` 和 `opacity` 这两个属性的改变能被高度优化，仅触发合成。

## 4. 浏览器优化策略：渲染队列

考虑到频繁的重排和重绘会严重影响性能，现代浏览器实现了一套**渲染队列（Render Queue）**机制来进行优化。

*   **机制**：当你的代码触发了重排或重绘时，浏览器并不会立即执行，而是将这个“待处理”的变更放入一个队列中。浏览器会继续执行后续的 JS 代码。
*   **批量执行**：浏览器会等到一个合适的时机（比如当前 JS 代码块执行完毕，或者队列中的变更积累到一定程度），然后**一次性地**将队列中的所有变更批量处理掉，这样多次的重排/重绘就有可能被合并为一次。

**但是**，正如上面提到的，如果你在代码中**读取了需要即时计算的布局属性**，就会破坏这个优化机制。浏览器为了给你返回最准确的值，不得不**强制清空渲染队列**，立即执行一次重排/重绘。

**一个反面教材：**
```javascript
const elements = document.querySelectorAll('.box');
elements.forEach(el => {
  // 每次循环都强制浏览器重排，因为要读取 offsetWidth
  el.style.width = el.offsetWidth + 10 + 'px';
});
```
这个循环有 N 个元素，就会导致 N 次布局，性能极差。

## 5. 现代 CSS 性能优化三剑客

除了传统的减少重排重绘，现代浏览器提供了更细粒度的 CSS 属性，让开发者可以**主动控制**渲染行为。

### a. `content-visibility: auto` (浏览器原生虚拟列表)

这是一个革命性的属性。

*   **作用**：它允许浏览器**跳过屏幕外元素**的渲染工作（布局和绘制）。
*   **原理**：当一个元素设置了 `content-visibility: auto` 且不在视口内时，浏览器会将其视为一个“空盒子”，不计算其内部复杂的子树。当用户滚动，元素接近视口时，浏览器才开始渲染它。
*   **场景**：长列表、长文章。这相当于浏览器提供了原生的“虚拟滚动”能力，对于首屏加载性能有巨大提升。
*   **配套**：通常需要配合 `contain-intrinsic-size` 属性给元素指定一个预估高度，防止滚动条抖动。

```css
.card {
  content-visibility: auto;
  contain-intrinsic-size: 100px; /* 预估高度 */
}
```

### b. `contain` (渲染隔离)

`contain` 属性允许开发者显式地告诉浏览器：“这个元素的内部变化完全独立于外部”。

*   **作用**：限制重排的范围。
*   **常用值**：
    *   `contain: layout;`：告诉浏览器，该元素内部的布局变化不会影响到外部，外部的布局变化也不会影响内部。这样重排就被限制在这个元素内部，不会波及整个页面。
    *   `contain: paint;`：告诉浏览器，该元素的子元素不会绘制到边框之外。如果元素在屏幕外，浏览器可以直接跳过绘制。
    *   `contain: content;` (简写)：结合了 `layout` 和 `paint` 等特性。

### c. `will-change` (合成层提升)

*   **作用**：提前通知浏览器某个元素即将发生变化。
*   **效果**：浏览器会为该元素创建独立的**合成层 (Compositor Layer)**，并预先做好 GPU 优化准备。
*   **最佳实践**：
    *   **只针对关键动画使用**：如 `transform`, `opacity`。
    *   **避免滥用**：每个合成层都需要消耗显存。滥用 `will-change` 会导致内存爆炸，反而降低性能（甚至导致手机端浏览器崩溃）。
    *   **用完即弃**：如果是动态添加的动画，动画结束后最好移除该属性。

```css
/* 推荐用法：仅在鼠标悬停或动画开始前添加 */
.box:hover {
  will-change: transform;
}
```

## 6. 总结

1.  **核心原则**：减少布局，避免绘制，坚持合成。
2.  **代码层面**：
    *   批量修改样式（`class` 或 `cssText`）。
    *   批量读取布局信息（读写分离）。
    *   使用 `DocumentFragment` 批量操作 DOM。
3.  **动画层面**：优先使用 `transform` 和 `opacity` 实现动画。
4.  **现代 API**：
    *   利用 `content-visibility` 优化长列表。
    *   利用 `contain` 隔离独立的组件布局。
    *   谨慎使用 `will-change` 提升关键动画性能。
