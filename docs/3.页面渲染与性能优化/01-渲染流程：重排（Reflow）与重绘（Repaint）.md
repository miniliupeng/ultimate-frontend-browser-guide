# 07-渲染流程：布局、绘制与合成

我们在“关键渲染路径”一章中已经了解了浏览器渲染页面的基本流程。当页面元素的样式或结构发生变化时，浏览器需要重新执行这个流程的一部分，这些后续的更新操作是影响前端性能的关键。

我们可以将这些更新操作按其对性能的影响，从高到低分为三个层次：**布局 (Layout)**、**绘制 (Paint)** 和 **合成 (Composite)**。性能优化的核心目标就是：**尽可能地将操作限制在“合成”层，避免“绘制”，极力规避“布局”**。

## 1. 概念定义

### a. 布局 (Layout / Reflow)

*   **定义**：当 DOM 的**几何属性**（如宽度、高度、位置、边距等）发生变化，导致浏览器需要**重新计算元素的几何信息**，并重新构建页面布局的过程，就称为布局（也称重排 Reflow）。
*   **核心**：任何会改变元素在文档流中**位置**和**尺寸**的操作，都可能触发布局。

### b. 绘制 (Paint / Repaint)

*   **定义**：当 DOM 的**外观属性**（如颜色、背景、阴影等）发生变化，但**不影响其几何属性**时，浏览器需要**重新将元素绘制成像素**的过程，就称为绘制（也称重绘 Repaint）。
*   **核心**：只改变视觉效果，不改变几何布局。

### c. 合成 (Composite)

*   **定义**：当一个元素被提升到独立的**图层 (Layer)** 后，如果它发生的变更既不影响布局也不影响绘制（通常是 `transform` 和 `opacity` 属性的改变），浏览器就会跳过布局和绘制，直接在 GPU 中将多个图层合并，生成最终的屏幕图像。这个过程就是合成。
*   **核心**：不涉及主线程的布局和绘制计算，性能开销最低。

## 2. 关系：性能开销金字塔

**布局 (Layout) 的成本远高于绘制 (Paint)，而绘制的成本又远高于合成 (Composite)。**

它们的关系可以看作一个金字塔：
1.  **布局 (Layout)**：如果你移动了房间里的一个大沙发，你需要重新规划整个房间的布局。
2.  **绘制 (Paint)**：布局改变后，沙发的新旧位置的地板都需要重新“画”出来。
3.  **合成 (Composite)**：如果你只是通过魔法让沙发悬浮起来并移动，它没有挤占任何新的地面空间，也无需重新粉刷地板，只需要最后把它和其他东西的影像合并起来即可。

因此，**一次布局必定会触发绘制和合成**。反之，一次绘制不一定会触发布局，但通常会触发合成。而一次合成，则不会触发布局和绘制。

## 3. 触发条件

*   **查询实用工具**：对于任何一个 CSS 属性，想知道修改它会触发哪个流程，可以查询 **CSS Triggers** ([https://csstriggers.com/](https://csstriggers.com/)) 网站。

### a. 触发布局 (Layout) 的常见操作

*   **页面首次渲染**：这是最大规模的一次布局。
*   **添加或删除可见的 DOM 节点**。
*   **元素尺寸或位置的改变**：修改 `width`, `height`, `margin`, `padding`, `border`, `left`, `top` 等属性。
*   **内容改变**：例如，文本数量的增减，导致元素尺寸变化。
*   **浏览器窗口尺寸改变（resize）**。
*   **获取布局信息**：这是一个非常关键且容易被忽略的点。当你读取某些需要即时计算的 DOM 属性时，浏览器为了返回最精确的值，会强制提前执行布局流程。
    *   常见的属性包括：`offsetTop`, `offsetLeft`, `offsetWidth`, `offsetHeight`, `scrollTop`, `scrollLeft`, `scrollWidth`, `scrollHeight` 等。
    *   调用 `getComputedStyle()` 或 `getBoundingClientRect()` 方法。

### b. 仅触发绘制 (Paint) 的常见操作

*   修改 `color`, `background-color`, `border-color`, `outline-style`, `visibility`, `text-decoration` 等不影响几何布局的样式。

### c. 仅触发合成 (Composite) 的常见操作

*   通常只有 `transform` 和 `opacity` 这两个属性的改变能被高度优化，仅触发合成。

## 4. 浏览器优化策略：渲染队列

考虑到频繁的重排和重绘会严重影响性能，现代浏览器实现了一套**渲染队列（Render Queue）**机制来进行优化。

*   **机制**：当你的代码触发了重排或重绘时，浏览器并不会立即执行，而是将这个“待处理”的变更放入一个队列中。浏览器会继续执行后续的 JS 代码。
*   **批量执行**：浏览器会等到一个合适的时机（比如当前 JS 代码块执行完毕，或者队列中的变更积累到一定程度），然后**一次性地**将队列中的所有变更批量处理掉，这样多次的重排/重绘就有可能被合并为一次。

**但是**，正如上面提到的，如果你在代码中**读取了需要即时计算的布局属性**，就会破坏这个优化机制。浏览器为了给你返回最准确的值，不得不**强制清空渲染队列**，立即执行一次重排/重绘。

**一个反面教材：**
```javascript
const elements = document.querySelectorAll('.box');
elements.forEach(el => {
  // 每次循环都强制浏览器重排，因为要读取 offsetWidth
  el.style.width = el.offsetWidth + 10 + 'px';
});
```
这个循环有 N 个元素，就会导致 N 次布局，性能极差。

## 5. 如何优化：向“合成层”看齐

1.  **样式集中改变**：
    *   避免逐条修改样式，而是通过切换 CSS class 或使用 `cssText` 属性一次性修改。
    ```javascript
    // 不推荐
    el.style.width = '100px';
    el.style.height = '100px';
    el.style.margin = '10px';

    // 推荐
    el.className += ' new-style'; // 或者 el.classList.add('new-style')
    // 或者
    el.style.cssText = 'width: 100px; height: 100px; margin: 10px;';
    ```

2.  **批量操作 DOM**：
    *   当需要对 DOM 进行多次操作时，使用 `DocumentFragment` 作为临时容器，在内存中完成所有修改，然后一次性地将其添加到真实 DOM 中。
    *   或者，可以先将元素 `display: none`，对其进行多次修改后，再恢复显示。

3.  **避免强制同步布局**：
    *   在修改样式后，避免立即读取会触发强制同步布局的属性。可以先将需要读取的值缓存到一个变量中。
    ```javascript
    // 优化版
    const elements = document.querySelectorAll('.box');
    const widths = [];
    elements.forEach(el => widths.push(el.offsetWidth)); // 先统一读
    elements.forEach((el, i) => {
      el.style.width = widths[i] + 10 + 'px'; // 再统一写
    });
    ```

4.  **拥抱合成层动画**：
    *   **优先使用 `transform` 和 `opacity`**：实现位移、缩放、旋转和淡入淡出等动画时，优先使用这两个属性。
    *   **原理回顾**：正如我们在第一章所学，合成操作主要由**合成器线程**和 **GPU** 负责，它完全**独立于主线程**（JS 和布局/绘制所在线程）。因此，即使主线程繁忙，由 `transform` 和 `opacity` 驱动的动画依然能保持丝滑流畅。

5.  **提升为合成层 (`will-change`)**：
    *   对于即将要进行频繁变换的元素，可以使用 `will-change` 属性（例如 `will-change: transform;`）提前“通知”浏览器。浏览器会为该元素创建一个独立的合成层，使其后续的变换开销更小。
    *   **注意**：不要滥用 `will-change`。为太多元素创建合成层会占用大量内存和 GPU 资源，反而可能降低性能。应只对关键的、复杂的动画元素使用。
