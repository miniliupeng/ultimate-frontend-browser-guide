# 08-前端性能指标与优化策略

前端性能优化是一个系统性工程，它不仅仅是让网站“感觉”更快，更是通过一系列可量化的**指标**来精准度量用户体验，并针对性地实施优化策略。

## 1. 核心 Web 指标 (Core Web Vitals)

Core Web Vitals 是由 Google 提出的一组以用户为中心的关键性能指标，它们衡量了网页加载速度、交互性和视觉稳定性。这些指标是 Google 搜索排名的一个考量因素。

### a. LCP (Largest Contentful Paint) - 最大内容绘制

*   **定义**：衡量**加载性能**。它指的是视口内可见的**最大图像或文本块**完成渲染的时间点。
*   **目标**：LCP 应在页面首次开始加载后的 **2.5 秒**内发生。
*   **解读**：LCP 告诉我们用户看到页面主要内容的速度。一个快速的 LCP 能让用户感觉页面加载迅速，内容有效。
*   **优化方向**：
    *   **服务器响应时间优化**：使用 CDN、缓存、更快的服务器。
    *   **资源加载优化**：优化图片大小、使用 WebP 等现代格式、预加载关键资源。
    *   **阻塞渲染的资源**：减少阻塞渲染的 CSS 和 JavaScript。

### b. FID (First Input Delay) - 首次输入延迟

*   **定义**：衡量**交互性**。它测量的是从用户**首次**与页面进行交互（例如点击按钮、输入文本）到浏览器实际能够开始处理该事件之间的时间。
*   **目标**：FID 应小于 **100 毫秒**。
*   **解读**：FID 反映了页面的“响应能力”。一个低的 FID 保证了当用户第一次尝试与页面交互时，能够立即得到反馈，不会感到卡顿或无响应。
*   **优化方向**：
    *   **减少长任务 (Long Tasks)**：分解耗时长的 JavaScript 任务，避免长时间阻塞主线程。
    *   **使用 Web Workers**：将复杂的、非 UI 相关的计算放到后台线程。
    *   **代码分割 (Code Splitting)**：只在需要时加载 JavaScript 代码，减少主线程在页面加载初期的负担。

> **INP 将取代 FID**
> 谷歌已宣布，从 2024 年 3 月 12 日起，**INP (Interaction to Next Paint)** 将正式取代 FID 成为新的核心 Web 指标。
> *   **INP 是什么？** 它衡量的是从用户交互（点击、按键等）开始，到**下一帧被绘制出来**的总时长。这更全面地反映了用户感知到的响应能力，因为它包含了**输入延迟**、**事件处理时间**和**呈现延迟**（浏览器将更新渲染到屏幕的时间）。
> *   **为什么更优？** INP 关注的是页面生命周期内的**所有**交互，并报告最慢的那一次（或接近最慢的一次），而 FID 只关注第一次。因此，INP 能更准确地衡量一个页面的整体交互流畅度。

### c. CLS (Cumulative Layout Shift) - 累积布局偏移

*   **定义**：衡量**视觉稳定性**。它测量的是页面在加载过程中，所有意外发生的**布局偏移**的总分。
*   **目标**：CLS 分数应小于 **0.1**。
*   **解读**：CLS 反映了页面的“打扰”程度。一个低的 CLS 意味着页面元素在加载时不会突然跳动，避免了用户误点或阅读时被干扰的糟糕体验。
*   **常见原因**：
    *   没有指定尺寸的图片或视频。
    *   动态插入的广告或 iframe。
    *   Web 字体的加载导致文本闪烁或布局变化。
*   **优化方向**：
    *   **为图片和视频预留空间**：始终在 `<img>` 和 `<video>` 标签上设置 `width` 和 `height` 属性。
    *   **避免在现有内容上方动态插入内容**。
    *   **优化字体加载**：使用 `font-display` 属性或预加载字体文件。

## 2. 以用户为中心的 RAIL 性能模型

为了将各种性能指标和优化手段统一到一个更高维度的框架中，Google 提出了 **RAIL 模型**。这是一个以用户感知为核心的性能指南，旨在保证优秀的用户体验。

*   **Response (响应)**：在 **100ms** 内响应用户输入。用户的感觉是“即时”的。
    *   **对应指标**：FID / INP
*   **Animation (动画)**：在 **16ms** 内产出一帧动画，以达到 60fps 的流畅体验。
    *   **对应概念**：我们在第一章学习的“浏览器的一帧”。
*   **Idle (空闲)**：最大化利用主线程的空闲时间来执行后台任务。
    *   **对应 API**：`requestIdleCallback`
*   **Load (加载)**：在 **1 秒** 内加载完主要内容，让用户可以开始交互。
    *   **对应指标**：LCP / TTI

RAIL 模型为性能优化工作提供了一个清晰的目标：确保你的应用在这四个方面的表现都足够出色。

## 3. 其他重要性能指标

*   **FCP (First Contentful Paint) - 首次内容绘制**
    *   **定义**：浏览器渲染出**第一个** DOM 内容（文本、图片、SVG 等）的时间点。FCP 是用户感知到页面“正在加载”的第一个信号。
*   **TTI (Time to Interactive) - 可交互时间**
    *   **定义**：指页面已经完成了主要内容的渲染（FCP），并且能够可靠地响应用户输入的时间点。
*   **TBT (Total Blocking Time) - 总阻塞时间**
    *   **定义**：衡量在 FCP 和 TTI 之间，主线程被**长任务（执行时间超过 50ms 的任务）**阻塞的总时间。TBT 与 FID/INP 密切相关。

## 4. 系统性性能优化策略

### a. 加载优化

*   **关键请求**：尽早发现并加载关键资源。
    *   `preload`：用于**当前导航**中肯定会用到的资源（如LCP图片、关键CSS/JS）。
    *   `preconnect`：提前与第三方源建立连接（DNS解析、TCP握手、TLS协商）。
    *   `prefetch`：用于**未来导航**中可能用到的资源（如下一页的资源），优先级较低。
    *   `prerender`：在后台预先渲染整个页面，实现“即时”加载体验。现代浏览器主推使用 **Speculation Rules API** 来实现。

*   **Speculation Rules API 示例**：
    *   你可以在 HTML 中加入一个 `<script type="speculationrules">` 标签，来告诉浏览器你对用户未来行为的“推测”。
    ```html
    <script type="speculationrules">
    {
      "prerender": [
        {
          "source": "document",
          "where": {
            "href_matches": "/next-page.html"
          },
          "eagerness": "moderate"
        }
      ]
    }
    </script>
    ```
    *   **含义**：这段代码告诉浏览器，在当前页面中查找所有指向 `/next-page.html` 的链接。当用户鼠标悬停（`eagerness: "moderate"`）在这些链接上时，就在后台完整地预渲染 `next-page.html`。当用户最终点击时，页面便可瞬时加载。

*   **压缩**：对文本资源（HTML, CSS, JS）使用 Gzip 或 Brotli 压缩；对图片进行适当压缩和格式选择（WebP, AVIF）。
*   **缓存**：合理配置 HTTP 缓存（强缓存与协商缓存），善用 Service Worker 进行离线缓存。
*   **CDN**：将静态资源部署到 CDN，加速全球用户的访问。

### b. 渲染优化

*   **减少阻塞渲染的资源**：将 CSS 放在 `<head>` 中，将非关键的 JS 使用 `defer` 或 `async` 加载。
*   **避免重排与重绘**：遵循上一章的优化原则，如样式集中修改、使用 `transform` 等。
*   **代码分割**：利用 Webpack 等工具按需加载 JS 和 CSS。
*   **服务端渲染 (SSR) 或静态站点生成 (SSG)**：对于内容型网站，可以显著加快首屏渲染速度。

### c. 运行时优化

*   **长任务拆分**：将耗时的 JS 计算分解成小块，避免长时间阻塞主线程。
    *   **关联思考**：正如第一、二章所学，长时间的同步 JS 会阻塞事件循环，导致浏览器无法执行渲染更新（掉帧）或响应用户输入。通过 `setTimeout(..., 0)` 将长任务切分为多个宏任务，或利用 `requestIdleCallback`，可以将执行权交还给浏览器，使其有机会处理更高优先级的任务。
*   **节流 (Throttling) 与防抖 (Debouncing)**：对于高频触发的事件（如 `scroll`, `resize`），限制其执行频率。
*   **虚拟列表 (Virtual Scrolling)**：对于长列表，只渲染视口内可见的部分。
*   **Web Workers**：将 CPU 密集型任务完全移出主线程。

### d. 资源优化

*   **图片优化**：使用响应式图片、懒加载、合适的格式（WebP, AVIF）。
*   **字体优化**：使用 `font-display` 控制加载行为、只加载需要的字重、压缩字体文件。
*   **第三方脚本**：谨慎评估和异步加载第三方 JS，它们是常见的性能瓶颈。
