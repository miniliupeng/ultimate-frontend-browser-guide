# 10-图片专题优化

图片是 Web 内容的重要组成部分，但也是最常见的性能瓶颈之一。一张未经优化的图片可能会比整个页面的 HTML、CSS 和 JS 加起来还要大。图片优化不仅关乎网络传输，还涉及到客户端的**解码开销**——浏览器在渲染图片前，需要将其解码成像素数据，这个过程会占用主线程，影响页面的可交互性。

系统性地进行图片优化，对于提升 LCP 指标、减少 CLS、降低带宽消耗和改善用户体验至关重要。

## 1. 选择正确的图片格式

不同的图片格式有不同的适用场景，选择合适的格式是优化的第一步。

| 格式    | 优点                                       | 缺点                                     | 适用场景                               |
| ------- | ------------------------------------------ | ---------------------------------------- | -------------------------------------- |
| **JPEG**| 压缩率高，文件体积小，兼容性好             | **有损压缩**，不支持透明度               | 色彩丰富的照片、Banner 图等            |
| **PNG** | **无损压缩**，支持透明通道（alpha channel）| 体积较大                                 | 需要透明背景的 Logo、图标、复杂图表    |
| **GIF** | 支持动画，支持透明度（但效果有限）         | 只能显示 256 种颜色，画质差，体积大    | 简单的动画表情包（正逐渐被视频替代）   |
| **SVG** | **矢量格式**，无限缩放不失真，体积小       | 不适合表示复杂的、色彩丰富的照片         | Logo、图标、简单的插画和图表           |
| **WebP**| **现代格式**，提供优秀的有损和无损压缩，支持透明度和动画，**体积远小于 JPEG 和 PNG** | 兼容性问题（尽管现代浏览器已普遍支持） | **首选格式**，可以作为 JPEG 和 PNG 的替代品 |
| **AVIF**| **下一代格式**，基于 AV1 视频编码，压缩率比 WebP 更高，画质更好 | 编码耗时较长，兼容性仍在发展中         | 未来的趋势，可作为 WebP 的备选方案     |

**策略**：优先使用 WebP/AVIF 等现代格式，并提供 JPEG/PNG 作为兼容性回退。可以使用 `<picture>` 标签来实现。

## 2. 图片压缩

*   **有损压缩 (Lossy)**：通过移除部分人眼不敏感的图像数据来减小文件体积。压缩率高，但会损失一部分图像质量。JPEG 和 WebP (有损模式) 属于此类。
*   **无损压缩 (Lossless)**：在不损失任何图像质量的前提下，通过优化图像的存储方式来减小文件体积。压缩率相对较低。PNG, GIF, SVG, WebP (无损模式) 属于此类。

**工具**：
*   **在线工具**：TinyPNG, Squoosh 等，可以直观地看到压缩前后的效果。
*   **构建工具插件**：imagemin (Webpack/Gulp/Grunt) 等，可以在项目构建流程中自动完成压缩。

## 3. 响应式图片：为不同设备提供不同尺寸

在移动设备上加载桌面端尺寸的大图是一种巨大的浪费。**响应式图片**技术允许浏览器根据设备的**屏幕尺寸、分辨率（DPR）和网络状况**，来选择加载最合适的一张图片。

### a. `srcset` 属性

`srcset` 属性允许我们在 `<img>` 标签中提供一个以逗号分隔的图像源列表，并为每个源指定描述符。

*   **宽度描述符 (`w`)**：
    ```html
    <img srcset="small.jpg 500w, medium.jpg 1000w, large.jpg 2000w"
         sizes="(max-width: 600px) 100vw, 50vw"
         src="medium.jpg" alt="A responsive image">
    ```
    *   `srcset`: 定义了图片源列表及其**真实宽度** (`500w`, `1000w` ...)。
    *   `sizes`: 向浏览器提供一个“提示”，告知图片在不同视口宽度下的**预期显示宽度**。
        *   `(max-width: 600px) 100vw`: 当视口宽度小于等于 600px 时，图片将占据视口宽度的 100%。
        *   `50vw`: 在其他情况下（大于 600px），图片将占据视口宽度的 50%。
    *   **浏览器决策**：浏览器会根据 `sizes` 属性计算出图片在当前设备上的显示宽度，然后从 `srcset` 列表中选择一个最接近该宽度的、最合适的图片源来加载。
    *   `src`: 作为不支持 `srcset` 的旧浏览器的回退。

*   **像素密度描述符 (`x`)**：
    ```html
    <img srcset="icon-1x.png 1x, icon-2x.png 2x, icon-3x.png 3x"
         src="icon-1x.png" alt="A high-res icon">
    ```
    *   这种方式更简单，适用于根据设备像素比（DPR）来提供不同分辨率的图标或固定尺寸的图片。

### b. `<picture>` 元素

`<picture>` 元素提供了更强大的艺术指导能力，允许你根据不同的媒体查询条件来完全更换图片源，或者提供对现代图片格式（如 WebP）的优雅降级。

```html
<picture>
  <!-- 如果浏览器支持 AVIF，优先使用此源 -->
  <source srcset="image.avif" type="image/avif">
  <!-- 如果不支持 AVIF 但支持 WebP，使用此源 -->
  <source srcset="image.webp" type="image/webp">
  <!-- 如果以上都不支持，使用 JPEG 作为最终回退 -->
  <img src="image.jpg" alt="My image">
</picture>
```

## 4. 图片懒加载 (Lazy Loading)

懒加载是一种延迟加载非视口内（off-screen）图片的技术。当用户滚动页面，图片即将进入视口时，才开始加载它。这可以极大地提升首屏加载速度，并节省用户的带宽。

### a. 原生懒加载

现代浏览器提供了原生的懒加载支持，实现起来极其简单：

```html
<img src="image.jpg" loading="lazy" alt="An image to be lazy-loaded">
<iframe src="widget.html" loading="lazy"></iframe>
```
`loading="lazy"` 属性会告诉浏览器推迟加载该图片或 iframe，直到用户滚动到它附近。

### b. 使用 Intersection Observer API

对于需要兼容旧浏览器或实现更复杂懒加载逻辑的场景，**Intersection Observer API** 是目前最佳的方案。它提供了一种异步地观察目标元素与其祖先元素或顶级视口交叉状态变化的方法。

**基本流程**：
1.  初始时，`<img>` 标签的 `src` 属性可以不设置，或者设置一个轻量的占位符图片。真实的图片 URL 存放在 `data-src` 属性中。
2.  创建一个 `IntersectionObserver` 实例，让它观察所有待懒加载的图片。
3.  当一个图片元素进入视口时，Observer 的回调函数会被触发。
4.  在回调函数中，将 `data-src` 的值赋给 `src` 属性，从而触发图片的加载。
5.  图片加载完成后，停止对该元素的观察。

**注意：防止布局偏移（CLS）**
无论是使用原生懒加载还是 JS 方案，都**必须**在 `<img>` 标签上设置明确的 `width` 和 `height` 属性，或者通过 CSS 的 `aspect-ratio` 属性，为即将加载的图片预留出准确的空间。这是避免页面在图片加载时发生内容跳动、导致 CLS 指标恶化的关键。

### c. 配合占位符提升体验

在图片完全加载出来之前，使用占位符可以有效地提升用户体验，并进一步防止布局偏移。

*   **纯色占位符**：最简单的方式，根据图片主题色生成一个纯色的背景块。
*   **LQIP (Low Quality Image Placeholders)**：低质量图片占位符。先加载一张尺寸极小、高度模糊的同内容图片（通常只有几百字节），然后在其之上渐进地加载高清原图，给用户一种“渐进明晰”的加载感。
*   **SQIP (SVG-based Image Placeholders)**：使用 SVG 生成一种由简单形状和颜色构成的、能模拟原图轮廓的矢量占位符，体积比 LQIP 更小。

```javascript
const lazyImages = document.querySelectorAll('img[data-src]');

const observer = new IntersectionObserver((entries, observer) => {
  entries.forEach(entry => {
    // 如果元素进入了视口
    if (entry.isIntersecting) {
      const img = entry.target;
      // For LQIP, the low quality image is already in src,
      // we just need to load the high quality one.
      const highResSrc = img.dataset.src;
      img.src = highResSrc;
      img.removeAttribute('data-src');

      img.onload = () => {
        img.classList.remove('lazy-blur'); // remove blur effect
      };
      
      observer.unobserve(img);
    }
  });
});

lazyImages.forEach(img => {
  observer.observe(img);
});
```

## 5. 使用 CDN 进行图片分发与处理

将图片托管在 CDN 上，除了能享受 CDN 本身的加速优势外，许多现代 CDN 服务商还提供了强大的**实时图片处理**能力。
*   **动态格式转换**：CDN 可以根据客户端请求的 `Accept` 头部，自动将图片转换为 WebP 或 AVIF 格式返回，无需后端进行复杂的适配。
*   **实时裁剪与缩放**：可以通过在图片 URL 中添加参数，让 CDN 返回指定尺寸、裁剪方式或质量的图片。例如 `image.jpg?w=500&h=300&q=80`。这极大地简化了响应式图片的管理。
