# 08-深入JS内存：内存泄漏与调试

内存泄漏（Memory Leak）是指应用程序中已分配的内存，由于某种原因未能被正确释放，导致其持续被占用。随着时间的推移，泄漏的内存会越积越多，可能导致应用性能下降、页面卡顿，甚至浏览器崩溃。

理解常见的内存泄漏场景并掌握调试工具，是每一位高级前端工程师的必备技能。

## 1. 常见的内存泄漏场景（附示例）

内存泄漏的根本原因是：**一个不再需要的对象，仍然被一个可达的对象（或全局变量）直接或间接地引用着，导致垃圾回收（GC）无法回收它。**

### a. 意外的全局变量

*   **原因**：在非严格模式下，给一个未声明的变量赋值，会在全局对象（`window`）上创建一个同名属性。如果这个变量引用了一个大对象，那么只要页面不关闭，这个对象就永远不会被回收。
*   **示例**：
    ```javascript
    function createLeakingObject() {
      // 'leakingData' 未经 'var', 'let' 或 'const' 声明
      leakingData = new Array(1000000).join('*'); // 变成 window.leakingData
    }
    createLeakingObject();
    // 即使 createLeakingObject 执行完毕，leakingData 依然存在
    ```
*   **如何避免**：始终使用 `'use strict';` 开启严格模式。

### b. 被遗忘的定时器或回调函数

*   **原因**：`setInterval` 或 `setTimeout` 如果在组件销毁或不再需要时没有被清除，那么它们的回调函数以及回调函数所引用的外部变量（闭包），将一直无法被回收。
*   **示例**：
    ```javascript
    function setupInterval() {
      const someLargeObject = { data: new Array(1000000).join('*') };
      
      setInterval(() => {
        // 匿名回调函数引用了 someLargeObject
        console.log(someLargeObject.data.length);
      }, 1000);
      
      // 没有调用 clearInterval
    }
    setupInterval();
    ```

*   **如何避免**：在组件的销毁生命周期中（如 React 的 `useEffect` 的清理函数、Vue 的 `beforeDestroy`/`unmounted`），务必调用 `clearInterval` 或 `clearTimeout`。对于 `addEventListener` 等添加的事件监听，也要在组件销毁时调用 `removeEventListener`。

### c. 分离的 DOM 节点 (Detached DOM)

*   **原因**：一个 DOM 节点已经从 DOM 树中被移除，但 JavaScript 代码中仍然保留着对它的引用。
*   **示例**：
    ```javascript
    let detachedElement = null;

    function createDetachedNode() {
      const ul = document.createElement('ul');
      for (let i = 0; i < 10; i++) {
        const li = document.createElement('li');
        ul.appendChild(li);
      }
      // 将 ul 存入一个全局可达的变量
      detachedElement = ul;
    }

    function removeNodeFromDOM() {
      // 假设页面上有一个 id 为 'container' 的元素
      const container = document.getElementById('container');
      // 将 detachedElement 从 DOM 树中移除
      if (container && container.firstChild) {
        container.removeChild(container.firstChild);
      }
    }
    
    // 1. 创建并引用
    createDetachedNode(); 
    document.getElementById('container').appendChild(detachedElement);
    // 2. 从 DOM 中移除，但 JS 引用依然存在
    removeNodeFromDOM(); 
    // detachedElement 及其所有子节点都无法被 GC 回收
    ```
*   **如何避免**：在移除 DOM 节点后，确保所有指向它的 JavaScript 引用都被设置为 `null`。

### d. 闭包的无意引用

*   **原因**：闭包会使其外部函数的作用域持续存在。如果一个外部函数的变量引用了一个大对象，而这个变量又被一个生命周期很长的内部函数（闭包）所使用，就可能导致内存泄漏。
*   **示例**：
    ```javascript
    function createClosure() {
      const largeObject = new Array(1000000).join('*');
      
      return function(name) {
        // largeObject 在这里并没有被使用，但它依然存活于闭包的作用域链中
        console.log(`Hello, ${name}`);
      };
    }

    const myClosure = createClosure();
    // myClosure 将一直存在，导致 largeObject 无法被回收
    ```
*   **如何避免**：谨慎设计闭包。如果内部函数不需要某个外部变量，应在不再使用时将其设置为 `null`，或通过重构避免不必要的引用。
*   **优化后示例**：
    ```javascript
    function createClosureOptimized() {
      const largeObject = { data: new Array(1000000).join('*'), name: 'MyObject' };
      const name = largeObject.name; // 只提取需要的数据
      
      return function() {
        // 现在闭包只引用了 name, 而不是整个 largeObject
        console.log(`Hello, ${name}`);
      };
    }
    const myClosureOptimized = createClosureOptimized();
    ```

### e. Map/Set 中的对象引用

*   **原因**：当使用 `Map` 或 `Set` 存储对象时，如果这些对象在外部已经不再需要，但没有从 `Map`/`Set` 中显式地移除，那么 `Map`/`Set` 就会一直持有对这些对象的**强引用**，阻止它们被 GC 回收。
*   **示例**：
    ```javascript
    const elementMap = new Map();
    
    function watchElement(element) {
      elementMap.set(element, { isWatched: true });
    }

    let myElement = document.getElementById('my-element');
    watchElement(myElement);

    // 稍后，DOM 节点从页面移除了
    myElement.remove();
    myElement = null;
    
    // 此时，虽然 myElement 变量被清空，但 elementMap 依然持有对
    // 那个 DOM 节点的引用，导致它和它的所有子节点都无法被回收。
    ```
*   **如何避免（最佳实践）**：使用 **`WeakMap`** 或 **`WeakSet`**。它们的键（对于 `WeakMap`）或值（对于 `WeakSet`）是**弱引用**的。这意味着，如果一个对象只被 `WeakMap`/`WeakSet` 所引用，那么 GC 会自动忽略这个引用并回收该对象，相应的条目也会从集合中自动消失。

## 2. 使用 DevTools Memory 面板进行调试

Chrome DevTools 的 `Memory` 面板是定位内存泄漏的终极武器。它主要提供了三种工具：

*   **Heap snapshot (堆快照)**：这是定位内存泄漏最核心、最强大的工具。它能拍下某一时刻堆内存的完整视图，用于分析对象之间的引用关系。
*   **Allocation instrumentation on timeline (时间线上的分配检测)**：这个工具可以记录下随时间发生的内存分配和释放活动。它非常适合用来定位那些因**频繁创建和销毁临时对象**而导致 GC 压力过大、引发页面卡顿的问题。
*   **Allocation sampling (分配采样)**：这是一个开销较低的内存分析工具，它通过采样的方式来持续监控内存分配。它适合用来排查那些持续时间长、泄漏缓慢的问题。

对于典型的内存泄漏问题，我们主要使用**堆快照**。

### 调试流程

1.  **打开页面并执行操作**：
    *   以无痕模式打开你的页面，以避免插件干扰。
    *   执行一系列你怀疑可能导致内存泄漏的操作。例如，反复打开和关闭一个弹窗组件。

2.  **拍摄第一个堆快照 (Baseline)**：
    *   打开 DevTools → `Memory` 面板。
    *   选择 `Heap snapshot`。
    *   点击 `Take snapshot` 按钮。这将拍下当前时刻堆内存中所有对象的状态。

3.  **再次执行操作**：
    *   回到页面，**重复**第一步中的操作。确保执行的次数和方式与第一次完全一致。

4.  **手动触发垃圾回收**：
    *   在 `Memory` 面板中，点击左上角的**垃圾桶图标 (Collect garbage)**。这一步非常重要，它可以强制浏览器执行一次垃圾回收，清除那些可以被正常回收的内存，只留下真正“泄漏”的对象。

5.  **拍摄第二个堆快照**：
    *   再次点击 `Take snapshot` 按钮。

6.  **对比两次快照**：
    *   在快照列表中，选择第二次拍摄的快照。
    *   在快照视图上方的下拉菜单中，选择 **`Comparison`** 模式，并将对比目标设置为第一个快照 (`Snapshot 1`)。
    *   点击 **`Retainers`** 视图。

### 如何分析对比结果

*   **`Comparison` 视图**：这个视图会显示两次快照之间，对象数量的变化。
    *   **`# New`**: 在快照1之后、快照2之前新分配的对象数量。
    *   **`# Delta`**: 对象的净增减数量。**我们主要关注 `# Delta` 为正值的对象**，特别是那些我们预期在操作结束后应该被销毁的对象（例如组件实例）。
*   **`Retainers` 视图（支配树）**：
    *   在 `Comparison` 视图中，找到一个你怀疑是泄漏了的对象（例如，某个组件的构造函数名，如 `MyComponent`）。
    *   点击展开它，你会在下方的 **`Retainers`** 视图中看到一个**引用链**。这个链展示了**为什么这个对象无法被垃圾回收**——即它被谁直接或间接地引用着。
    *   从你的目标对象开始，向上追溯这条引用链，直到找到一个你熟悉的代码对象（例如一个全局变量、一个事件监听器、一个定时器回调）。这个“源头”通常就是导致内存泄漏的根本原因。
    *   **红色**的条目通常表示“分离的 DOM 树”，是排查的重点。

通过这套“**操作 → 快照 → 重复操作 → GC → 快照 → 对比**”的流程，我们就可以精准地定位到那些在操作结束后未能被成功回收的对象，并通过分析其引用链找到问题的根源。
