# 06-浏览器垃圾回收（GC）机制

垃圾回收（Garbage Collection, GC）是一种自动内存管理的机制。在 JavaScript 中，开发者无需（也无法）手动分配和释放内存，这些工作都由 JS 引擎（如 V8）在后台自动完成。GC 的核心任务是**找出那些不再被使用的内存（垃圾），并将其回收，以便后续代码可以重新利用这部分空间**。

V8 的垃圾回收策略是基于**分代假说（Generational Hypothesis）** 的，这个假说有两个核心特点：
1.  **大部分对象“朝生夕死”**：它们在被创建后很快就不再被需要。
2.  **“老”对象，很少“死”**：存活时间越长的对象，就越有可能持续存活下去。

基于这个假说，V8 将其堆内存（Heap）分为了两个主要区域：**新生代（Young Generation）** 和 **老生代（Old Generation）**。

## 1. 新生代 (Young Generation)

*   **特点**：用于存放存活时间较短的新对象。新生代空间较小（通常只有几 MB），但垃圾回收非常频繁。
*   **回收算法**：**Scavenge（清除）算法**，这是一种典型的“以空间换时间”的策略。

### Scavenge 算法流程

新生代内存被平均分成了两块相等的空间：**From 空间（使用中）** 和 **To 空间（空闲）**。

1.  **分配**：所有新创建的对象首先都会被分配在 **From 空间**。
2.  **标记**：当 From 空间即将被占满时，GC 开始工作。它会从根对象（如全局对象 `window`）出发，遍历所有可达的**活动对象**，并给它们做一个标记。
3.  **复制与整理**：GC 将所有被标记的**活动对象**从 From 空间复制到 **To 空间**，并进行内存整理，使它们在 To 空间中紧凑地排列。那些没有被标记的非活动对象（垃圾）则被留在 From 空间。
4.  **清空与角色互换**：复制完成后，整个 From 空间内的对象都被视为垃圾，可以被一次性清空。然后，From 空间和 To 空间的角色发生互换。原来的 To 空间变成了新的 From 空间，继续进行对象分配；原来的 From 空间则变成了新的 To 空间，等待下一次 GC。

### 对象的晋升 (Promotion)

如果在一次 Scavenge 回收过程中，一个对象依然存活，那么它就被认为是经历了一轮回收。如果一个对象连续经历了**两轮**回收依然存活，V8 就会认为它是一个存活时间较长的对象，并将其**晋升**到**老生代**内存区。

此外，如果复制一个对象到 To 空间时，发现 To 空间的使用率已经超过了 25%，那么这个对象也会被直接晋升到老生代。

## 2. 老生代 (Old Generation)

*   **特点**：用于存放存活时间较长的对象（从新生代晋升而来）以及一些较大的对象。老生代空间较大，垃圾回收的频率相对较低。
*   **回收算法**：**Mark-Sweep（标记-清除）** 和 **Mark-Compact（标记-整理）** 相结合。

### a. Mark-Sweep (标记-清除)

由于老生代的对象数量多、存活率高，如果再使用 Scavenge 算法（需要复制大量对象）会非常低效。因此，老生代采用 Mark-Sweep 算法。

1.  **标记 (Marking)**：GC 从根对象开始，遍历堆中所有可达的**活动对象**，并打上标记。
2.  **清除 (Sweeping)**：遍历整个堆内存，将所有**没有被标记**的对象（垃圾）进行回收，并清除它们的内存。

**缺点**：Mark-Sweep 会在内存中产生大量不连续的**内存碎片**。如果后续需要分配一个较大的对象，可能会因为找不到足够大的连续内存空间而失败。

### b. Mark-Compact (标记-整理)

为了解决内存碎片问题，V8 引入了 Mark-Compact 算法。它通常在 Mark-Sweep 执行多次，空间碎片化问题变得比较严重时才会被触发。

1.  **标记 (Marking)**：同 Mark-Sweep。
2.  **整理 (Compacting)**：在标记完成后，此算法会将所有**活动对象**向内存的一端移动，使它们紧凑地排列。移动完成后，直接清理掉边界以外的所有内存。

**缺点**：移动对象的过程会比较耗时。

因此，V8 在老生代主要使用 Mark-Sweep，并在必要时才使用 Mark-Compact 来处理内存碎片。

## 3. 全停顿 (Stop-The-World) 与现代 GC 优化

需要注意的是，由于 JavaScript 是单线程的，**在进行垃圾回收时，JS 脚本的执行必须暂停**，这个现象被称为“**全停顿（Stop-The-World）**”。

为了最大限度地减少全停顿带来的卡顿感，V8 的垃圾回收器（项目代号 **Orinoco**）引入了许多先进技术，将原本需要长时间的 GC 过程打散或放到后台执行。

*   **增量标记 (Incremental Marking)**：这是针对老生代标记过程的优化。V8 不会一次性遍历整个堆，而是将标记工作切分成许多小块，穿插在 JS 应用逻辑的执行间隙中进行。这显著减少了单次停顿的最长时间。

*   **并行回收 (Parallel GC)**：在执行垃圾回收时（无论是新生代还是老生代），V8 会启动多个**辅助线程**来同时进行工作。这就像多个人一起做大扫除，虽然“大扫除”期间你（主线程）仍然不能干活，但总的打扫时间被大大缩短了。

*   **并发回收 (Concurrent GC)**：这是更进一步的优化。V8 允许**辅助线程**在后台执行一部分垃圾回收任务（主要是标记），而此时 **JS 主线程可以继续运行**，几乎不受影响。这是实现“无停顿”或“低停顿”GC 的关键技术。

## 4. 可达性 vs. 引用计数：GC 算法的选择

V8 采用的标记类算法，其核心思想是**可达性 (Reachability)**。即从根对象出发，能访问到的对象就是“活”的，不能访问到的就是“死”的。

除了可达性分析，还有一种经典的垃圾回收算法叫**引用计数 (Reference Counting)**。

*   **工作原理**：为每个对象维护一个引用计数器。当有新的引用指向它时，计数器+1；当引用失效时，计数器-1。当计数器归零时，该对象就被回收。
*   **致命缺点**：无法回收**循环引用**的对象。例如：
    ```javascript
    let objA = {};
    let objB = {};
    objA.b = objB;
    objB.a = objA;
    // 此时 objA 和 objB 的引用计数都为 1
    
    objA = null;
    objB = null;
    // 外部引用消失，但它们内部互相引用，计数器永远无法归零
    ```
    在这种场景下，`objA` 和 `objB` 将成为无法回收的“孤岛”，造成内存泄漏。而基于可达性分析的 Mark-Sweep 算法则可以正确地处理这种情况，因为这个“孤岛”从根对象出发是不可达的。

## 5. 常见的内存泄漏场景与排查

内存泄漏是指程序中已分配的内存，由于某种原因程序未释放或无法释放，造成系统内存的浪费。常见的场景有：

*   **意外的全局变量**：未声明的变量被附加到全局对象上。
*   **被遗忘的定时器**：`setInterval` 如果没有被 `clearInterval`，其回调函数及其依赖的变量将一直无法被回收。
*   **分离的 DOM 节点**：一个 DOM 节点从 DOM 树中被移除了，但仍然有一个 JavaScript 变量在引用它。
*   **闭包使用不当**：闭包会使其内部函数持有外部作用域的引用，如果这些引用不再需要但没有被解除，就会导致内存泄漏。

### 使用 Chrome DevTools 进行排查

1.  **Performance 面板**：通过录制一段时间的操作，观察内存（Memory）曲线图。如果内存占用持续上升，无法回落到一个稳定水平，则很可能存在内存泄漏。
2.  **Memory 面板**：这是排查内存泄漏的利器。
    *   **Heap snapshot (堆快照)**：可以为当前的内存状态拍摄一张快照。通常的做法是在页面加载后拍一张，执行一系列操作后再拍一张，然后**对比两张快照**。通过查看两次快照之间新增的对象，可以定位到可疑的内存增长点，特别是 “Detached” (分离的) DOM 树，这是最常见的泄漏源之一。
