# 07-JS核心理论：执行上下文、作用域链与闭包

要真正掌握 JavaScript，就必须理解其代码在执行时内部发生了什么。执行上下文、作用域链和闭包是 JS 语言最核心、最底层的概念，它们共同决定了变量和函数的可访问性以及 `this` 的指向。

## 1. 执行上下文 (Execution Context, EC)

**执行上下文**可以理解为是 JavaScript 代码被**执行时**所需的环境。当 JS 引擎运行代码时，它会为不同类型的代码创建不同类型的执行上下文。

*   **全局执行上下文 (Global EC)**：这是最基础的上下文。当 JS 文件被加载和执行时，引擎会首先创建一个全局执行上下文。这个上下文在整个页面生命周期中只有一个，并且在浏览器关闭时被销毁。在浏览器环境中，全局对象就是 `window`，`this` 在全局上下文中也指向 `window`。
*   **函数执行上下文 (Function EC)**：每当一个**函数被调用**时，就会为该函数创建一个新的执行上下文。每个函数都有自己独立的执行上下文。
*   **Eval 执行上下文**：通过 `eval()` 函数执行的代码也有自己的执行上下文（不推荐使用）。

### 执行上下文的创建过程

一个执行上下文的创建分为两个阶段：**创建阶段**和**执行阶段**。

#### a. 创建阶段 (Creation Phase)

在代码被逐行执行**之前**，JS 引擎会先在“幕后”做一些准备工作，即创建执行上下文。这个阶段发生了三件重要的事情：

1.  **确定 `this` 的值 (This Binding)**：
    *   在全局上下文中，`this` 指向全局对象 (`window`)。
    *   在函数上下文中，`this` 的值取决于函数的**调用方式**。其绑定规则有以下几种，优先级从高到低：
        1.  **`new` 绑定**：通过 `new` 关键字调用构造函数时，`this` 会被绑定到新创建的实例对象上。
        2.  **显式绑定**：通过 `call()`, `apply()`, `bind()` 方法调用函数时，`this` 会被显式地绑定到传入的第一个参数上。
        3.  **隐式绑定**：当函数作为对象的方法被调用时（如 `obj.myFunc()`），`this` 会被绑定到调用该方法的对象（`obj`）上。
        4.  **默认绑定**：在独立的函数调用中（不符合以上任何规则），非严格模式下 `this` 指向全局对象 `window`，严格模式 (`'use strict'`) 下为 `undefined`。
    *   **箭头函数的特殊性**：箭头函数 (`=>`) 没有自己的 `this` 绑定。它会捕获其**定义时**所在词法作用域的 `this` 值，一旦确定，就不会再改变。

2.  **创建词法环境 (Lexical Environment)**：
    *   **词法环境**是一个内部数据结构，用于存储当前上下文中的**变量和函数声明**。它由两部分组成：
        *   **环境记录 (Environment Record)**：存储变量和函数声明的实际位置。
        *   **对外部环境的引用 (Outer Environment Reference)**：一个指向其**外部**词法环境的链接，这构成了作用域链的基础。
    *   在这个阶段，JS 引擎会扫描当前上下文中的函数声明、`var` 变量声明，并将它们记录下来。这就是**变量提升 (Hoisting)** 的来源：
        *   对于**函数声明 (function declaration)**，会完整地创建函数并存储其引用。
        *   对于 **`var` 声明的变量**，会为其分配内存并初始化为 `undefined`。
        *   对于 **`let` 和 `const` 声明的变量**，也会被记录下来，但**不会被初始化**。它们被置于一个“**暂时性死区 (Temporal Dead Zone, TDZ)**”中，在声明语句执行之前访问它们会抛出错误。

3.  **创建变量环境 (Variable Environment)**：
    *   它也是一个词法环境，但只用于存储 `var` 声明的变量。`let` 和 `const` 的声明则存储在词法环境中。

#### b. 执行阶段 (Execution Phase)

在创建阶段完成后，JS 引擎开始逐行执行代码。在这个阶段，引擎会完成变量的赋值、执行函数调用等操作。

## 2. 调用栈 (Call Stack)

我们在“事件循环”一章中已经介绍过调用栈。现在我们可以更精确地定义它：调用栈是一个后进先出（LIFO）的栈，专门用于**存储和管理执行上下文**。

*   当 JS 引擎开始执行代码时，它首先将**全局执行上下文**压入栈底。
*   每当一个函数被调用时，就会创建一个新的**函数执行上下文**，并将其压入栈顶。
*   当栈顶的函数执行完毕后，其对应的执行上下文就会从栈中弹出。
*   最终，当所有代码执行完毕，全局执行上下文也会被弹出，调用栈清空。

## 3. 作用域链 (Scope Chain)

**作用域 (Scope)** 定义了变量和函数在代码中的可访问区域。JavaScript 采用的是**词法作用域 (Lexical Scoping)**，也叫静态作用域。

*   **词法作用域**：意味着变量和函数的可访问性，在**代码编写时**就已经被确定下来了，并且不会在运行时改变。它取决于代码块（`{}`）和函数的嵌套关系。

**作用域链**是在执行上下文的**创建阶段**，通过**词法环境**的“**对外部环境的引用 (Outer)**”这个链接建立起来的。

*   **工作原理**：当代码在一个执行环境中需要访问一个变量时：
    1.  JS 引擎首先在**当前**执行上下文的词法环境中查找。
    2.  如果找不到，它就会顺着“外部环境引用”这个“链条”，去**外部**（父级）的词法环境中查找。
    3.  这个过程会一直持续下去，沿着作用域链一直向上，直到找到该变量，或者到达最顶层的**全局执行上下文**。
    4.  如果在全局上下文中仍然找不到，就会抛出 `ReferenceError`。

## 4. 闭包 (Closure)

**闭包**是 JavaScript 中一个强大而独特的概念。一个被广为接受的定义是：

> **当一个函数能够记住并访问其所在的词法作用域时，即使该函数在其词法作用域之外执行，也会产生闭包。**

简单来说，闭包就是 **“一个函数”** 和 **“它在创建时所能访问的作用域”** 的组合。

```javascript
function outer() {
  const outerVar = 'I am outside!';
  
  function inner() {
    // inner 函数访问了其外部函数 outer 的变量 outerVar
    console.log(outerVar);
  }
  
  return inner; // 返回了 inner 函数
}

const myClosure = outer(); // outer() 执行完毕，其执行上下文已从调用栈中弹出
myClosure(); // 但 inner 函数依然可以访问 outerVar，输出 "I am outside!"
```

### 闭包的原理

*   在 `outer` 函数被调用时，创建了 `outer` 的执行上下文，其词法环境中包含了 `outerVar`。
*   `inner` 函数在 `outer` 函数**内部定义**，所以 `inner` 的词法环境中的“外部环境引用”指向了 `outer` 的词法环境。
*   当 `outer` 函数返回 `inner` 函数时，`inner` 函数本身被赋值给了 `myClosure`。
*   关键点：由于 `inner` 函数仍然存活（被 `myClosure` 引用），并且它持有对其创建时所在词法环境（即 `outer` 的词法环境）的引用，**垃圾回收机制（GC）就不会回收 `outer` 的词法环境**，特别是被 `inner` 使用到的 `outerVar`。
*   因此，当 `myClosure()`（即 `inner` 函数）在全局作用域中被调用时，它仍然可以通过其内部的作用域链，找到并访问那个本应“消失”的 `outerVar`。

### 闭包的应用与注意事项

*   **应用**：
    *   **数据封装与私有变量**：创建只有内部函数才能访问的“私有”变量。
    *   **模块化**：在模块模式中用于创建私有作用域。
    *   **函数柯里化、高阶函数**等。
*   **注意事项**：
    *   **内存泄漏**：由于闭包会使其外部作用域的变量持续存在于内存中，如果不当使用（例如，在一个不再需要的闭包中意外地引用了一个大对象），可能会导致内存泄漏。

### 闭包的经典陷阱：循环中的闭包

这是一个非常经典的面试题，也是理解闭包与作用域交互的试金石。

**问题代码 (使用 `var`)**:
```javascript
for (var i = 1; i <= 5; i++) {
  setTimeout(function timer() {
    console.log(i);
  }, i * 1000);
}
```
很多人期望代码会每隔一秒依次输出 `1, 2, 3, 4, 5`，但实际结果是：大约5秒后，**连续输出五个 `6`**。

**原因分析**：
*   `for` 循环是同步代码，它会很快执行完毕。`setTimeout` 注册了5个宏任务（timer回调），但它们都会在循环结束后才开始执行。
*   `var` 是函数作用域。在循环中，所有 `timer` 函数共享了同一个**全局作用域**中的变量 `i`。
*   当循环结束时，`i` 的值已经变成了 `6`。
*   大约1-5秒后，当 `timer` 回调函数真正被执行时，它们去自己的作用域链上查找 `i`，最终在全局作用域中找到了这个值为 `6` 的 `i`。因此，所有回调都输出了 `6`。

**解决方案 (使用 `let`)**:
```javascript
for (let i = 1; i <= 5; i++) {
  setTimeout(function timer() {
    console.log(i);
  }, i * 1000);
}
```
将 `var` 换成 `let`，就能得到期望的结果。

**原因分析**：
*   `let` 具有**块级作用域**。在 `for` 循环中使用 `let`，JavaScript 引擎会在**每一次循环**时，都创建一个新的、独立的词法作用域。
*   每个 `timer` 回调函数都“闭包”了**当次循环**的那个独立作用域，并捕获了那个作用域中的 `i` 值（分别是 1, 2, 3, 4, 5）。
*   因此，当回调函数后续执行时，它们会访问各自闭包中的、值不同的 `i`，从而得到正确的结果。

## 4. 深入理解 JS 类型系统与转换

除了执行上下文和作用域，深刻理解 JavaScript 的类型系统同样是掌握这门语言的基石。JS 开发者日常遇到的很多“怪异”行为和 Bug，都源于对其类型和类型转换规则的误解。

### a. 原始类型 (Primitives) vs. 对象类型 (Objects)

JavaScript 的数据类型可分为两大类：

*   **原始类型**: `Number`, `String`, `Boolean`, `Null`, `Undefined`, `Symbol`, `BigInt`。
    *   它们是**不可变 (immutable)**的。
    *   存储在**栈 (Stack)**内存中，访问速度快。
    *   按值传递。

*   **对象类型**: `Object` (包括 `Array`, `Function`, `Date`, `RegExp` 等)。
    *   它们是**可变 (mutable)**的。
    *   值本身存储在**堆 (Heap)**内存中，而其引用（内存地址）存储在栈中。
    *   按引用传递。

### b. 类型检查 (Type Checking)

*   **`typeof`**: 最适合用来检查原始类型（`"number"`, `"string"`, `"boolean"`, `"symbol"`, `"bigint"`, `"undefined"`）。但它有两个著名的怪癖：
    *   `typeof null` 返回 `"object"`，这是一个历史遗留的 Bug。
    *   `typeof` 无法区分具体的对象类型，对于数组、函数、对象，它都会返回 `"object"`（函数除外，返回 `"function"`）。

*   **`instanceof`**: 用于检查一个对象是否是某个构造函数的实例。它通过检查对象的原型链 (`__proto__`) 来工作。
    *   `[] instanceof Array` -> `true`
    *   `new Date() instanceof Date` -> `true`
    *   **缺点**：无法处理跨 `iframe` 或 `window` 的对象，因为每个窗口都有自己的全局执行环境。

*   **`Object.prototype.toString.call()`**: 这是最可靠、最通用的类型检查方法。
    ```javascript
    Object.prototype.toString.call(42); // "[object Number]"
    Object.prototype.toString.call("hello"); // "[object String]"
    Object.prototype.toString.call([]); // "[object Array]"
    Object.prototype.toString.call({}); // "[object Object]"
    Object.prototype.toString.call(null); // "[object Null]"
    Object.prototype.toString.call(undefined); // "[object Undefined]"
    ```

### c. 隐式类型转换 (Coercion)

这是 JavaScript 中最强大也最容易引起混淆的特性。当运算符在运算时，如果两边的类型不统一，JS 引擎会自动尝试将它们转换为相同的类型。

**转换规则**:
1.  **转换为字符串**: 如果 `+` 运算的一边是字符串，另一边也会被转换为字符串。
    *   `'5' + 1` -> `"51"`
2.  **转换为数字**:
    *   对于 `-, *, /, %` 等算术运算符，操作数会被转换为数字。
        *   `'5' - 1` -> `4`
        *   `'5' * '2'` -> `10`
    *   对于关系比较 (`>`, `<`, `>=`, `<=`)，如果两边都是字符串，则按字典序比较。否则，转换为数字比较。
        *   `'10' > 9` -> `true`
3.  **转换为布尔值**: 在逻辑上下文中（如 `if` 语句, `||`, `&&`），值会被转换为布尔值。除了 `undefined`, `null`, `false`, `NaN`, `0`, `""` (空字符串) 这六个“虚值 (falsy values)”外，其他所有值都为 `true`。

### d. `==` vs. `===` 的终极对比

*   **`===` (严格相等)**：
    *   **不进行**类型转换。
    *   如果类型不同，直接返回 `false`。
    *   如果类型相同，再比较值。
    *   **行为可预测，是开发中的首选。**

*   **`==` (宽松相等)**：
    *   **会进行**隐式类型转换。
    *   转换规则复杂且不直观，是许多“面试题”的来源。
    *   例如，`[] == ![]` 为 `true` 的过程：
        1.  `![]` -> `false` (数组是真值，取反为 false)
        2.  `[] == false`
        3.  `[]` 转换为数字 `0`
        4.  `false` 转换为数字 `0`
        5.  `0 == 0` -> `true`
    *   **除非你非常清楚其转换规则，否则应避免在代码中使用。**

## 总结