# 11-微前端架构下的浏览器隔离机制

微前端（Micro Frontends）架构的核心挑战在于：如何在一个页面中同时运行多个独立开发、技术栈可能不同的子应用，而互不干扰？

这就需要深入理解并利用浏览器提供的各种隔离机制。

## 1. CSS 隔离

CSS 也是全局生效的，子应用 A 的 `.btn` 样式很容易意外覆盖子应用 B 的按钮。

### a. BEM / CSS Modules (工程化手段)
最基础的方案。通过添加命名空间前缀（BEM）或生成唯一的哈希类名（CSS Modules）来避免冲突。但这属于“约定大于配置”，并非物理隔离。

### b. Shadow DOM (浏览器原生隔离)
Shadow DOM 提供了真正意义上的 CSS 边界。在 Shadow Root 内部定义的样式，**完全不会**泄露到外部；外部的全局样式（除了可继承属性如 `color`, `font`）也**很难**影响内部。

*   **微前端应用**：Qiankun 等框架并未默认使用 Shadow DOM，主要原因是它带来的“副作用”处理成本极高。Web Components 标准则是基于此构建。

*   **Shadow DOM 的“坑”与挑战**：
    1.  **事件冒泡 (Retargeting)**：从 Shadow DOM 内部冒泡出来的事件，其 `target` 会被浏览器自动修正为 Shadow Host（宿主元素）。这会导致依赖 `event.target` 进行事件委托的逻辑失效（如 React 的合成事件机制在旧版本中会受此影响）。
    2.  **样式穿透困难**：虽然隔离是初衷，但有时主应用确实需要微调子应用的样式。此时必须使用复杂的 `::part`, `::theme` 伪元素，或者 CSS 变量穿透。
    3.  **弹窗挂载 (Body Append)**：子应用中将弹窗挂载到 `document.body` 的组件（如 Modal, Tooltip），会脱离 Shadow DOM 的管辖，导致样式丢失。需要重写这些组件的挂载逻辑，将其挂载到 Shadow Root 内部。

## 2. JavaScript 沙箱 (JS Sandbox)

JS 变量默认是全局的（挂在 `window` 上），子应用修改 `window.location` 或定义全局变量 `window.user` 会导致严重冲突。

### a. 快照沙箱 (Snapshot Sandbox)
*   **原理**：在子应用激活前，记录当前 `window` 的状态（快照）；子应用卸载时，将 `window` 恢复到快照状态。
*   **缺点**：无法支持多个子应用**同时**运行（单例模式）。

### b. Proxy 代理沙箱 (现代微前端主流方案)
利用 ES6 的 `Proxy` 特性，为每个子应用创建一个“伪造”的 window 对象。

*   **原理**：
    1.  创建一个 `fakeWindow` 对象。
    2.  使用 `Proxy` 拦截对 `fakeWindow` 的读写操作。
    3.  **读操作**：优先从 `fakeWindow` 读，读不到再回退到真实的 `window`（实现对全局 API 的访问）。
    4.  **写操作**：只写入 `fakeWindow`，**绝不污染**真实的 `window`。
    5.  结合 `with` 语法，将子应用的 JS 代码包裹在一个闭包中执行，强制将其作用域绑定到 `proxyWindow`。

```javascript
// 极简版 Proxy 沙箱实现
class ProxySandbox {
  constructor() {
    const fakeWindow = {};
    const rawWindow = window;

    this.proxy = new Proxy(fakeWindow, {
      get(target, p) {
        // 优先取沙箱内的值，否则取全局值
        return p in target ? target[p] : rawWindow[p];
      },
      set(target, p, value) {
        // 只修改沙箱内的值
        target[p] = value;
        return true;
      }
    });
  }
}

// 使用 with 绑定作用域
const sandbox = new ProxySandbox();
const code = `
  window.a = 1; // 实际上修改的是 fakeWindow.a
  console.log(a); // 1
`;

// 构造执行函数
const run = new Function('window', `with(window) { ${code} }`);
run(sandbox.proxy);

console.log(window.a); // undefined，全局 window 未被污染
```

## 3. iframe 隔离 (最硬核的隔离)

`iframe` 是浏览器提供的最古老、最彻底的隔离方案。它天然具备完美的 CSS 和 JS 隔离。

*   **传统痛点**：
    *   **UI 体验差**：滚动条隔离、弹窗无法覆盖全屏、URL 不同步。
    *   **性能开销大**：每个 iframe 都是一个独立的文档环境，内存占用高。
    *   **通信困难**：必须通过 `postMessage` 通信。

*   **新一代 iframe 方案 (如 wujie)**：
    *   **原理**：利用 iframe 做 **JS 沙箱**（一个隐藏的 iframe 仅运行 JS），利用 Web Components (Shadow DOM) 做 **UI 渲染**。
    *   **优势**：
        *   JS 在 iframe 中运行，天然隔离，无须复杂的 Proxy 模拟。
        *   DOM 渲染在主应用的 Shadow Root 中，解决了 iframe UI 体验差的问题（如弹窗可以覆盖全屏）。
        *   这种“**JS 在 iframe，DOM 在主应用**”的混合模式，是目前微前端领域的一个重要创新方向。

## 总结

| 隔离维度 | 方案 | 优点 | 缺点 |
| :--- | :--- | :--- | :--- |
| **CSS** | BEM / CSS Modules | 简单、兼容性好 | 依靠约定，非物理隔离 |
| | **Shadow DOM** | 浏览器原生物理隔离 | 事件冒泡处理复杂、全局库样式丢失 |
| **JS** | 快照沙箱 | 兼容旧浏览器 | 只能单例运行 |
| | **Proxy 沙箱** | 支持多实例、性能好 | 需支持 ES6 Proxy |
| | **iframe** | 完美隔离 | 割裂感强、通信麻烦、内存高 |
| **新趋势** | **iframe (JS) + Shadow DOM (UI)** | 结合了 iframe 的安全与 Shadow DOM 的灵活性 | 架构实现较复杂 (如 wujie) |

