# 14-Web安全：XSS、CSRF与防御策略

Web 安全是一个庞大的领域，其中，XSS 和 CSRF 是两种最常见、也最需要前端工程师深入理解的攻击类型。

## 1. XSS (Cross-Site Scripting) - 跨站脚本攻击

*   **核心原理**：攻击者通过某种方式，将**恶意的 JavaScript 脚本注入**到正常的网页中，当其他用户访问这个网页时，这些恶意脚本就会在用户的浏览器上执行。
*   **攻击目标**：窃取用户的敏感信息（如 Cookie、LocalStorage）、劫持用户会话、伪造用户操作、在页面上展示钓鱼内容等。
*   **本质**：XSS 的本质是**代码注入**，攻击者利用了网站对用户输入内容**过度信任**的漏洞。

### a. XSS 的类型

1.  **存储型 XSS (Stored XSS)**
    *   **流程**：
        1.  攻击者将恶意脚本提交并**存储**到目标网站的**数据库**中（例如，通过发表一篇包含 `<script>` 标签的文章、或在个人简介中写入恶意代码）。
        2.  当其他用户访问展示这些内容的页面时，服务器会从数据库中读取并拼接出 HTML，恶意脚本作为正常内容的一部分被发送到用户的浏览器。
        3.  恶意脚本在用户的浏览器上执行。
    *   **特点**：危害最大，影响范围最广，因为一次成功的攻击可以影响所有访问该页面的用户。

2.  **反射型 XSS (Reflected XSS)**
    *   **流程**：
        1.  攻击者构造一个包含恶意脚本的**特制 URL**，并诱导用户点击。
        2.  用户点击后，恶意脚本作为 URL 的一部分（通常是查询参数）被发送到服务器。
        3.  服务器从 URL 中获取参数，未经充分处理就**反射**回 HTML 响应中（例如，在搜索结果页面显示 "您搜索的关键词是：<恶意脚本>"）。
        4.  恶意脚本在用户的浏览器上执行。
    *   **特点**：非持久化，攻击行为只发生在点击了特制 URL 的用户身上，是一次性的。

3.  **DOM 型 XSS (DOM-based XSS)**
    *   **流程**：这是一种特殊类型的反射型 XSS。它的整个过程都发生在**客户端**。
        1.  攻击者构造一个包含恶意代码的 URL（通常在 `#` hash 部分）。
        2.  用户点击 URL 后，前端的 JavaScript 获取 URL 中的数据（如 `location.hash`），并且在**未经转义**的情况下，直接将其写入到页面的 DOM 中（例如通过 `innerHTML`）。
        3.  恶意脚本被当作 HTML 的一部分，在用户的浏览器上执行。
    *   **特点**：服务器端可能完全感知不到这次攻击，因为恶意代码可能根本不会发送到服务器。

### b. XSS 的防御策略

核心思想是**不信任任何用户输入**。

1.  **输入过滤与输出转义 (核心)**
    *   **输入过滤 (Input Filtering)**：在数据存入数据库**之前**，根据业务需求对用户的输入进行验证和过滤（例如，限制用户名只能是字母和数字）。但这不能作为主要的防御手段。
    *   **输出转义 (Output Escaping)**：在将数据插入到 HTML **之前**，对其进行 HTML 实体转义。这是**最根本、最有效**的防御方法。
        *   将特殊字符（如 `<`, `>`, `"`, `'`, `&`）转换成它们的 HTML 实体（如 `&lt;`, `&gt;`, `&quot;`, `&#39;`, `&amp;`）。
        *   现代前端框架（如 React, Vue）默认都会对动态插入的内容进行转义，大大降低了 XSS 的风险。
        *   **警惕 `innerHTML`, `outerHTML`, `document.write()` 等 API**，它们会直接将字符串作为 HTML 解析，应避免使用用户提供的内容来填充它们。如果必须使用，请确保内容经过了严格的过滤和转义。
        *   **（新兴）使用 `Trusted Types`**：这是一个由浏览器提供的较新的 API，旨在从根本上消除 DOM XSS。它要求开发者在调用 `innerHTML` 等危险 API 之前，必须先将字符串数据封装成一个经过策略函数处理的“可信类型”对象，从而阻止未经验证的数据注入。

2.  **内容安全策略 (Content Security Policy, CSP)**
    *   **原理**：通过设置 HTTP 响应头 `Content-Security-Policy`，告知浏览器一个“白名单”，明确规定页面只允许加载和执行来自这些指定来源的资源（脚本、样式、图片等）。
    *   **作用**：即使攻击者成功注入了恶意脚本，由于脚本来源不在白名单内，浏览器也会拒绝执行它，从而提供了第二道坚实的防线。

3.  **设置 HttpOnly Cookie**
    *   **原理**：为关键的 Cookie（如 Session ID）设置 `HttpOnly` 属性。
    *   **作用**：设置了 `HttpOnly` 的 Cookie 将**无法通过 JavaScript 的 `document.cookie` API 来访问**。这可以有效防止 XSS 攻击者通过脚本窃取用户的会话 Cookie。

4.  **使用 `iframe` 沙箱 (`sandbox`)**
    *   **原理**：当需要展示来自用户或第三方的、不可信的 HTML 内容时，可以将其嵌入到一个设置了 `sandbox` 属性的 `<iframe>` 中。
    *   **作用**：`sandbox` 属性可以极大地限制 `iframe` 内部页面的权限，例如禁止执行脚本 (`allow-scripts`)、禁止访问父窗口的 DOM、禁止提交表单等，从而将潜在的 XSS 风险隔离在 `iframe` 内部。

## 2. CSRF (Cross-Site Request Forgery) - 跨站请求伪造

*   **核心原理**：攻击者**诱导**已登录的用户，在用户**不知情**的情况下，点击一个恶意链接或访问一个恶意页面，该页面会向被攻击的网站**发送一个伪造的请求**。
*   **攻击目标**：利用用户已经获取的登录凭证（特别是 Cookie），冒充用户执行非本意的操作，如修改密码、转账、发表文章等。
*   **本质**：CSRF 的本质是**利用了浏览器会自动携带 Cookie 的机制**，攻击者并没有窃取到 Cookie，只是“借用”了用户的身份。

### a. CSRF 的攻击流程 (以 GET 请求为例)

1.  用户登录了目标网站 A (`bank.com`)，浏览器中保存了 A 网站的登录凭证 Cookie。
2.  用户在未退出的情况下，访问了攻击者精心构造的恶意网站 B。
3.  网站 B 中可能有一个看似无害的图片标签：`<img src="http://bank.com/transfer?to=attacker&amount=1000">`。
4.  当用户的浏览器加载这个图片时，它会**自动携带上 `bank.com` 的 Cookie**，向 `bank.com` 的服务器发起一个 GET 请求。
5.  `bank.com` 的服务器验证 Cookie，确认是合法用户的请求，于是执行了转账操作。整个过程用户毫不知情。

### b. CSRF 的防御策略

核心思想是**验证请求的来源**，确保请求是用户主动发起的。

1.  **验证 Referer 头部**
    *   **原理**：在服务器端检查 HTTP 请求头中的 `Referer` 字段，该字段表明了请求是从哪个页面发起的。可以设置一个白名单，只允许来自同源页面的请求。
    *   **缺点**：`Referer` 头部可以被用户或浏览器插件修改或禁用，因此不是一个完全可靠的防御手段。

2.  **使用 Anti-CSRF Token (核心)**
    *   **原理**：这是目前最常用、最有效的有状态（Stateful）防御方法。
    *   **流程**：
        1.  用户访问页面时，服务器生成一个**随机的、不可预测的 Token**，并将其与用户的会话（Session）绑定。
        2.  服务器将这个 Token 嵌入到页面的表单中（作为一个隐藏字段）或者通过 API 返回给前端。
        3.  当用户提交表单或发送请求时，前端需要将这个 Token 一起提交（可以放在请求体或请求头中）。
        4.  服务器在接收到请求后，**验证提交的 Token 是否与会话中存储的 Token 一致**。
    *   **作用**：攻击者无法获取到这个与用户会话绑定的随机 Token，因此他们伪造的请求中将不包含或包含错误的 Token，服务器端验证失败，从而拒绝该请求。

3.  **双重 Cookie 验证 (Double Submit Cookie)**
    *   **原理**：这是一种无状态（Stateless）的 CSRF 防御模式，对于不依赖 Session 的应用（如使用 JWT）非常有用。
    *   **流程**：
        1.  用户登录后，服务器生成一个 Token 并将其设置在用户的 **Cookie** 中（非 `HttpOnly`）。
        2.  前端在发起请求时，通过 JavaScript 读取该 Cookie 的值，并将其作为请求头（如 `X-CSRF-Token`）或请求体的一部分发送给服务器。
        3.  服务器接收到请求后，**同时验证请求中的 Token 和 Cookie 中的 Token 是否一致**。
    *   **作用**：攻击者可以伪造请求，但由于同源策略的限制，他们无法在自己的恶意网站上读取用户在被攻击网站下的 Cookie，因此无法构造出包含正确 Token 的请求。

4.  **设置 SameSite Cookie 属性**
    *   **原理**：为 Cookie 设置 `SameSite` 属性，可以告知浏览器在跨站请求中是否应该携带这个 Cookie。
    *   **属性值**：
        *   `Strict`：最严格。完全禁止在任何跨站请求中携带 Cookie。
        *   `Lax`：适度宽松。允许在一些顶层导航（如点击链接、GET 表单）的跨站请求中携带 Cookie，但在 `POST`, `iframe` 等场景下会禁止。这是目前很多浏览器的默认值。
        *   `None`：允许在所有跨站请求中携带 Cookie，但必须同时设置 `Secure` 属性（即只在 HTTPS 中生效）。
    *   **作用**：将关键 Cookie 设置为 `SameSite=Strict` 或 `SameSite=Lax` 可以有效地防御大部分 CSRF 攻击。它是**纵深防御体系**中的重要一环，应与 Anti-CSRF Token 配合使用，以提供更全面的保护。

## 3. XSS vs CSRF - 总结

| 对比项         | XSS (跨站脚本攻击)                           | CSRF (跨站请求伪造)                                |
| -------------- | -------------------------------------------- | -------------------------------------------------- |
| **攻击原理**   | 向页面注入恶意脚本，在用户浏览器上执行       | 冒用用户的身份，发送用户非本意的请求               |
| **攻击目标**   | **窃取**用户信息（如 Cookie）                | **利用**用户身份执行操作（不窃取）                 |
| **信任关系**   | 攻击者利用了网站对**用户输入**的信任         | 攻击者利用了浏览器对**Cookie**的信任（自动携带）   |
| **主要防御**   | 输入过滤、输出转义、CSP、HttpOnly Cookie     | Anti-CSRF Token、SameSite Cookie、验证 Referer     |
