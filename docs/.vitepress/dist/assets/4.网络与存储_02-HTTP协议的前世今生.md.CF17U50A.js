import{_ as o,c as n,o as s,ae as r}from"./chunks/framework.DK_uz7nx.js";const p=JSON.parse('{"title":"11-HTTP协议的前世今生","description":"","frontmatter":{},"headers":[],"relativePath":"4.网络与存储/02-HTTP协议的前世今生.md","filePath":"4.网络与存储/02-HTTP协议的前世今生.md"}'),e={name:"4.网络与存储/02-HTTP协议的前世今生.md"};function d(l,t,a,i,g,c){return s(),n("div",null,[...t[0]||(t[0]=[r(`<h1 id="_11-http协议的前世今生" tabindex="-1">11-HTTP协议的前世今生 <a class="header-anchor" href="#_11-http协议的前世今生" aria-label="Permalink to &quot;11-HTTP协议的前世今生&quot;">​</a></h1><p>HTTP (HyperText Transfer Protocol, 超文本传输协议) 是 Web 通信的基石。从最初简单的文本请求，到如今支持高效、安全、复杂交互的现代化协议，HTTP 的演进史就是 Web 发展的缩影。</p><h2 id="http-0-9-单行协议-1991" tabindex="-1">HTTP/0.9 - 单行协议 (1991) <a class="header-anchor" href="#http-0-9-单行协议-1991" aria-label="Permalink to &quot;HTTP/0.9 - 单行协议 (1991)&quot;">​</a></h2><ul><li><strong>诞生背景</strong>：最早期的版本，由蒂姆·伯纳斯-李设计，旨在从服务器获取简单的 HTML 文档。</li><li><strong>核心特点</strong>： <ul><li><strong>极其简单</strong>：只有一个命令 <code>GET</code>，例如 <code>GET /index.html</code>。</li><li><strong>无协议头</strong>：请求中没有任何头信息，服务器也只响应纯粹的 HTML 内容，没有状态码或响应头。</li><li><strong>无状态、无连接</strong>：每个请求都需要建立一个新的 TCP 连接，请求完成后连接立即关闭。</li></ul></li></ul><h2 id="http-1-0-构建基础-1996" tabindex="-1">HTTP/1.0 - 构建基础 (1996) <a class="header-anchor" href="#http-1-0-构建基础-1996" aria-label="Permalink to &quot;HTTP/1.0 - 构建基础 (1996)&quot;">​</a></h2><ul><li><strong>诞生背景</strong>：随着 Web 内容的丰富（如图片、样式表），单行协议已无法满足需求。</li><li><strong>报文结构示例</strong>：<div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>// 请求报文</span></span>
<span class="line"><span>GET /index.html HTTP/1.0</span></span>
<span class="line"><span>User-Agent: Mozilla/5.0</span></span>
<span class="line"><span>Host: www.example.com</span></span>
<span class="line"><span></span></span>
<span class="line"><span>// 响应报文</span></span>
<span class="line"><span>HTTP/1.0 200 OK</span></span>
<span class="line"><span>Content-Type: text/html</span></span>
<span class="line"><span>Content-Length: 1270</span></span>
<span class="line"><span></span></span>
<span class="line"><span>&lt;html&gt;</span></span>
<span class="line"><span>  ...</span></span>
<span class="line"><span>&lt;/html&gt;</span></span></code></pre></div></li><li><strong>核心改进</strong>： <ul><li><strong>引入请求头和响应头</strong>：使得协议更具灵活性。例如，可以通过 <code>Content-Type</code> 头来传输除 HTML 以外的多种类型文件。</li><li><strong>增加了请求方法</strong>：除了 <code>GET</code>，还引入了 <code>POST</code> 和 <code>HEAD</code> 等方法。</li><li><strong>增加了状态码</strong>：如 <code>200 OK</code>, <code>404 Not Found</code> 等，使得客户端可以了解请求的结果。</li><li><strong>缓存机制</strong>：引入了 <code>Expires</code> 和 <code>If-Modified-Since</code> 等头部，允许浏览器缓存资源。</li></ul></li><li><strong>主要缺陷</strong>： <ul><li><strong>短连接</strong>：默认情况下，每个请求仍然需要建立一个新的 TCP 连接，请求完成后就关闭。如果一个页面包含多张图片，就需要建立多次 TCP 连接，开销巨大。</li></ul></li></ul><h2 id="http-1-1-成熟与标准化-1999" tabindex="-1">HTTP/1.1 - 成熟与标准化 (1999) <a class="header-anchor" href="#http-1-1-成熟与标准化-1999" aria-label="Permalink to &quot;HTTP/1.1 - 成熟与标准化 (1999)&quot;">​</a></h2><p>HTTP/1.1 是目前使用最广泛的版本，它引入了大量优化来解决 HTTP/1.0 的性能问题，是 Web 发展的一个里程碑。</p><ul><li><strong>核心改进</strong>： <ul><li><strong>长连接 (Persistent Connections)</strong>：默认开启 <code>Connection: keep-alive</code>，允许多个 HTTP 请求<strong>复用同一个 TCP 连接</strong>，极大地减少了 TCP 连接建立和关闭的开销。</li><li><strong>管道化 (Pipelining)</strong>：允许客户端在收到上一个响应之前，就连续发送多个请求。 <ul><li><strong>现实中的失败</strong>：尽管理论上可以减少延迟，但管道化要求服务器必须严格按顺序返回响应，这并未解决队头阻塞问题。同时，由于其在代理服务器和实现上的诸多困难，该特性在现实中<strong>几乎未被使用，且被大多数现代浏览器默认禁用</strong>。</li></ul></li><li><strong>更完善的缓存控制</strong>：引入了 <code>Cache-Control</code>, <code>ETag</code>, <code>If-None-Match</code> 等更强大、更灵活的缓存头。</li><li><strong>增加了 HOST 头</strong>：允许一台服务器托管多个不同域名的网站（虚拟主机）。</li><li><strong>增加了更多请求方法</strong>：如 <code>PUT</code>, <code>DELETE</code>, <code>OPTIONS</code>, <code>TRACE</code> 等。</li></ul></li></ul><h3 id="核心概念深化-http-请求方法" tabindex="-1">核心概念深化：HTTP 请求方法 <a class="header-anchor" href="#核心概念深化-http-请求方法" aria-label="Permalink to &quot;核心概念深化：HTTP 请求方法&quot;">​</a></h3><table tabindex="0"><thead><tr><th>方法</th><th>描述</th><th>特性</th></tr></thead><tbody><tr><td><strong>GET</strong></td><td>获取资源</td><td>安全、幂等、可缓存</td></tr><tr><td><strong>POST</strong></td><td>创建或提交数据，通常会导致服务器状态的改变</td><td><strong>不安全</strong>、<strong>非幂等</strong>、通常不可缓存</td></tr><tr><td><strong>PUT</strong></td><td><strong>替换</strong>或<strong>完整更新</strong>一个已知的资源</td><td>幂等</td></tr><tr><td><strong>DELETE</strong></td><td>删除一个资源</td><td>幂等</td></tr><tr><td><strong>PATCH</strong></td><td>对资源进行<strong>部分更新</strong></td><td><strong>非幂等</strong></td></tr><tr><td><strong>HEAD</strong></td><td>获取资源的元信息（头部），响应体为空</td><td>安全、幂等、可缓存</td></tr><tr><td><strong>OPTIONS</strong></td><td>获取服务器支持的方法和配置（用于 CORS 预检）</td><td>安全、幂等</td></tr></tbody></table><ul><li><strong>安全 (Safe)</strong>：指请求方法不会改变服务器上的资源状态。</li><li><strong>幂等 (Idempotent)</strong>：指多次执行相同的请求，服务器上的资源状态结果都是相同的。<code>POST</code> 和 <code>PATCH</code> 不是幂等的，因为多次调用会产生副作用（如多次创建资源、多次修改数值）。</li></ul><h3 id="核心概念深化-http-状态码分类" tabindex="-1">核心概念深化：HTTP 状态码分类 <a class="header-anchor" href="#核心概念深化-http-状态码分类" aria-label="Permalink to &quot;核心概念深化：HTTP 状态码分类&quot;">​</a></h3><table tabindex="0"><thead><tr><th>分类</th><th>描述</th><th>常见状态码</th></tr></thead><tbody><tr><td><strong>1xx</strong></td><td><strong>信息性响应</strong> - 表示请求已接收，继续处理</td><td><code>100 Continue</code>, <code>101 Switching Protocols</code> (用于 WebSocket 升级)</td></tr><tr><td><strong>2xx</strong></td><td><strong>成功</strong> - 表示请求已被成功接收、理解、接受</td><td><code>200 OK</code>, <code>201 Created</code>, <code>204 No Content</code></td></tr><tr><td><strong>3xx</strong></td><td><strong>重定向</strong> - 需要采取进一步操作才能完成请求</td><td><code>301 Moved Permanently</code>, <code>302 Found</code>, <code>304 Not Modified</code></td></tr><tr><td><strong>4xx</strong></td><td><strong>客户端错误</strong> - 请求包含语法错误或无法完成</td><td><code>400 Bad Request</code>, <code>401 Unauthorized</code>, <code>403 Forbidden</code>, <code>404 Not Found</code></td></tr><tr><td><strong>5xx</strong></td><td><strong>服务器错误</strong> - 服务器在处理请求时发生错误</td><td><code>500 Internal Server Error</code>, <code>502 Bad Gateway</code>, <code>503 Service Unavailable</code></td></tr></tbody></table><ul><li><p><strong><code>401 Unauthorized</code> vs <code>403 Forbidden</code></strong></p><ul><li><code>401</code>: 表示“未认证”。客户端需要提供有效的身份凭证（如登录）。</li><li><code>403</code>: 表示“已认证，但无权限”。服务器理解了请求，但拒绝执行，因为当前用户没有访问该资源的权限。</li></ul></li><li><p><strong>主要缺陷</strong>：</p><ul><li><strong>队头阻塞 (Head-of-Line Blocking)</strong>：尽管管道化允许同时发送多个请求，但服务器必须<strong>按顺序</strong>响应它们。如果第一个请求耗时很长（例如一个大的 API 查询），后面的请求（即使是小的图片）也必须等待它完成才能收到响应，从而造成阻塞。</li></ul></li></ul><h2 id="http-2-性能革命-2015" tabindex="-1">HTTP/2 - 性能革命 (2015) <a class="header-anchor" href="#http-2-性能革命-2015" aria-label="Permalink to &quot;HTTP/2 - 性能革命 (2015)&quot;">​</a></h2><p>HTTP/2 的主要目标是解决 HTTP/1.1 的性能瓶颈，特别是队头阻塞问题，从而全面提升 Web 加载速度。</p><ul><li><strong>核心改进</strong>： <ul><li><strong>二进制分帧 (Binary Framing)</strong>：这是 HTTP/2 的基础。它将所有传输的信息（请求、响应、头部等）分割成更小的二进制<strong>帧 (Frame)</strong>，并为它们打上流标识（Stream ID）。</li><li><strong>多路复用 (Multiplexing)</strong>：基于二进制分帧，浏览器可以在<strong>同一个 TCP 连接</strong>上同时发送和接收多个独立的请求和响应，而不会相互干扰。不同的流（Stream）在逻辑上是独立的，一个流的阻塞不会影响其他流。<strong>这从根本上解决了 HTTP/1.1 的队头阻塞问题。</strong></li><li><strong>头部压缩 (Header Compression)</strong>：使用 HPACK 算法来压缩请求和响应的头部。对于多个相似的请求，可以只发送差异部分, 极大地减少了传输的头部数据大小。</li><li><strong>服务器推送 (Server Push)</strong>：服务器可以在客户端请求之前，主动将它认为客户端会需要的资源（如 CSS, JS）推送过去，减少了请求的往返次数。 <ul><li><strong>现实中的挑战</strong>：尽管理论上很美好，但服务器推送在实践中被证明<strong>非常难以正确使用</strong>。核心问题在于服务器很难知道客户端缓存中到底已经有了哪些资源，因此很容易推送一些客户端已经拥有或不需要的资源，反而浪费了带宽。鉴于此，该特性并未被广泛采纳，甚至有被浏览器废弃的趋势。</li></ul></li></ul></li><li><strong>主要缺陷</strong>： <ul><li><strong>TCP 队头阻塞</strong>：虽然 HTTP/2 解决了应用层的队头阻塞，但它依然基于 TCP 协议。TCP 是一个可靠的协议，它要求数据包按顺序到达。如果在一个 TCP 连接中，某个数据包丢失了，TCP 会暂停该连接上的所有流，直到这个丢失的数据包被重传并成功接收。这就导致了底层的 <strong>TCP 队头阻塞</strong>。</li></ul></li></ul><h2 id="http-3-面向未来-进行中" tabindex="-1">HTTP/3 - 面向未来 (进行中) <a class="header-anchor" href="#http-3-面向未来-进行中" aria-label="Permalink to &quot;HTTP/3 - 面向未来 (进行中)&quot;">​</a></h2><p>HTTP/3 的核心目标是解决 HTTP/2 遗留的 TCP 队头阻塞问题。为了实现这一目标，它做出了一个革命性的改变：<strong>放弃 TCP，转向 QUIC 协议</strong>。</p><ul><li><strong>核心改进</strong>： <ul><li><strong>基于 QUIC 协议</strong>：QUIC (Quick UDP Internet Connections) 是一个基于 <strong>UDP</strong> 的、可靠的、低延迟的多路复用传输协议。</li><li><strong>彻底解决队头阻塞</strong>：QUIC 实现了在连接层面上的多路复用。每个流都是完全独立的。如果一个流中的某个 UDP 数据包丢失，它只会影响到当前这一个流，而不会阻塞该 QUIC 连接上的任何其他流。</li><li><strong>更快的连接建立</strong>：QUIC 将 TCP 的三次握手和 TLS 的加密握手（在 HTTPS 中需要）结合在了一起，大多数情况下只需要 <strong>1 RTT</strong>（往返时间）甚至 <strong>0 RTT</strong> 就可以建立一个安全的连接。</li><li><strong>连接迁移 (Connection Migration)</strong>：当用户的网络发生变化时（例如从 Wi-Fi 切换到 4G），QUIC 可以无缝地迁移连接，保持通信不中断，而 TCP 连接则需要重新建立。</li></ul></li></ul>`,21)])])}const h=o(e,[["render",d]]);export{p as __pageData,h as default};
