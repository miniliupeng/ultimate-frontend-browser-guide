import{_ as e,c as t,o as r,ae as d}from"./chunks/framework.DK_uz7nx.js";const h=JSON.parse('{"title":"17-浏览器存储方案：Cookie、LocalStorage、IndexedDB","description":"","frontmatter":{},"headers":[],"relativePath":"4.网络与存储/08-浏览器存储方案：Cookie、LocalStorage、IndexedDB.md","filePath":"4.网络与存储/08-浏览器存储方案：Cookie、LocalStorage、IndexedDB.md"}'),s={name:"4.网络与存储/08-浏览器存储方案：Cookie、LocalStorage、IndexedDB.md"};function l(n,o,i,a,c,g){return r(),t("div",null,[...o[0]||(o[0]=[d('<h1 id="_17-浏览器存储方案-cookie、localstorage、indexeddb" tabindex="-1">17-浏览器存储方案：Cookie、LocalStorage、IndexedDB <a class="header-anchor" href="#_17-浏览器存储方案-cookie、localstorage、indexeddb" aria-label="Permalink to &quot;17-浏览器存储方案：Cookie、LocalStorage、IndexedDB&quot;">​</a></h1><p>除了 HTTP 缓存，浏览器还提供了多种机制，允许网页在客户端（用户的浏览器）存储和访问数据。这些技术对于实现状态保持、个性化设置、离线应用等功能至关重要。</p><p>我们主要对比分析以下几种主流的存储方案：</p><h2 id="_1-cookie" tabindex="-1">1. Cookie <a class="header-anchor" href="#_1-cookie" aria-label="Permalink to &quot;1. Cookie&quot;">​</a></h2><ul><li><strong>诞生背景</strong>：最早被设计出来用于<strong>服务器端</strong>识别和跟踪用户，以弥补 HTTP 协议的无状态性。</li><li><strong>核心特点</strong>： <ul><li><strong>与服务器通信</strong>：<code>Cookie</code> 的最大特点是，在<strong>每次</strong> HTTP 请求中，它都会被自动携带在请求头（Request Header）中发送给服务器。同样，服务器也可以通过响应头（Response Header）来设置或修改 <code>Cookie</code>。</li><li><strong>体积小</strong>：单个 <code>Cookie</code> 的大小不能超过 <strong>4KB</strong>，且单个域名下的 <code>Cookie</code> 数量也有限制（通常是 20 到 50 个）。</li><li><strong>API 简单但原始</strong>：通过 <code>document.cookie</code> 来读写，API 不够友好，需要手动封装。</li></ul></li><li><strong>主要用途</strong>： <ul><li><strong>会话管理</strong>：存储用户的登录状态（Session ID）。</li><li><strong>个性化设置</strong>：存储用户偏好，如主题、语言等。</li><li><strong>跟踪和分析</strong>：广告联盟常用 <code>Cookie</code> 来跟踪用户的浏览行为。</li></ul></li><li><strong>缺点</strong>： <ul><li><strong>性能开销</strong>：由于每次请求都会携带，如果 <code>Cookie</code> 中存储了大量非必要数据，会增加网络传输的开销。</li><li><strong>安全性风险</strong>：容易受到 CSRF（跨站请求伪造）攻击。为了防御此类攻击，必须合理设置其安全属性： <ul><li><code>HttpOnly</code>：防止脚本窃取 <code>Cookie</code>。</li><li><code>Secure</code>：确保 <code>Cookie</code> 仅在 HTTPS 连接中传输。</li><li><code>SameSite</code>：控制 <code>Cookie</code> 在跨站请求中的发送行为，是防御 CSRF 的关键。现代浏览器默认值为 <code>Lax</code>，能有效防御大部分 CSRF 场景。</li></ul></li></ul></li></ul><h2 id="_2-web-storage-api-localstorage-sessionstorage" tabindex="-1">2. Web Storage API: <code>LocalStorage</code> &amp; <code>SessionStorage</code> <a class="header-anchor" href="#_2-web-storage-api-localstorage-sessionstorage" aria-label="Permalink to &quot;2. Web Storage API: `LocalStorage` &amp; `SessionStorage`&quot;">​</a></h2><p>Web Storage 是 HTML5 引入的，旨在提供比 <code>Cookie</code> 更强大、更易用的客户端存储方案。它分为 <code>LocalStorage</code> 和 <code>SessionStorage</code> 两种。</p><h3 id="a-localstorage" tabindex="-1">a. <code>LocalStorage</code> <a class="header-anchor" href="#a-localstorage" aria-label="Permalink to &quot;a. `LocalStorage`&quot;">​</a></h3><ul><li><strong>核心特点</strong>： <ul><li><strong>持久化存储</strong>：除非用户手动清除浏览器数据或代码主动移除，否则 <code>LocalStorage</code> 中存储的数据会<strong>永久有效</strong>。</li><li><strong>容量较大</strong>：通常为 <strong>5MB</strong> 左右（因浏览器而异），远大于 <code>Cookie</code>。</li><li><strong>纯客户端</strong>：存储的数据<strong>不会</strong>自动发送给服务器，完全保留在客户端。</li><li><strong>同源策略</strong>：数据遵循同源策略，只有来自同一来源（协议、域名、端口）的页面才能访问。</li><li><strong>API 友好</strong>：提供了简单的键值对（key-value）API：<code>setItem()</code>, <code>getItem()</code>, <code>removeItem()</code>, <code>clear()</code>。</li><li><strong>事件监听</strong>：当同源的其他标签页修改 <code>LocalStorage</code> 时，当前标签页可以监听到 <code>storage</code> 事件，这为实现多标签页通信提供了一种便捷的机制。</li></ul></li><li><strong>主要用途</strong>： <ul><li>存储不常变化、且不敏感的数据，如用户的基础信息、全局配置等。</li><li>作为离线应用的数据缓存。</li></ul></li><li><strong>缺点</strong>： <ul><li><strong>API 是同步的</strong>：读写 <code>LocalStorage</code> 是一个同步操作，如果数据量过大，可能会阻塞主线程。</li><li><strong>只能存储字符串</strong>：如果要存储对象或数组，需要先用 <code>JSON.stringify()</code> 转换成字符串，读取时再用 <code>JSON.parse()</code> 解析回来。</li></ul></li></ul><h3 id="b-sessionstorage" tabindex="-1">b. <code>SessionStorage</code> <a class="header-anchor" href="#b-sessionstorage" aria-label="Permalink to &quot;b. `SessionStorage`&quot;">​</a></h3><p><code>SessionStorage</code> 的 API 和特性与 <code>LocalStorage</code> 几乎完全相同，唯一的区别在于其<strong>生命周期</strong>。</p><ul><li><strong>生命周期</strong>：<code>SessionStorage</code> 中存储的数据仅在**当前会话（Session）**期间有效。 <ul><li>“会话”指的是从用户打开一个标签页到关闭该标签页的整个过程。</li><li>页面刷新或恢复（Restore）时，数据<strong>依然存在</strong>。</li><li><strong>关闭标签页或浏览器后，数据会被清除</strong>。</li><li>在不同的标签页之间，即使是同源的页面，<code>SessionStorage</code> 也是<strong>不共享</strong>的。</li></ul></li><li><strong>主要用途</strong>： <ul><li>存储与当前页面会话相关的临时数据，如单页应用中的某些临时状态、表单中已填写的内容等。</li></ul></li></ul><h2 id="_3-indexeddb" tabindex="-1">3. IndexedDB <a class="header-anchor" href="#_3-indexeddb" aria-label="Permalink to &quot;3. IndexedDB&quot;">​</a></h2><ul><li><strong>诞生背景</strong>：为了满足在浏览器中存储和查询<strong>大量结构化数据</strong>的需求，<code>LocalStorage</code> 这种简单的键值对存储已无法胜任。</li><li><strong>核心特点</strong>： <ul><li><strong>非关系型数据库</strong>：它是一个在浏览器中运行的、功能完备的<strong>事务性、非关系型（NoSQL）数据库</strong>。</li><li><strong>容量巨大</strong>：理论上容量没有严格上限，通常至少有数百 MB，具体取决于用户的可用磁盘空间。</li><li><strong>异步 API</strong>：所有数据库操作都是<strong>异步</strong>的，通过事件和回调函数来处理结果。这确保了它不会阻塞主线程，适合处理大数据。</li><li><strong>支持事务</strong>：保证了一系列操作的原子性，要么全部成功，要么全部失败。</li><li><strong>支持索引</strong>：可以为数据创建索引，从而实现快速的数据检索和查询。</li><li><strong>存储多种类型</strong>：可以直接存储 JavaScript 对象，无需手动序列化。</li></ul></li><li><strong>主要用途</strong>： <ul><li><strong>离线应用</strong>：PWA（渐进式 Web 应用）的核心技术之一，用于在离线状态下存储和访问应用数据。</li><li><strong>客户端数据仓库</strong>：存储和管理大量的用户数据、应用状态或从服务器获取的数据缓存。</li><li><strong>需要复杂查询功能的场景</strong>。</li></ul></li><li><strong>缺点</strong>： <ul><li><strong>API 复杂</strong>：相比 <code>LocalStorage</code>，<code>IndexedDB</code> 的原生 API 较为繁琐和底层，学习曲线较陡。通常需要借助第三方库（如 <code>Dexie.js</code>, <code>localForage</code>）来简化操作。</li></ul></li></ul><h2 id="_4-总结与对比" tabindex="-1">4. 总结与对比 <a class="header-anchor" href="#_4-总结与对比" aria-label="Permalink to &quot;4. 总结与对比&quot;">​</a></h2><table tabindex="0"><thead><tr><th>特性</th><th><code>Cookie</code></th><th><code>LocalStorage</code></th><th><code>SessionStorage</code></th><th><code>IndexedDB</code></th></tr></thead><tbody><tr><td><strong>主要用途</strong></td><td>与服务器通信，维持状态</td><td>客户端持久化存储</td><td>单个会话的临时存储</td><td>客户端大型结构化数据存储</td></tr><tr><td><strong>与服务器交互</strong></td><td>每次请求自动携带</td><td>否</td><td>否</td><td>否</td></tr><tr><td><strong>生命周期</strong></td><td>可设置过期时间，否则随浏览器关闭而失效</td><td>永久有效，除非手动清除</td><td>当前会话期间有效（标签页关闭即清除）</td><td>永久有效，除非手动清除</td></tr><tr><td><strong>容量大小</strong></td><td>~4KB</td><td>~5MB</td><td>~5MB</td><td>巨大（通常 &gt; 250MB）</td></tr><tr><td><strong>API</strong></td><td><code>document.cookie</code> (不友好)</td><td>同步 API (<code>setItem</code>, <code>getItem</code>)</td><td>同步 API (<code>setItem</code>, <code>getItem</code>)</td><td>异步 API (事务、索引)</td></tr><tr><td><strong>数据类型</strong></td><td>字符串</td><td>字符串</td><td>字符串</td><td>任意 JavaScript 对象</td></tr><tr><td><strong>同源跨标签页共享</strong></td><td>是</td><td>是</td><td><strong>否</strong></td><td>是</td></tr></tbody></table><p><strong>如何选择？</strong></p><ul><li>需要与服务器端进行状态同步，或者需要兼容老旧浏览器 -&gt; <strong><code>Cookie</code></strong></li><li>需要存储少量、不敏感的、持久化的配置信息 -&gt; <strong><code>LocalStorage</code></strong></li><li>需要存储仅在当前标签页有效的临时数据 -&gt; <strong><code>SessionStorage</code></strong></li><li>需要存储大量、复杂的结构化数据，并可能需要进行查询，或用于离线应用 -&gt; <strong><code>IndexedDB</code></strong></li></ul><h2 id="_5-补充-cache-api-service-worker-cache" tabindex="-1">5. 补充：Cache API (Service Worker Cache) <a class="header-anchor" href="#_5-补充-cache-api-service-worker-cache" aria-label="Permalink to &quot;5. 补充：Cache API (Service Worker Cache)&quot;">​</a></h2><p>除了上述用于存储<strong>数据</strong>的 API 外，现代浏览器还提供了一个专门用于<strong>缓存网络请求响应</strong>的存储机制——<code>Cache API</code>。</p><ul><li><strong>主要用途</strong>：通常与 <code>Service Worker</code> 配合使用，用于拦截网络请求，并将响应对象（如 JS/CSS 文件、图片、API 返回的 JSON）存储起来。</li><li><strong>核心优势</strong>：它是实现 PWA (渐进式 Web 应用) <strong>离线访问能力</strong>的关键技术。通过 <code>Cache API</code>，开发者可以编程控制资源的缓存策略，让应用在没有网络连接时也能从缓存中读取内容并正常工作。</li></ul><p>因此，在构建复杂的离线应用时，通常是 <strong><code>IndexedDB</code> (存储结构化数据) + <code>Cache API</code> (缓存网络资源)</strong> 协同工作。</p>',22)])])}const u=e(s,[["render",l]]);export{h as __pageData,u as default};
