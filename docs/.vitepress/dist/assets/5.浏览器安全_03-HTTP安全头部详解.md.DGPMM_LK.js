import{_ as i,c as o,o as s,ae as t}from"./chunks/framework.DK_uz7nx.js";const g=JSON.parse('{"title":"15-HTTP安全头部详解","description":"","frontmatter":{},"headers":[],"relativePath":"5.浏览器安全/03-HTTP安全头部详解.md","filePath":"5.浏览器安全/03-HTTP安全头部详解.md"}'),r={name:"5.浏览器安全/03-HTTP安全头部详解.md"};function a(l,e,n,c,d,p){return s(),o("div",null,[...e[0]||(e[0]=[t('<h1 id="_15-http安全头部详解" tabindex="-1">15-HTTP安全头部详解 <a class="header-anchor" href="#_15-http安全头部详解" aria-label="Permalink to &quot;15-HTTP安全头部详解&quot;">​</a></h1><p>除了我们在 XSS 和 CSRF 章节中讨论的防御策略，现代浏览器还支持一系列的 HTTP 响应头，它们可以作为多层防御体系（Defense-in-Depth）的一部分，极大地增强 Web 应用的安全性。配置好这些安全头部，是每一个线上应用的必修课。</p><h2 id="_1-content-security-policy-csp" tabindex="-1">1. Content-Security-Policy (CSP) <a class="header-anchor" href="#_1-content-security-policy-csp" aria-label="Permalink to &quot;1. Content-Security-Policy (CSP)&quot;">​</a></h2><ul><li><strong>作用</strong>：<strong>缓解 XSS 攻击</strong>。</li><li><strong>原理</strong>：CSP 是防御 XSS 的一道强有力的防线。它通过设置一个“白名单”，告知浏览器只允许加载和执行来自指定来源的资源。即使攻击者成功注入了恶意脚本，由于其来源不在白名单内，浏览器也会拒绝执行它。</li><li><strong>配置示例</strong>：<div class="language-http vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">http</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">Content-Security-Policy</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">:</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> default-src &#39;self&#39;; script-src &#39;self&#39; https://apis.google.com; img-src *;</span></span></code></pre></div><ul><li><code>default-src &#39;self&#39;</code>: 默认只允许加载来自同源的资源。</li><li><code>script-src &#39;self&#39; https://apis.google.com</code>: 脚本只能来自同源或 <code>https://apis.google.com</code>。</li><li><code>img-src *</code>: 图片可以来自任何来源。</li></ul></li><li><strong>重要性</strong>：CSP 是防止 XSS 的最佳实践之一，虽然配置可能相对复杂，但提供了极高的安全收益。</li></ul><h2 id="_2-http-strict-transport-security-hsts" tabindex="-1">2. HTTP Strict-Transport-Security (HSTS) <a class="header-anchor" href="#_2-http-strict-transport-security-hsts" aria-label="Permalink to &quot;2. HTTP Strict-Transport-Security (HSTS)&quot;">​</a></h2><ul><li><strong>作用</strong>：<strong>强制浏览器使用 HTTPS 通信</strong>，防止中间人攻击（MITM）中的 SSL 剥离攻击。</li><li><strong>原理</strong>：当用户首次通过 HTTPS 访问网站时，服务器返回 <code>Strict-Transport-Security</code> 头部。浏览器收到后会记录下来，在接下来指定的时间内（<code>max-age</code>），任何对该网站的 <strong>HTTP</strong> 访问请求，都会在<strong>浏览器内部</strong>被自动转换为 <strong>HTTPS</strong> 请求。</li><li><strong>配置示例</strong>：<div class="language-http vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">http</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">Strict-Transport-Security</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">:</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> max-age=31536000; includeSubDomains</span></span></code></pre></div><ul><li><code>max-age=31536000</code>: 强制 HTTPS 的有效期为一年。</li><li><code>includeSubDomains</code>: 策略同样适用于所有子域名。</li></ul></li><li><strong>重要性</strong>：对于提供了 HTTPS 服务的网站，HSTS 是必不可少的安全配置，它从根本上杜绝了降级到不安全 HTTP 的可能性。</li></ul><h2 id="_3-x-frame-options" tabindex="-1">3. X-Frame-Options <a class="header-anchor" href="#_3-x-frame-options" aria-label="Permalink to &quot;3. X-Frame-Options&quot;">​</a></h2><ul><li><strong>作用</strong>：<strong>防止点击劫持 (Clickjacking)</strong>。</li><li><strong>原理</strong>：点击劫持是一种视觉欺骗攻击，攻击者使用一个透明的 <code>&lt;iframe&gt;</code> 覆盖在你的网站上，诱导用户点击 <code>&lt;iframe&gt;</code> 中的按钮，而用户实际上点击的是被覆盖的、你网站上的危险操作（如“删除账户”按钮）。 <code>X-Frame-Options</code> 头部可以控制你的网站是否允许被嵌入到 <code>&lt;iframe&gt;</code> 或 <code>&lt;frame&gt;</code> 中。</li><li><strong>配置选项</strong>： <ul><li><code>DENY</code>: 完全禁止任何页面嵌入。</li><li><code>SAMEORIGIN</code>: 只允许同源的页面嵌入。</li><li><code>ALLOW-FROM uri</code>: (已废弃) 只允许来自指定 URI 的页面嵌入。</li></ul></li><li><strong>现代替代方案</strong>：虽然 <code>X-Frame-Options</code> 仍然广泛使用，但更现代的做法是使用 CSP 的 <code>frame-ancestors</code> 指令，它提供了更灵活的控制。<div class="language-http vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">http</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">Content-Security-Policy</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">:</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> frame-ancestors &#39;self&#39; https://partner.com;</span></span></code></pre></div></li></ul><h2 id="_4-x-content-type-options" tabindex="-1">4. X-Content-Type-Options <a class="header-anchor" href="#_4-x-content-type-options" aria-label="Permalink to &quot;4. X-Content-Type-Options&quot;">​</a></h2><ul><li><strong>作用</strong>：<strong>防止 MIME 类型嗅探攻击</strong>。</li><li><strong>原理</strong>：某些旧版本的浏览器会尝试“猜测”（嗅探）资源的 <code>Content-Type</code>，而不是严格遵守服务器返回的类型。例如，一个本应是图片的 URL，如果返回的内容看起来像 JavaScript，浏览器可能会尝试执行它，从而导致 XSS 漏洞。 这个头部只有一个值 <code>nosniff</code>，它会禁用浏览器的这种嗅探行为，强制浏览器严格遵守 <code>Content-Type</code> 头部。</li><li><strong>配置示例</strong>：<div class="language-http vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">http</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">X-Content-Type-Options</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">:</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> nosniff</span></span></code></pre></div></li><li><strong>重要性</strong>：这是一个简单但有效的安全加固措施。</li></ul><h2 id="_5-referrer-policy" tabindex="-1">5. Referrer-Policy <a class="header-anchor" href="#_5-referrer-policy" aria-label="Permalink to &quot;5. Referrer-Policy&quot;">​</a></h2><ul><li><strong>作用</strong>：<strong>控制 <code>Referer</code> 头部的发送策略，保护用户隐私</strong>。</li><li><strong>原理</strong>：<code>Referer</code> 请求头包含了当前请求是从哪个 URL 跳转而来的。这在某些情况下可能会泄露用户的敏感信息（例如，一个 URL <code>.../reset_password?token=...</code>）。<code>Referrer-Policy</code> 允许网站控制在何种情况下发送 <code>Referer</code> 头部，以及发送多少信息。</li><li><strong>常用配置选项</strong>： <ul><li><code>no-referrer</code>: 完全不发送 <code>Referer</code> 头部。</li><li><code>strict-origin-when-cross-origin</code> (默认行为): <ul><li>同源请求时，发送完整的 URL。</li><li>跨域请求时，只发送源（协议+域名+端口），不包含路径和参数。</li><li>在从 HTTPS 向 HTTP 降级请求时不发送。</li></ul></li><li><code>same-origin</code>: 只在同源请求时发送 <code>Referer</code>。</li></ul></li><li><strong>配置示例</strong>：<div class="language-http vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">http</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">Referrer-Policy</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">:</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> strict-origin-when-cross-origin</span></span></code></pre></div></li></ul><h2 id="_6-permissions-policy" tabindex="-1">6. Permissions-Policy <a class="header-anchor" href="#_6-permissions-policy" aria-label="Permalink to &quot;6. Permissions-Policy&quot;">​</a></h2><ul><li><strong>作用</strong>：<strong>控制浏览器功能的访问权限</strong>，遵循“最小权限原则”。</li><li><strong>原理</strong>：这是一个较新的安全头部（取代了旧的 <code>Feature-Policy</code>），允许网站明确声明哪些浏览器功能（如摄像头 <code>camera</code>、麦克风 <code>microphone</code>、地理位置 <code>geolocation</code> 等）是被允许的，以及允许在哪些源中使用。</li><li><strong>作用</strong>：可以有效防止页面被第三方脚本（如广告、<code>iframe</code>）滥用敏感的浏览器 API，增强网站的安全性和对用户隐私的保护。</li><li><strong>配置示例</strong>：<div class="language-http vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">http</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">Permissions-Policy</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">:</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> camera=(), microphone=(), geolocation=(self &quot;https://trusted-partner.com&quot;)</span></span></code></pre></div><ul><li><code>camera=()</code>: 在当前页面及所有 <code>iframe</code> 中禁用摄像头 API。</li><li><code>geolocation=(self &quot;https://trusted-partner.com&quot;)</code>: 只允许同源及 <code>trusted-partner.com</code> 的 <code>iframe</code> 使用地理位置 API。</li></ul></li></ul><h2 id="_7-跨域隔离相关头部-coop-coep" tabindex="-1">7. 跨域隔离相关头部 (COOP &amp; COEP) <a class="header-anchor" href="#_7-跨域隔离相关头部-coop-coep" aria-label="Permalink to &quot;7. 跨域隔离相关头部 (COOP &amp; COEP)&quot;">​</a></h2><p>这两个头部通常需要配合使用，用于开启“跨域隔离” (Cross-Origin Isolation) 状态，以防御“幽灵 (Spectre)”等旁路攻击，并解锁 <code>SharedArrayBuffer</code> 等强大的 Web API。</p><h3 id="a-cross-origin-opener-policy-coop" tabindex="-1">a. <code>Cross-Origin-Opener-Policy</code> (COOP) <a class="header-anchor" href="#a-cross-origin-opener-policy-coop" aria-label="Permalink to &quot;a. `Cross-Origin-Opener-Policy` (COOP)&quot;">​</a></h3><ul><li><strong>作用</strong>：隔离<strong>顶级窗口</strong>之间的上下文关系，防止恶意窗口通过 <code>window.opener</code> 引用你的页面并发起攻击。</li><li><strong>常用配置</strong>： <ul><li><code>same-origin</code>: 确保只有同源的窗口才能建立 <code>opener</code> 关系。</li><li><code>same-origin-allow-popups</code>: 在保持隔离的同时，允许页面打开的弹出窗口保留对 <code>opener</code> 的引用。</li></ul></li></ul><h3 id="b-cross-origin-embedder-policy-coep" tabindex="-1">b. <code>Cross-Origin-Embedder-Policy</code> (COEP) <a class="header-anchor" href="#b-cross-origin-embedder-policy-coep" aria-label="Permalink to &quot;b. `Cross-Origin-Embedder-Policy` (COEP)&quot;">​</a></h3><ul><li><strong>作用</strong>：控制页面可以嵌入哪些<strong>跨域资源</strong>。</li><li><strong>常用配置</strong>： <ul><li><code>require-corp</code>: 要求所有跨域资源（如图片、脚本）都必须通过 CORS 或 CORP (<code>Cross-Origin-Resource-Policy</code>) 头部明确授权嵌入。</li></ul></li><li><strong>重要性</strong>：开启跨域隔离是 Web 安全的未来方向，虽然配置较为复杂，但它为构建高安全、高性能的应用提供了基础。</li></ul><h2 id="总结" tabindex="-1">总结 <a class="header-anchor" href="#总结" aria-label="Permalink to &quot;总结&quot;">​</a></h2><p>配置这些 HTTP 安全头部是一种低成本、高收益的安全投资。它们与应用代码的防御逻辑（如输入校验、权限控制）相辅相成，共同构建起一个纵深防御体系，有效提升应用的整体安全性。</p>',22)])])}const u=i(r,[["render",a]]);export{g as __pageData,u as default};
