import{_ as r,c as t,o as e,ae as l}from"./chunks/framework.DK_uz7nx.js";const u=JSON.parse('{"title":"02-URL输入到页面展现的全过程","description":"","frontmatter":{},"headers":[],"relativePath":"1.浏览器工作原理/02-URL输入到页面展现的全过程.md","filePath":"1.浏览器工作原理/02-URL输入到页面展现的全过程.md"}'),n={name:"1.浏览器工作原理/02-URL输入到页面展现的全过程.md"};function s(i,o,g,d,c,a){return e(),t("div",null,[...o[0]||(o[0]=[l('<h1 id="_02-url输入到页面展现的全过程" tabindex="-1">02-URL输入到页面展现的全过程 <a class="header-anchor" href="#_02-url输入到页面展现的全过程" aria-label="Permalink to &quot;02-URL输入到页面展现的全过程&quot;">​</a></h1><p>这个过程是前端知识体系的完美串联，它清晰地展示了从网络通信到浏览器渲染的每一个细节。</p><h2 id="_1-用户输入处理-浏览器进程" tabindex="-1">1. 用户输入处理 (浏览器进程) <a class="header-anchor" href="#_1-用户输入处理-浏览器进程" aria-label="Permalink to &quot;1. 用户输入处理 (浏览器进程)&quot;">​</a></h2><p>故事始于用户在浏览器地址栏输入内容。此阶段完全在<strong>浏览器进程</strong>的 <strong>UI 线程</strong>中进行。</p><ul><li><p><strong>解析输入</strong>：UI 线程判断用户输入的是一个<strong>搜索查询</strong>还是一个合法的 <strong>URL</strong>。</p><ul><li>如果是搜索查询，浏览器会使用默认的搜索引擎，将其拼接成一个新的 URL。</li><li>如果是合法的 URL，浏览器会准备开始导航。</li></ul></li><li><p><strong><code>beforeunload</code> 事件</strong>：在当前页面即将被导航离开时，UI 线程会触发 <code>beforeunload</code> 事件，允许页面在关闭前执行一些清理工作或向用户弹出确认提示。如果用户选择取消，后续的导航流程将终止。</p></li><li><p><strong>开始导航，准备渲染进程</strong>：UI 线程通知网络线程准备发起请求。同时，浏览器会寻找一个合适的<strong>渲染进程</strong>来渲染即将到来的页面。如果可能，会复用已有的渲染进程，否则会创建一个新的。</p></li></ul><h2 id="_2-网络请求阶段-网络进程" tabindex="-1">2. 网络请求阶段 (网络进程) <a class="header-anchor" href="#_2-网络请求阶段-网络进程" aria-label="Permalink to &quot;2. 网络请求阶段 (网络进程)&quot;">​</a></h2><p>浏览器进程通过 IPC (进程间通信) 将 URL 交给<strong>网络进程</strong>，由网络进程发起真正的网络请求。</p><ol><li><p><strong>HSTS 检查</strong>：浏览器会检查当前域名是否在 HSTS (HTTP Strict Transport Security) 预加载列表中。如果在，浏览器会<strong>强制将 HTTP 请求升级为 HTTPS 请求</strong>，确保通信安全。</p></li><li><p><strong>Service Worker 检查</strong>：</p><ul><li>在发起请求之前，主线程会检查当前作用域下是否注册并激活了 <strong>Service Worker</strong>。</li><li>如果存在活动的 Service Worker，它将获得拦截网络请求的机会。Service Worker 可以在 <code>fetch</code> 事件中决定是<strong>直接从缓存中返回响应</strong>（实现离线访问），还是<strong>继续向网络发送请求</strong>。这为 PWA (Progressive Web Apps) 提供了强大的能力。</li></ul></li><li><p><strong>查找缓存</strong>：</p><ul><li>浏览器会首先检查<strong>强缓存</strong>（HTTP Headers 中的 <code>Expires</code> 和 <code>Cache-Control</code>）。如果资源在缓存中且未过期，就直接从本地缓存中读取，网络请求结束。这是最快的方式。</li><li>如果强缓存失效，浏览器会继续检查<strong>协商缓存</strong>（HTTP Headers 中的 <code>Last-Modified</code>/<code>If-Modified-Since</code> 和 <code>ETag</code>/<code>If-None-Match</code>）。网络进程会向服务器发送一个请求，服务器根据这些头信息判断资源是否有更新。 <ul><li>若无更新，服务器返回 <code>304 Not Modified</code> 响应，浏览器从缓存中加载资源。</li><li>若有更新，服务器返回 <code>200 OK</code> 和最新的资源。</li></ul></li></ul></li><li><p><strong>DNS 解析 (域名系统)</strong>：</p><ul><li>如果缓存中没有，网络进程需要将 URL 中的域名（例如 <code>www.google.com</code>）解析成服务器的 IP 地址。</li><li>解析顺序如下： <ul><li><strong>浏览器 DNS 缓存</strong>：检查浏览器自身是否缓存了该域名的 IP。</li><li><strong>操作系统 DNS 缓存</strong>：检查操作系统（如 Windows 的 <code>hosts</code> 文件）是否有缓存。</li><li><strong>路由器 DNS 缓存</strong>：检查路由器的缓存。</li><li><strong>ISP (网络服务提供商) DNS 服务器</strong>：向网络运营商的 DNS 服务器发起请求。</li><li><strong>根 DNS 服务器</strong>：如果以上都没有，请求会逐级向上，从根服务器开始，进行递归或迭代查询，直到找到目标 IP 地址。</li></ul></li></ul></li><li><p><strong>建立 TCP 连接</strong>：</p><ul><li>拿到了服务器 IP 地址后，网络进程会与服务器建立一个 TCP 连接。这个过程就是著名的“<strong>三次握手</strong>”。</li><li><strong>现代协议的演进</strong>： <ul><li>传统的 TCP 连接受限于“队头阻塞”，并且建立连接需要多次往返。</li><li><strong>HTTP/2</strong> 通过<strong>多路复用</strong>缓解了应用层的队头阻塞，但依然基于单个 TCP 连接，无法解决 TCP 层的队头阻塞。</li><li>最新的 <strong>HTTP/3</strong> 则基于 <strong>QUIC</strong> 协议，它建立在 UDP 之上，彻底解决了队头阻塞问题，并实现了更快的连接建立（0-RTT 或 1-RTT）。当浏览器和服务器都支持时，会优先使用 QUIC 连接。</li></ul></li></ul></li><li><p><strong>发起 HTTP/HTTPS 请求</strong>：</p><ul><li>连接建立后，浏览器就可以向服务器发送 HTTP 请求了。请求报文包括请求行、请求头和请求体。</li><li>如果 URL 是 <code>https</code> 协议，还需要在 TCP 连接之上建立一个 TLS/SSL 安全层，进行加密通信，涉及证书验证和密钥交换。</li></ul></li></ol><h2 id="_3-服务器处理与响应" tabindex="-1">3. 服务器处理与响应 <a class="header-anchor" href="#_3-服务器处理与响应" aria-label="Permalink to &quot;3. 服务器处理与响应&quot;">​</a></h2><p>服务器（如 Nginx, Apache）接收到 HTTP 请求后，进行处理并构建 HTTP 响应，然后将响应通过 TCP 连接发送回浏览器的<strong>网络进程</strong>。</p><h2 id="_4-浏览器解析与渲染" tabindex="-1">4. 浏览器解析与渲染 <a class="header-anchor" href="#_4-浏览器解析与渲染" aria-label="Permalink to &quot;4. 浏览器解析与渲染&quot;">​</a></h2><p>这是整个流程中最核心、最复杂的阶段，涉及浏览器进程与渲染进程的多次协作。</p><ol><li><p><strong>响应解析与安全检查 (网络进程)</strong>：网络进程接收到响应后，会进行初步解析。</p><ul><li>它会进行<strong>安全检查</strong>，如 <code>CORB</code> (Cross-Origin Read Blocking) 和 <code>MIME 类型嗅探</code>，以防止恶意跨站数据的攻击。</li><li>根据响应头中的 <code>Content-Type</code> 判断资源类型。如果是 <code>text/html</code>，它会通知<strong>浏览器进程</strong>数据已准备好，可以提交给渲染进程了。如果是需要下载的类型，则会交给下载管理器。</li></ul></li><li><p><strong>提交导航与确认 (浏览器进程 &lt;-&gt; 渲染进程)</strong>：</p><ul><li>浏览器进程接收到网络进程的通知后，通过 IPC 将导航指令和数据发送给之前准备好的<strong>渲染进程</strong>。</li><li>渲染进程收到数据后，会开始准备解析和渲染。准备就绪后，它会<strong>向浏览器进程发送一个“确认提交”的消息</strong>。</li><li>浏览器进程收到这个确认后，才会真正地更新地址栏 UI、更新会话历史，并销毁旧的页面（如果存在）。这个确认机制确保了导航的顺畅过渡。</li></ul></li><li><p><strong>渲染进程开始工作 (渲染进程)</strong>：渲染进程的主线程开始执行<strong>关键渲染路径 (Critical Rendering Path)</strong> 的流程：</p><ul><li><p><strong>资源加载提示 (Resource Hints) 与预加载</strong>：在主解析器工作前，浏览器其实已经开始进行优化。</p><ul><li>它会检查 HTML 头部是否存在 <code>link</code> 标签指定的预加载提示，如 <code>dns-prefetch</code>, <code>preconnect</code>, <code>preload</code>, <code>prefetch</code>。这些提示会指导浏览器更早地发起 DNS 解析、建立连接或下载关键资源。</li><li>现代浏览器还会利用 <strong>Speculation Rules API</strong> 实现更智能的<strong>预渲染 (prerender)</strong>，提前在后台渲染好用户可能要访问的下一个页面。</li></ul></li><li><p><strong>构建 DOM 树</strong>：解析 HTML 文本，生成一个树状结构的 DOM (Document Object Model)。在构建的同时，一个<strong>预扫描器 (pre-scanner)</strong> 会在后台运行，查找页面中的关键资源（如 CSS, JS, 图片），并提前通知网络进程去下载，从而与主解析流程并行，提升加载速度。</p></li><li><p><strong>构建 CSSOM 树</strong>：解析 CSS 文件和 <code>&lt;style&gt;</code> 标签，生成一个树状结构的 CSSOM (CSS Object Model)。CSSOM 的构建会<strong>阻塞渲染</strong>，但通常不会阻塞 DOM 的构建。</p></li><li><p><strong>执行 JavaScript</strong>：当解析器遇到 <code>&lt;script&gt;</code> 标签时，DOM 构建会暂停（除非脚本是 <code>async</code> 或 <code>defer</code> 的），<strong>主线程</strong>会接管控制权，开始执行脚本。JS 可能会通过 DOM API 来修改 DOM 结构。</p></li><li><p><strong>构建渲染树 (Render Tree)</strong>：将 DOM 树和 CSSOM 树结合起来，生成渲染树。渲染树只包含需要被渲染的节点（例如，<code>display: none</code> 的节点不会出现在渲染树中）。</p></li><li><p><strong>布局 (Layout / Reflow)</strong>：根据渲染树，计算出每个节点在屏幕上的精确位置和大小。</p></li><li><p><strong>绘制 (Paint)</strong>：根据布局阶段计算出的信息，将每个节点绘制成一系列的绘制指令。</p></li><li><p><strong>合成 (Composite)</strong>：<strong>合成器线程</strong>会将页面的不同部分提升到独立的图层（Layers）上，并进行栅格化。最后，它将这些图层信息提交给 <strong>GPU 进程</strong>，由 GPU 负责将这些图层按照正确的顺序合成，并最终显示在屏幕上。</p></li></ul></li></ol><h2 id="_5-加载完成与连接管理" tabindex="-1">5. 加载完成与连接管理 <a class="header-anchor" href="#_5-加载完成与连接管理" aria-label="Permalink to &quot;5. 加载完成与连接管理&quot;">​</a></h2><ol><li><p><strong>页面加载事件</strong>：</p><ul><li>当初始的 HTML 文档被完全加载和解析完成之后，<strong><code>DOMContentLoaded</code></strong> 事件被触发，此时无需等待样式表、图像和子框架的完成。</li><li>当页面上的所有资源（包括图片、脚本、样式表等）都已加载完成时，<strong><code>load</code></strong> 事件被触发。</li></ul></li><li><p><strong>连接关闭</strong>：页面完全加载后，TCP 连接可能会根据 HTTP 的 <code>Keep-Alive</code> 机制保持连接以便复用，也可能通过“<strong>四次挥手</strong>”被关闭。</p></li></ol>',15)])])}const T=r(n,[["render",s]]);export{u as __pageData,T as default};
