import{_ as i,c as a,o as n,ae as t}from"./chunks/framework.DK_uz7nx.js";const E=JSON.parse('{"title":"08-Web 动画性能优化","description":"","frontmatter":{},"headers":[],"relativePath":"3.页面渲染与性能优化/08-Web动画性能优化.md","filePath":"3.页面渲染与性能优化/08-Web动画性能优化.md"}'),l={name:"3.页面渲染与性能优化/08-Web动画性能优化.md"};function e(h,s,p,k,r,d){return n(),a("div",null,[...s[0]||(s[0]=[t(`<h1 id="_08-web-动画性能优化" tabindex="-1">08-Web 动画性能优化 <a class="header-anchor" href="#_08-web-动画性能优化" aria-label="Permalink to &quot;08-Web 动画性能优化&quot;">​</a></h1><p>流畅的动画是提升用户体验、引导用户注意力、创造情感化设计的关键。然而，性能不佳的动画则会带来相反的效果——卡顿、掉帧，甚至让用户对应用产生廉价和不可靠的印象。本节将深入探讨 Web 动画的性能瓶颈，并提供一套构建“丝般顺滑”动画体验的最佳实践。</p><h2 id="_1-动画性能为何重要-理解帧率-fps" tabindex="-1">1. 动画性能为何重要？理解帧率 (FPS) <a class="header-anchor" href="#_1-动画性能为何重要-理解帧率-fps" aria-label="Permalink to &quot;1. 动画性能为何重要？理解帧率 (FPS)&quot;">​</a></h2><p>用户感知到的“流畅”与否，取决于<strong>帧率 (Frames Per Second, FPS)</strong>。大多数设备的屏幕刷新率为 60Hz，这意味着浏览器需要在每秒内绘制 60 帧画面，即大约每 <strong>16.7 毫秒</strong> (1000ms / 60) 就必须完成一帧的全部渲染工作。</p><p>这个 16.7ms 的时间预算非常宝贵。浏览器需要在这段时间内完成 JavaScript 执行、样式计算、布局、绘制和合成等所有步骤。如果任何一步的耗时过长，导致总时间超过 16.7ms，那么这一帧就会被“丢弃”，用户就会在视觉上感觉到一次“卡顿”或“掉帧”。</p><p>因此，动画性能优化的核心目标就是：<strong>确保每一帧的渲染工作都能在 16.7ms 内完成。</strong></p><h2 id="_2-优先使用合成器属性-transform-与-opacity" tabindex="-1">2. 优先使用合成器属性：<code>transform</code> 与 <code>opacity</code> <a class="header-anchor" href="#_2-优先使用合成器属性-transform-与-opacity" aria-label="Permalink to &quot;2. 优先使用合成器属性：\`transform\` 与 \`opacity\`&quot;">​</a></h2><p>回顾第三章的“浏览器硬件加速”，我们知道渲染流水线可以被简化为 <code>JS -&gt; Style -&gt; Layout -&gt; Paint -&gt; Composite</code> 五个阶段。性能最高的动画，是那些**只涉及最后一步“合成 (Composite)”**的动画。</p><ul><li><p><strong>昂贵的动画属性</strong>：如果你对 <code>width</code>, <code>height</code>, <code>left</code>, <code>top</code>, <code>margin</code> 等属性进行动画，会触发<strong>布局 (Layout)</strong> 阶段，这通常是流水线中最昂贵的一步，因为它需要重新计算所有受影响元素的几何信息，并可能引发后续的绘制和合成，极易导致掉帧。</p></li><li><p><strong>廉价的动画属性</strong>：<code>transform</code> (移动、旋转、缩放) 和 <code>opacity</code> (透明度) 是两个特殊的属性。为它们创建动画，浏览器可以将这个元素提升到一个独立的“合成层 (Compositor Layer)”上。之后，这些动画的每一帧变化，都<strong>只在合成器线程 (Compositor Thread) 上由 GPU 直接处理</strong>，完全绕过了主线程的布局和绘制，因此性能极高。</p></li></ul><h3 id="示例-移动一个元素的-好-与-坏" tabindex="-1">示例：移动一个元素的“好”与“坏” <a class="header-anchor" href="#示例-移动一个元素的-好-与-坏" aria-label="Permalink to &quot;示例：移动一个元素的“好”与“坏”&quot;">​</a></h3><p><strong>坏的方式 (触发布局和绘制)</strong></p><div class="language-css vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">css</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">.box</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">  transition</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">left</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 0.5</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">s</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">.box:hover</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">  left</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">100</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">px</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">; </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">/* 改变 left 会触发 Layout -&gt; Paint -&gt; Composite */</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><p><strong>好的方式 (仅触发合成)</strong></p><div class="language-css vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">css</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">.box</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">  transition</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: transform </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">0.5</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">s</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">.box:hover</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">  transform</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">translateX</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">100</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">px</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">); </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">/* transform 只在 Composite 阶段处理 */</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><p><strong>结论：尽可能地将你的动画限制在 <code>transform</code> 和 <code>opacity</code> 这两个属性上。</strong></p><h2 id="_3-javascript-动画的最佳实践" tabindex="-1">3. JavaScript 动画的最佳实践 <a class="header-anchor" href="#_3-javascript-动画的最佳实践" aria-label="Permalink to &quot;3. JavaScript 动画的最佳实践&quot;">​</a></h2><p>虽然 CSS 动画和过渡更易于浏览器优化，但有时我们确实需要通过 JavaScript 来实现更复杂的、交互驱动的动画。</p><h3 id="a-使用-requestanimationframe" tabindex="-1">a. 使用 <code>requestAnimationFrame</code> <a class="header-anchor" href="#a-使用-requestanimationframe" aria-label="Permalink to &quot;a. 使用 \`requestAnimationFrame\`&quot;">​</a></h3><p><code>requestAnimationFrame</code> (rAF) 是浏览器提供的、用于执行动画更新的<strong>标准 API</strong>。</p><ul><li><strong>工作原理</strong>：你通过 <code>requestAnimationFrame()</code> 传入一个回调函数，浏览器会<strong>保证</strong>在下一次重绘（repaint）之前执行这个回调函数。这完美地将你的动画逻辑与浏览器的渲染节奏同步了起来。</li><li><strong>为何优于 <code>setTimeout</code>/<code>setInterval</code></strong>： <ul><li><strong>时机精准</strong>：<code>setTimeout</code> 无法保证回调的精确执行时机，可能会在两帧之间或一帧的中间执行，造成动画抖动。rAF 则能确保在最佳时机（帧开始时）更新。</li><li><strong>性能优化</strong>：当页面处于非激活状态（如标签页被切换到后台）时，浏览器会自动暂停 <code>requestAnimationFrame</code> 的执行，从而节省 CPU 和电池资源。</li></ul></li></ul><h3 id="示例-使用-raf-实现平滑动画" tabindex="-1">示例：使用 rAF 实现平滑动画 <a class="header-anchor" href="#示例-使用-raf-实现平滑动画" aria-label="Permalink to &quot;示例：使用 rAF 实现平滑动画&quot;">​</a></h3><div class="language-javascript vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> element</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> document.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">getElementById</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;my-box&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">let</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> start;</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">function</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> step</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">timestamp</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  if</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (start </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">===</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> undefined</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    start </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> timestamp;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  }</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> elapsed</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> timestamp </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> start;</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">  // 在这里更新元素的位置</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">  // 例如：让元素在 2 秒内向右移动 500px</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  element.style.transform </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> \`translateX(\${</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">Math</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">min</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">0.25</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> *</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> elapsed</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">500</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">)</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">}px)\`</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  if</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (elapsed </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&lt;</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 2000</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) { </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 只要动画未结束</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    requestAnimationFrame</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(step); </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 就请求下一帧</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">requestAnimationFrame</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(step);</span></span></code></pre></div><h3 id="b-使用-will-change-属性" tabindex="-1">b. 使用 <code>will-change</code> 属性 <a class="header-anchor" href="#b-使用-will-change-属性" aria-label="Permalink to &quot;b. 使用 \`will-change\` 属性&quot;">​</a></h3><p><code>will-change</code> 是一个 CSS 属性，它允许你<strong>提前告知</strong>浏览器，某个元素的某个属性<strong>即将发生变化</strong>。</p><ul><li><strong>作用</strong>：当浏览器接收到这个“提示”后，它可以提前做一些优化工作，例如提前为这个元素创建一个独立的合成层，避免在动画开始的第一帧才去创建层而导致的延迟。</li><li><strong>语法</strong>：<code>will-change: transform, opacity;</code></li><li><strong>注意事项</strong>：<strong>不要滥用 <code>will-change</code></strong>。它会占用额外的内存资源。最佳实践是在一个元素的交互状态（如 <code>:hover</code>）即将开始时添加它，并在动画结束后移除它。</li></ul><div class="language-css vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">css</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">.box</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">  /* ... */</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">  transition</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: transform </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">0.5</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">s</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">.box:hover</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">  /* 提示浏览器：transform 属性即将改变 */</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">  will-change</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: transform;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><h2 id="_4-现代方案-web-animations-api-waapi" tabindex="-1">4. 现代方案：Web Animations API (WAAPI) <a class="header-anchor" href="#_4-现代方案-web-animations-api-waapi" aria-label="Permalink to &quot;4. 现代方案：Web Animations API (WAAPI)&quot;">​</a></h2><p><code>Web Animations API (WAAPI)</code> 是一个 W3C 标准，旨在将 CSS 动画的声明式优点与 JavaScript 动画的动态控制能力结合起来，提供一个统一的、强大的原生动画模型。</p><p>它允许你通过 JavaScript 创建、播放、暂停、取消和控制动画的时间线，其性能表现与原生 CSS 动画相当。</p><div class="language-javascript vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">element.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">animate</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">([</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  { transform: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;translateX(0px)&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, opacity: </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> },</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  { transform: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;translateX(500px)&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, opacity: </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">0.5</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">], {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  duration: </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">2000</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  iterations: </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Infinity</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  direction: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;alternate&#39;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">});</span></span></code></pre></div><p>WAAPI 目前已在所有现代浏览器中得到支持，是构建复杂 Web 动画的未来方向。</p><h2 id="总结" tabindex="-1">总结 <a class="header-anchor" href="#总结" aria-label="Permalink to &quot;总结&quot;">​</a></h2><p>构建高性能 Web 动画的关键在于<strong>理解并尊重浏览器的渲染流水线</strong>。通过优先使用仅触发“合成”的 <code>transform</code> 和 <code>opacity</code> 属性，并在需要时借助 <code>requestAnimationFrame</code> 将 JS 动画与渲染节奏同步，你就能够为用户创造出如黄油般丝滑的动态体验。</p>`,33)])])}const g=i(l,[["render",e]]);export{E as __pageData,g as default};
