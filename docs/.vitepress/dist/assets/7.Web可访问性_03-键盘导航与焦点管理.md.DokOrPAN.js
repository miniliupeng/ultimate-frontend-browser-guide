import{_ as e,c as s,o as a,ae as t}from"./chunks/framework.DK_uz7nx.js";const g=JSON.parse('{"title":"21-键盘导航与焦点管理","description":"","frontmatter":{},"headers":[],"relativePath":"7.Web可访问性/03-键盘导航与焦点管理.md","filePath":"7.Web可访问性/03-键盘导航与焦点管理.md"}'),i={name:"7.Web可访问性/03-键盘导航与焦点管理.md"};function n(d,o,l,c,r,p){return a(),s("div",null,[...o[0]||(o[0]=[t(`<h1 id="_21-键盘导航与焦点管理" tabindex="-1">21-键盘导航与焦点管理 <a class="header-anchor" href="#_21-键盘导航与焦点管理" aria-label="Permalink to &quot;21-键盘导航与焦点管理&quot;">​</a></h1><p>确保所有交互功能都可以通过键盘来访问，是 Web 可访问性（a11y）中最核心、最基本的要求之一。对于无法使用鼠标的用户（如运动障碍者、高级键盘用户、屏幕阅读器用户），键盘是他们与网页交互的主要甚至唯一途径。</p><p>键盘导航的核心在于<strong>焦点（Focus）</strong>。焦点决定了当前页面上哪一个元素正在接收键盘的输入。</p><h2 id="_1-保证所有交互元素都可聚焦" tabindex="-1">1. 保证所有交互元素都可聚焦 <a class="header-anchor" href="#_1-保证所有交互元素都可聚焦" aria-label="Permalink to &quot;1. 保证所有交互元素都可聚焦&quot;">​</a></h2><p>一个元素必须能够接收焦点，才能通过键盘（主要是 <code>Tab</code> 键）导航到并进行交互。</p><h3 id="a-天生可聚焦的元素" tabindex="-1">a. 天生可聚焦的元素 <a class="header-anchor" href="#a-天生可聚焦的元素" aria-label="Permalink to &quot;a. 天生可聚焦的元素&quot;">​</a></h3><p>正如我们在“语义化HTML”一章中提到的，许多原生 HTML 元素默认就是可聚焦的：</p><ul><li><code>&lt;a&gt;</code> (带 <code>href</code> 属性)</li><li><code>&lt;button&gt;</code></li><li><code>&lt;input&gt;</code>, <code>&lt;select&gt;</code>, <code>&lt;textarea&gt;</code></li><li><code>&lt;summary&gt;</code> (用于 <code>&lt;details&gt;</code> 元素)</li><li>等...</li></ul><p><strong>优先使用这些原生元素是保证可聚焦性的最简单方法。</strong></p><h3 id="b-让任意元素可聚焦-tabindex-属性" tabindex="-1">b. 让任意元素可聚焦：<code>tabindex</code> 属性 <a class="header-anchor" href="#b-让任意元素可聚焦-tabindex-属性" aria-label="Permalink to &quot;b. 让任意元素可聚焦：\`tabindex\` 属性&quot;">​</a></h3><p><code>tabindex</code> 属性可以控制一个元素是否可聚焦，以及它是否应该被包含在 <code>Tab</code> 键的导航顺序中。</p><ul><li><p><strong><code>tabindex=&quot;0&quot;</code></strong></p><ul><li><strong>作用</strong>：让一个<strong>原本不可聚焦</strong>的元素（如 <code>&lt;div&gt;</code>, <code>&lt;span&gt;</code>）变得<strong>可聚焦</strong>，并将其<strong>按照 DOM 顺序</strong>放入 <code>Tab</code> 键的导航序列中。</li><li><strong>何时使用</strong>：当你使用非交互元素来构建自定义的交互组件时（例如，用 <code>&lt;div&gt;</code> 模拟一个按钮），你必须为它添加 <code>tabindex=&quot;0&quot;</code>。</li><li><strong>重要</strong>：仅仅让它可聚焦是不够的，你还必须通过 JavaScript 为它添加相应的键盘事件监听（如 <code>keydown</code> 事件来响应 <code>Enter</code> 和 <code>Space</code> 键）。</li></ul></li><li><p><strong><code>tabindex=&quot;-1&quot;</code></strong></p><ul><li><strong>作用</strong>：让一个元素变得<strong>可通过脚本聚焦</strong>（即通过 <code>element.focus()</code> 方法），但<strong>不会</strong>将它放入 <code>Tab</code> 键的自然导航顺序中。</li><li><strong>何时使用</strong>：常用于管理复杂组件的内部焦点。例如，在一个弹窗（Modal）打开后，你希望通过脚本将焦点立即设置到弹窗内的某个元素上，但又不希望用户能通过 <code>Tab</code> 键从页面背景中意外地 <code>Tab</code> 进这个元素。</li></ul></li><li><p><strong><code>tabindex</code> &gt; 0 (反模式，避免使用)</strong></p><ul><li><strong>作用</strong>：任何大于 0 的 <code>tabindex</code> 都会创建一个独立的 <code>Tab</code> 导航序列，浏览器会优先遍历所有 <code>tabindex &gt; 0</code> 的元素（从 1 开始按序遍历），然后再回到 <code>tabindex=&quot;0&quot;</code> 和原生可聚焦元素的正常文档流。</li><li><strong>为什么是反模式</strong>：这会完全打乱用户预期的、基于 DOM 结构的自然导航顺序，造成巨大的困惑和糟糕的用户体验。<strong>应该始终避免使用大于 0 的 <code>tabindex</code>。</strong></li></ul></li></ul><h2 id="_2-维持一个合理的焦点顺序" tabindex="-1">2. 维持一个合理的焦点顺序 <a class="header-anchor" href="#_2-维持一个合理的焦点顺序" aria-label="Permalink to &quot;2. 维持一个合理的焦点顺序&quot;">​</a></h2><p>焦点的移动顺序应该是<strong>符合逻辑的、可预测的</strong>。通常，它应该与页面的视觉阅读顺序保持一致（从上到下，从左到右）。</p><p><strong>最佳实践</strong>：通过<strong>合理地组织你的 DOM 结构</strong>，来创建一个自然的、符合逻辑的 <code>Tab</code> 顺序。DOM 元素的顺序就是 <code>Tab</code> 键导航的默认顺序。</p><h2 id="_3-设计清晰的焦点指示器" tabindex="-1">3. 设计清晰的焦点指示器 <a class="header-anchor" href="#_3-设计清晰的焦点指示器" aria-label="Permalink to &quot;3. 设计清晰的焦点指示器&quot;">​</a></h2><p>“我当前在哪里？”——这是键盘用户最常问的问题。当一个元素接收到焦点时，必须有一个<strong>清晰的、视觉上可见</strong>的指示器来表明它的位置。</p><p>浏览器默认会为聚焦的元素提供一个轮廓（outline），通常是一条虚线或蓝色的辉光。</p><p><strong>要点</strong>：</p><ul><li><strong>永远不要移除 <code>outline</code></strong>：绝对不要为了“美观”而使用 <code>outline: none;</code> 或 <code>outline: 0;</code> 来全局性地移除焦点轮廓，除非你提供了效果更佳的替代方案。</li><li><strong>设计自定义焦点样式</strong>：使用 <code>:focus</code> 和 <code>:focus-visible</code> 伪类来设计一个既美观又清晰的自定义焦点样式。<code>:focus-visible</code> 是一个现代的伪类，它只在浏览器认为需要显示焦点指示器时（例如通过键盘导航时）才生效，而通过鼠标点击时则不显示，体验更佳。</li></ul><div class="language-css vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">css</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">/* 为所有可聚焦元素提供一个清晰的自定义焦点环 */</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">:focus-visible</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">  outline</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">3</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">px</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> solid</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> blue</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">  outline-offset</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">2</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">px</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">/* 移除那些在鼠标点击时不必要的默认焦点环 */</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">:focus:not</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">:focus-visible</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">  outline</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">none</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><ul><li><strong>处理粘性头部遮挡</strong>：如果页面有固定的页眉（<code>position: sticky</code>），页面内锚点或元素聚焦时可能会被页眉遮挡。可以使用 <code>scroll-margin-top</code> 属性为所有可聚焦元素添加一个滚动边距，确保它们在聚焦时能完整地显示在页眉下方。</li></ul><h2 id="_4-复合组件与漫游-tabindex" tabindex="-1">4. 复合组件与漫游 <code>tabindex</code> <a class="header-anchor" href="#_4-复合组件与漫游-tabindex" aria-label="Permalink to &quot;4. 复合组件与漫游 \`tabindex\`&quot;">​</a></h2><p>对于一些复杂的<strong>复合组件 (Composite Widgets)</strong>，如菜单、选项卡、树形视图等，其内部的导航不应使用 <code>Tab</code> 键，而应使用<strong>方向键 (Arrow Keys)</strong>。</p><p><strong>核心原则</strong>：整个复合组件在页面的 <code>Tab</code> 序列中<strong>只应该有一个停靠点</strong>。一旦焦点进入组件，用户就使用方向键等在组件内部导航，<code>Tab</code> 键则用于离开整个组件。</p><p>这种交互模式可以通过<strong>漫游 <code>tabindex</code> (Roving <code>tabindex</code>)</strong> 技术来实现：</p><ol><li><strong>单一入口</strong>：在组件内部，有且仅有<strong>一个</strong>当前活动的子元素被设置为 <code>tabindex=&quot;0&quot;</code>，使其成为 <code>Tab</code> 键的唯一停靠点。</li><li><strong>内部导航</strong>：所有其他可聚焦的子元素都被设置为 <code>tabindex=&quot;-1&quot;</code>。它们虽然无法通过 <code>Tab</code> 键导航到，但可以通过脚本的 <code>.focus()</code> 方法聚焦。</li><li><strong>脚本控制</strong>：开发者监听组件的 <code>keydown</code> 事件（特别是方向键）。当用户按下方向键时，脚本会： a. 找到下一个应该被聚焦的目标元素。 b. 将当前元素的 <code>tabindex</code> 修改为 <code>-1</code>。 c. 将目标元素的 <code>tabindex</code> 修改为 <code>0</code>。 d. 调用目标元素的 <code>.focus()</code> 方法，将焦点移动过去。</li></ol><p>这种模式极大地提升了复杂组件的键盘导航效率和体验，是构建高级可访问性组件的标准实践。</p><h2 id="_5-焦点管理与键盘陷阱" tabindex="-1">5. 焦点管理与键盘陷阱 <a class="header-anchor" href="#_5-焦点管理与键盘陷阱" aria-label="Permalink to &quot;5. 焦点管理与键盘陷阱&quot;">​</a></h2><p>对于一些复杂的动态组件，如弹窗（Modal）、抽屉（Drawer）或菜单，我们需要通过 JavaScript 来主动管理焦点，以提供流畅的键盘体验并避免“键盘陷阱”。</p><h3 id="a-弹窗-modal-的焦点管理" tabindex="-1">a. 弹窗 (Modal) 的焦点管理 <a class="header-anchor" href="#a-弹窗-modal-的焦点管理" aria-label="Permalink to &quot;a. 弹窗 (Modal) 的焦点管理&quot;">​</a></h3><p>一个可访问的弹窗必须满足以下要求：</p><ol><li><strong>打开时</strong>：焦点必须被<strong>立即移动</strong>到弹窗内部的第一个可聚焦元素上。</li><li><strong>焦点捕获 (Focus Trap)</strong>：当弹窗处于打开状态时，<code>Tab</code> 键的导航必须被<strong>限制</strong>在弹窗内部，不能让焦点跑到弹窗背后的页面内容上。</li><li><strong>关闭时</strong>：焦点必须被<strong>归还</strong>到弹窗<strong>打开之前</strong>的那个元素上。</li></ol><p><strong>实现思路</strong>：</p><ul><li>在弹窗打开前，记录下当前的活动元素：<code>const lastFocusedElement = document.activeElement;</code></li><li>弹窗打开后，找到弹窗内第一个可聚焦元素，并调用 <code>element.focus()</code>。</li><li>监听弹窗内部的 <code>keydown</code> 事件。如果用户按下了 <code>Tab</code> 键，检查当前焦点是否在弹窗的第一个或最后一个可聚焦元素上。如果是，并且用户试图向外导航（<code>Shift+Tab</code> 或 <code>Tab</code>），则手动将焦点循环到弹窗的另一端，从而将焦点“捕获”在内部。</li><li>弹窗关闭时，调用 <code>lastFocusedElement.focus()</code> 来归还焦点。</li></ul><h3 id="b-避免键盘陷阱" tabindex="-1">b. 避免键盘陷阱 <a class="header-anchor" href="#b-避免键盘陷阱" aria-label="Permalink to &quot;b. 避免键盘陷阱&quot;">​</a></h3><p><strong>键盘陷阱</strong>是指一个键盘用户 <code>Tab</code> 进入一个组件后，无法再通过 <code>Tab</code> 键离开的现象。这通常发生在一些复杂的自定义组件中（如嵌入的第三方小部件），如果没有正确处理焦点管理，就会造成灾难性的用户体验。</p><p><strong>核心原则</strong>：确保任何可聚焦的区域，都有一个可以通过键盘（<code>Tab</code>, <code>Shift+Tab</code>, <code>Esc</code>）退出的方式。</p>`,38)])])}const k=e(i,[["render",n]]);export{g as __pageData,k as default};
