import{_ as a,c as n,o,ae as t}from"./chunks/framework.DK_uz7nx.js";const c=JSON.parse('{"title":"06-浏览器垃圾回收（GC）机制","description":"","frontmatter":{},"headers":[],"relativePath":"2.JavaScript执行机制/03-浏览器垃圾回收（GC）机制.md","filePath":"2.JavaScript执行机制/03-浏览器垃圾回收（GC）机制.md"}'),r={name:"2.JavaScript执行机制/03-浏览器垃圾回收（GC）机制.md"};function i(e,s,l,g,p,h){return o(),n("div",null,[...s[0]||(s[0]=[t(`<h1 id="_06-浏览器垃圾回收-gc-机制" tabindex="-1">06-浏览器垃圾回收（GC）机制 <a class="header-anchor" href="#_06-浏览器垃圾回收-gc-机制" aria-label="Permalink to &quot;06-浏览器垃圾回收（GC）机制&quot;">​</a></h1><p>垃圾回收（Garbage Collection, GC）是一种自动内存管理的机制。在 JavaScript 中，开发者无需（也无法）手动分配和释放内存，这些工作都由 JS 引擎（如 V8）在后台自动完成。GC 的核心任务是<strong>找出那些不再被使用的内存（垃圾），并将其回收，以便后续代码可以重新利用这部分空间</strong>。</p><p>V8 的垃圾回收策略是基于<strong>分代假说（Generational Hypothesis）</strong> 的，这个假说有两个核心特点：</p><ol><li><strong>大部分对象“朝生夕死”</strong>：它们在被创建后很快就不再被需要。</li><li><strong>“老”对象，很少“死”</strong>：存活时间越长的对象，就越有可能持续存活下去。</li></ol><p>基于这个假说，V8 将其堆内存（Heap）分为了两个主要区域：<strong>新生代（Young Generation）</strong> 和 <strong>老生代（Old Generation）</strong>。</p><h2 id="_1-新生代-young-generation" tabindex="-1">1. 新生代 (Young Generation) <a class="header-anchor" href="#_1-新生代-young-generation" aria-label="Permalink to &quot;1. 新生代 (Young Generation)&quot;">​</a></h2><ul><li><strong>特点</strong>：用于存放存活时间较短的新对象。新生代空间较小（通常只有几 MB），但垃圾回收非常频繁。</li><li><strong>回收算法</strong>：<strong>Scavenge（清除）算法</strong>，这是一种典型的“以空间换时间”的策略。</li></ul><h3 id="scavenge-算法流程" tabindex="-1">Scavenge 算法流程 <a class="header-anchor" href="#scavenge-算法流程" aria-label="Permalink to &quot;Scavenge 算法流程&quot;">​</a></h3><p>新生代内存被平均分成了两块相等的空间：<strong>From 空间（使用中）</strong> 和 <strong>To 空间（空闲）</strong>。</p><ol><li><strong>分配</strong>：所有新创建的对象首先都会被分配在 <strong>From 空间</strong>。</li><li><strong>标记</strong>：当 From 空间即将被占满时，GC 开始工作。它会从根对象（如全局对象 <code>window</code>）出发，遍历所有可达的<strong>活动对象</strong>，并给它们做一个标记。</li><li><strong>复制与整理</strong>：GC 将所有被标记的<strong>活动对象</strong>从 From 空间复制到 <strong>To 空间</strong>，并进行内存整理，使它们在 To 空间中紧凑地排列。那些没有被标记的非活动对象（垃圾）则被留在 From 空间。</li><li><strong>清空与角色互换</strong>：复制完成后，整个 From 空间内的对象都被视为垃圾，可以被一次性清空。然后，From 空间和 To 空间的角色发生互换。原来的 To 空间变成了新的 From 空间，继续进行对象分配；原来的 From 空间则变成了新的 To 空间，等待下一次 GC。</li></ol><h3 id="对象的晋升-promotion" tabindex="-1">对象的晋升 (Promotion) <a class="header-anchor" href="#对象的晋升-promotion" aria-label="Permalink to &quot;对象的晋升 (Promotion)&quot;">​</a></h3><p>如果在一次 Scavenge 回收过程中，一个对象依然存活，那么它就被认为是经历了一轮回收。如果一个对象连续经历了<strong>两轮</strong>回收依然存活，V8 就会认为它是一个存活时间较长的对象，并将其<strong>晋升</strong>到<strong>老生代</strong>内存区。</p><p>此外，如果复制一个对象到 To 空间时，发现 To 空间的使用率已经超过了 25%，那么这个对象也会被直接晋升到老生代。</p><h2 id="_2-老生代-old-generation" tabindex="-1">2. 老生代 (Old Generation) <a class="header-anchor" href="#_2-老生代-old-generation" aria-label="Permalink to &quot;2. 老生代 (Old Generation)&quot;">​</a></h2><ul><li><strong>特点</strong>：用于存放存活时间较长的对象（从新生代晋升而来）以及一些较大的对象。老生代空间较大，垃圾回收的频率相对较低。</li><li><strong>回收算法</strong>：<strong>Mark-Sweep（标记-清除）</strong> 和 <strong>Mark-Compact（标记-整理）</strong> 相结合。</li></ul><h3 id="a-mark-sweep-标记-清除" tabindex="-1">a. Mark-Sweep (标记-清除) <a class="header-anchor" href="#a-mark-sweep-标记-清除" aria-label="Permalink to &quot;a. Mark-Sweep (标记-清除)&quot;">​</a></h3><p>由于老生代的对象数量多、存活率高，如果再使用 Scavenge 算法（需要复制大量对象）会非常低效。因此，老生代采用 Mark-Sweep 算法。</p><ol><li><strong>标记 (Marking)</strong>：GC 从根对象开始，遍历堆中所有可达的<strong>活动对象</strong>，并打上标记。</li><li><strong>清除 (Sweeping)</strong>：遍历整个堆内存，将所有<strong>没有被标记</strong>的对象（垃圾）进行回收，并清除它们的内存。</li></ol><p><strong>缺点</strong>：Mark-Sweep 会在内存中产生大量不连续的<strong>内存碎片</strong>。如果后续需要分配一个较大的对象，可能会因为找不到足够大的连续内存空间而失败。</p><h3 id="b-mark-compact-标记-整理" tabindex="-1">b. Mark-Compact (标记-整理) <a class="header-anchor" href="#b-mark-compact-标记-整理" aria-label="Permalink to &quot;b. Mark-Compact (标记-整理)&quot;">​</a></h3><p>为了解决内存碎片问题，V8 引入了 Mark-Compact 算法。它通常在 Mark-Sweep 执行多次，空间碎片化问题变得比较严重时才会被触发。</p><ol><li><strong>标记 (Marking)</strong>：同 Mark-Sweep。</li><li><strong>整理 (Compacting)</strong>：在标记完成后，此算法会将所有<strong>活动对象</strong>向内存的一端移动，使它们紧凑地排列。移动完成后，直接清理掉边界以外的所有内存。</li></ol><p><strong>缺点</strong>：移动对象的过程会比较耗时。</p><p>因此，V8 在老生代主要使用 Mark-Sweep，并在必要时才使用 Mark-Compact 来处理内存碎片。</p><h2 id="_3-全停顿-stop-the-world-与现代-gc-优化" tabindex="-1">3. 全停顿 (Stop-The-World) 与现代 GC 优化 <a class="header-anchor" href="#_3-全停顿-stop-the-world-与现代-gc-优化" aria-label="Permalink to &quot;3. 全停顿 (Stop-The-World) 与现代 GC 优化&quot;">​</a></h2><p>需要注意的是，由于 JavaScript 是单线程的，<strong>在进行垃圾回收时，JS 脚本的执行必须暂停</strong>，这个现象被称为“<strong>全停顿（Stop-The-World）</strong>”。</p><p>为了最大限度地减少全停顿带来的卡顿感，V8 的垃圾回收器（项目代号 <strong>Orinoco</strong>）引入了许多先进技术，将原本需要长时间的 GC 过程打散或放到后台执行。</p><ul><li><p><strong>增量标记 (Incremental Marking)</strong>：这是针对老生代标记过程的优化。V8 不会一次性遍历整个堆，而是将标记工作切分成许多小块，穿插在 JS 应用逻辑的执行间隙中进行。这显著减少了单次停顿的最长时间。</p></li><li><p><strong>并行回收 (Parallel GC)</strong>：在执行垃圾回收时（无论是新生代还是老生代），V8 会启动多个<strong>辅助线程</strong>来同时进行工作。这就像多个人一起做大扫除，虽然“大扫除”期间你（主线程）仍然不能干活，但总的打扫时间被大大缩短了。</p></li><li><p><strong>并发回收 (Concurrent GC)</strong>：这是更进一步的优化。V8 允许<strong>辅助线程</strong>在后台执行一部分垃圾回收任务（主要是标记），而此时 <strong>JS 主线程可以继续运行</strong>，几乎不受影响。这是实现“无停顿”或“低停顿”GC 的关键技术。</p></li></ul><h2 id="_4-可达性-vs-引用计数-gc-算法的选择" tabindex="-1">4. 可达性 vs. 引用计数：GC 算法的选择 <a class="header-anchor" href="#_4-可达性-vs-引用计数-gc-算法的选择" aria-label="Permalink to &quot;4. 可达性 vs. 引用计数：GC 算法的选择&quot;">​</a></h2><p>V8 采用的标记类算法，其核心思想是<strong>可达性 (Reachability)</strong>。即从根对象出发，能访问到的对象就是“活”的，不能访问到的就是“死”的。</p><p>除了可达性分析，还有一种经典的垃圾回收算法叫<strong>引用计数 (Reference Counting)</strong>。</p><ul><li><strong>工作原理</strong>：为每个对象维护一个引用计数器。当有新的引用指向它时，计数器+1；当引用失效时，计数器-1。当计数器归零时，该对象就被回收。</li><li><strong>致命缺点</strong>：无法回收<strong>循环引用</strong>的对象。例如：<div class="language-javascript vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">let</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> objA </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {};</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">let</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> objB </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {};</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">objA.b </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> objB;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">objB.a </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> objA;</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 此时 objA 和 objB 的引用计数都为 1</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">objA </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> null</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">objB </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> null</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 外部引用消失，但它们内部互相引用，计数器永远无法归零</span></span></code></pre></div>在这种场景下，<code>objA</code> 和 <code>objB</code> 将成为无法回收的“孤岛”，造成内存泄漏。而基于可达性分析的 Mark-Sweep 算法则可以正确地处理这种情况，因为这个“孤岛”从根对象出发是不可达的。</li></ul><h2 id="_5-常见的内存泄漏场景与排查" tabindex="-1">5. 常见的内存泄漏场景与排查 <a class="header-anchor" href="#_5-常见的内存泄漏场景与排查" aria-label="Permalink to &quot;5. 常见的内存泄漏场景与排查&quot;">​</a></h2><p>内存泄漏是指程序中已分配的内存，由于某种原因程序未释放或无法释放，造成系统内存的浪费。常见的场景有：</p><ul><li><strong>意外的全局变量</strong>：未声明的变量被附加到全局对象上。</li><li><strong>被遗忘的定时器</strong>：<code>setInterval</code> 如果没有被 <code>clearInterval</code>，其回调函数及其依赖的变量将一直无法被回收。</li><li><strong>分离的 DOM 节点</strong>：一个 DOM 节点从 DOM 树中被移除了，但仍然有一个 JavaScript 变量在引用它。</li><li><strong>闭包使用不当</strong>：闭包会使其内部函数持有外部作用域的引用，如果这些引用不再需要但没有被解除，就会导致内存泄漏。</li></ul><h3 id="使用-chrome-devtools-进行排查" tabindex="-1">使用 Chrome DevTools 进行排查 <a class="header-anchor" href="#使用-chrome-devtools-进行排查" aria-label="Permalink to &quot;使用 Chrome DevTools 进行排查&quot;">​</a></h3><ol><li><strong>Performance 面板</strong>：通过录制一段时间的操作，观察内存（Memory）曲线图。如果内存占用持续上升，无法回落到一个稳定水平，则很可能存在内存泄漏。</li><li><strong>Memory 面板</strong>：这是排查内存泄漏的利器。 <ul><li><strong>Heap snapshot (堆快照)</strong>：可以为当前的内存状态拍摄一张快照。通常的做法是在页面加载后拍一张，执行一系列操作后再拍一张，然后<strong>对比两张快照</strong>。通过查看两次快照之间新增的对象，可以定位到可疑的内存增长点，特别是 “Detached” (分离的) DOM 树，这是最常见的泄漏源之一。</li></ul></li></ol>`,37)])])}const d=a(r,[["render",i]]);export{c as __pageData,d as default};
