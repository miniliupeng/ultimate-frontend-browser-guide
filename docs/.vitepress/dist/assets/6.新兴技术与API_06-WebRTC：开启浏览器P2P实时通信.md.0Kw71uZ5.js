import{_ as a,c as i,o as e,ae as n}from"./chunks/framework.DK_uz7nx.js";const c=JSON.parse('{"title":"06-WebRTC：开启浏览器P2P实时通信","description":"","frontmatter":{},"headers":[],"relativePath":"6.新兴技术与API/06-WebRTC：开启浏览器P2P实时通信.md","filePath":"6.新兴技术与API/06-WebRTC：开启浏览器P2P实时通信.md"}'),t={name:"6.新兴技术与API/06-WebRTC：开启浏览器P2P实时通信.md"};function r(l,s,h,o,p,d){return e(),i("div",null,[...s[0]||(s[0]=[n(`<h1 id="_06-webrtc-开启浏览器p2p实时通信" tabindex="-1">06-WebRTC：开启浏览器P2P实时通信 <a class="header-anchor" href="#_06-webrtc-开启浏览器p2p实时通信" aria-label="Permalink to &quot;06-WebRTC：开启浏览器P2P实时通信&quot;">​</a></h1><p>在 Web 的世界里，绝大部分通信都遵循着“客户端-服务器”模型。但如果我们需要实现视频会议、在线协作或 P2P 文件分享这类要求<strong>超低延迟</strong>的实时应用，数据在服务器间的中转就会成为性能瓶颈。<code>WebRTC</code> (Web Real-Time Communication) 正是为此而生的革命性技术。</p><p>WebRTC 是一项支持浏览器进行任意类型的实时、点对点（Peer-to-Peer, P2P）通信的开放标准。它允许音视频和任意数据在浏览器之间直接传输，无需经过服务器中转，从而极大地降低了延迟，减少了服务器成本。</p><h2 id="_1-webrtc-的核心能力" tabindex="-1">1. WebRTC 的核心能力 <a class="header-anchor" href="#_1-webrtc-的核心能力" aria-label="Permalink to &quot;1. WebRTC 的核心能力&quot;">​</a></h2><ul><li><strong>低延迟音视频流</strong>：这是 WebRTC 最核心的应用场景，例如在线会议、视频聊天。</li><li><strong>任意数据传输</strong>：除了媒体流，还可以创建数据通道（<code>RTCDataChannel</code>）来传输任何类型的二进制数据，可用于文件分享、实时同步游戏状态等。</li><li><strong>P2P 直连</strong>：通过 ICE 协议，WebRTC 能够智能地穿透 NAT 和防火墙，在两个对等端之间建立直接连接。</li><li><strong>安全</strong>：所有 WebRTC 组件都要求强制加密，所有数据流都通过 DTLS (Datagram Transport Layer Security) 进行加密。</li></ul><h2 id="_2-核心-api-组件" tabindex="-1">2. 核心 API 组件 <a class="header-anchor" href="#_2-核心-api-组件" aria-label="Permalink to &quot;2. 核心 API 组件&quot;">​</a></h2><p>WebRTC 由几个核心的 JavaScript API 组成，它们协同工作以实现实时通信。</p><h3 id="a-mediadevices-getusermedia" tabindex="-1">a. <code>MediaDevices.getUserMedia()</code> <a class="header-anchor" href="#a-mediadevices-getusermedia" aria-label="Permalink to &quot;a. \`MediaDevices.getUserMedia()\`&quot;">​</a></h3><p>这是获取用户媒体设备（摄像头、麦克风）的入口。它会提示用户授权，成功后返回一个 <code>MediaStream</code> 对象，该对象可以被附加到 <code>&lt;video&gt;</code> 元素上进行本地预览，或添加到 P2P 连接中发送给对方。</p><div class="language-javascript vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> videoElement</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> document.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">querySelector</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;video&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">async</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> function</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> startMedia</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  try</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> stream</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> await</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> navigator.mediaDevices.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">getUserMedia</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">({</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">      audio: </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">true</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">      video: </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">true</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    });</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    // 在本地 &lt;video&gt; 元素上播放媒体流</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    videoElement.srcObject </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> stream;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  } </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">catch</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (error) {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    console.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">error</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;Error accessing media devices.&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, error);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><h3 id="b-rtcpeerconnection" tabindex="-1">b. <code>RTCPeerConnection</code> <a class="header-anchor" href="#b-rtcpeerconnection" aria-label="Permalink to &quot;b. \`RTCPeerConnection\`&quot;">​</a></h3><p>这是 WebRTC 的核心接口，负责建立和管理两个对等端之间的连接。它处理了所有复杂的底层工作，包括媒体协商（使用 SDP）、NAT 穿透（使用 ICE）和连接生命周期管理。</p><h3 id="c-rtcdatachannel" tabindex="-1">c. <code>RTCDataChannel</code> <a class="header-anchor" href="#c-rtcdatachannel" aria-label="Permalink to &quot;c. \`RTCDataChannel\`&quot;">​</a></h3><p><code>RTCDataChannel</code> 接口允许在对等端之间发送任意数据。它的 API 类似于 WebSocket，但数据是直接在两个浏览器之间传输的。</p><h2 id="_3-理解-信令-signaling" tabindex="-1">3. 理解“信令” (Signaling) <a class="header-anchor" href="#_3-理解-信令-signaling" aria-label="Permalink to &quot;3. 理解“信令” (Signaling)&quot;">​</a></h2><p>这是理解 WebRTC 工作方式的关键，也是最容易混淆的地方。</p><p><strong>WebRTC 自身不负责“发现”对方</strong>。它只管建立连接和传输数据。但在连接建立之前，两个素未谋面的浏览器需要一个“中间人”来交换一些元数据，这个过程就叫做<strong>信令 (Signaling)</strong>。</p><p>你需要自己搭建一个信令服务器（通常使用 WebSocket 实现）来传递以下信息：</p><ul><li><strong>会话控制消息</strong>：用于打开或关闭通信。</li><li><strong>网络配置数据 (ICE Candidates)</strong>：包含了浏览器所在网络的 IP 地址、端口等信息，用于 NAT 穿透。</li><li><strong>媒体能力数据 (SDP Offer/Answer)</strong>：描述了本地媒体的配置，如分辨率、编解码器等。</li></ul><p><strong>重要</strong>：一旦信令交换完成，P2P 连接成功建立，信令服务器的任务就完成了。之后所有的音视频和数据流都会在浏览器之间直接传输，不再经过服务器。</p><h2 id="_4-典型连接流程-简化版" tabindex="-1">4. 典型连接流程（简化版） <a class="header-anchor" href="#_4-典型连接流程-简化版" aria-label="Permalink to &quot;4. 典型连接流程（简化版）&quot;">​</a></h2><ol><li><strong>Peer A</strong> 创建 <code>RTCPeerConnection</code> 实例，并调用 <code>createOffer()</code> 生成一个 SDP <code>offer</code>。</li><li><strong>Peer A</strong> 通过信令服务器将这个 <code>offer</code> 发送给 <strong>Peer B</strong>。</li><li><strong>Peer B</strong> 收到 <code>offer</code> 后，将其设置为自己的远程描述，然后调用 <code>createAnswer()</code> 创建一个 SDP <code>answer</code>。</li><li><strong>Peer B</strong> 通过信令服务器将 <code>answer</code> 回传给 <strong>Peer A</strong>。</li><li><strong>Peer A</strong> 收到 <code>answer</code> 后，将其设置为自己的远程描述。</li><li>在此期间，A 和 B 会不断地通过信令服务器交换 ICE 候选者。一旦双方找到一条可用的 P2P 路径，连接就正式建立。</li></ol><h2 id="总结" tabindex="-1">总结 <a class="header-anchor" href="#总结" aria-label="Permalink to &quot;总结&quot;">​</a></h2><p>WebRTC 是一项功能极其强大的技术，它将 Web 应用的能力从传统的请求-响应模型扩展到了实时的、端到端的通信领域。虽然其 API 和“信令”的概念相对复杂，但它为构建下一代互动式 Web 应用（如在线教育、远程协作、云游戏等）提供了无限可能。</p>`,24)])])}const g=a(t,[["render",r]]);export{c as __pageData,g as default};
