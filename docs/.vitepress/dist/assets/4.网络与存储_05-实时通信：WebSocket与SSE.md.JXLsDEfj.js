import{_ as i,c as a,o as n,ae as t}from"./chunks/framework.DK_uz7nx.js";const E=JSON.parse('{"title":"14-实时通信：WebSocket 与 SSE","description":"","frontmatter":{},"headers":[],"relativePath":"4.网络与存储/05-实时通信：WebSocket与SSE.md","filePath":"4.网络与存储/05-实时通信：WebSocket与SSE.md"}'),l={name:"4.网络与存储/05-实时通信：WebSocket与SSE.md"};function e(h,s,p,k,r,o){return n(),a("div",null,[...s[0]||(s[0]=[t(`<h1 id="_14-实时通信-websocket-与-sse" tabindex="-1">14-实时通信：WebSocket 与 SSE <a class="header-anchor" href="#_14-实时通信-websocket-与-sse" aria-label="Permalink to &quot;14-实时通信：WebSocket 与 SSE&quot;">​</a></h1><p>传统的 HTTP 是一种“拉”（pull）协议，客户端发起请求，服务器响应。在这种模型下，服务器无法主动向客户端推送数据。为了实现实时更新（如聊天、股价更新、通知），开发者们曾采用了一些“模拟”技术，但它们都存在延迟高、资源浪费等问题。</p><h3 id="传统-模拟-实时技术" tabindex="-1">传统“模拟”实时技术 <a class="header-anchor" href="#传统-模拟-实时技术" aria-label="Permalink to &quot;传统“模拟”实时技术&quot;">​</a></h3><ul><li><strong>轮询 (Polling)</strong>：客户端<strong>每隔一个固定的时间</strong>（如 2 秒）就向服务器发送一次 HTTP 请求，询问是否有新数据。无论有无新数据，服务器都立即响应。这会产生大量无效请求，实时性也受限于轮询间隔。</li><li><strong>长轮询 (Long-Polling)</strong>：客户端发送请求后，服务器<strong>如果有新数据就立即响应</strong>；如果<strong>没有新数据，则会“挂起”这个连接</strong>，直到有新数据产生时再响应。客户端收到响应后，立即发起下一次请求。相比轮询，它减少了无效请求，提高了实时性，但仍然是基于 HTTP 请求-响应模型的模拟，资源消耗和延迟相对较高。</li></ul><p>为了从根本上解决 Web 实时通信的需求，现代浏览器提供了两种原生的解决方案：<strong>WebSocket</strong> 和 <strong>Server-Sent Events (SSE)</strong>。</p><h2 id="_1-websocket" tabindex="-1">1. WebSocket <a class="header-anchor" href="#_1-websocket" aria-label="Permalink to &quot;1. WebSocket&quot;">​</a></h2><p>WebSocket 是一种在<strong>单个 TCP 连接</strong>上进行<strong>全双工 (Full-duplex)</strong> 通信的协议。它允许客户端和服务器之间进行<strong>双向的、实时的</strong>数据传输。</p><h3 id="a-核心特点" tabindex="-1">a. 核心特点 <a class="header-anchor" href="#a-核心特点" aria-label="Permalink to &quot;a. 核心特点&quot;">​</a></h3><ul><li><strong>真正的双向通信</strong>：连接建立后，客户端和服务器都可以随时、主动地向对方发送数据。</li><li><strong>持久化连接</strong>：与 HTTP 不同，WebSocket 连接一旦建立，就会保持活动状态，直到一方明确关闭连接。这避免了 HTTP 频繁建立和销毁连接的开销。</li><li><strong>低延迟、低开销</strong>：WebSocket 的数据帧头部非常小（通常只有 2-10 字节），相比 HTTP 请求庞大的头部，传输开销极低，因此延迟也更小。</li><li><strong>独立的协议</strong>：WebSocket 有自己的协议规范（<code>ws://</code> 和 <code>wss://</code>），它始于一次特殊的 HTTP “升级”请求。</li></ul><h3 id="b-连接过程" tabindex="-1">b. 连接过程 <a class="header-anchor" href="#b-连接过程" aria-label="Permalink to &quot;b. 连接过程&quot;">​</a></h3><ol><li><strong>HTTP 握手 (Handshake)</strong>： <ul><li>客户端首先发起一个标准的 HTTP GET 请求，但其中包含了特殊的升级头部：<div class="language-http vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">http</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">GET</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> /chat </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">HTTP</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">/</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1.1</span></span>
<span class="line"><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">Host</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">:</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> server.example.com</span></span>
<span class="line"><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">Connection</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">:</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> Upgrade</span></span>
<span class="line"><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">Upgrade</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">:</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> websocket</span></span>
<span class="line"><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">Sec-WebSocket-Key</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">:</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> dGhlIHNhbXBsZSBub25jZQ==</span></span>
<span class="line"><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">Sec-WebSocket-Version</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">:</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> 13</span></span></code></pre></div></li><li>服务器如果同意升级，会返回一个 <code>101 Switching Protocols</code> 的响应，确认连接升级为 WebSocket。</li></ul></li><li><strong>建立连接</strong>：握手成功后，底层的 TCP 连接就被保留下来，用于后续的 WebSocket 通信。此后的数据传输都遵循 WebSocket 的帧格式，不再是 HTTP 协议。</li></ol><h3 id="c-api-使用" tabindex="-1">c. API 使用 <a class="header-anchor" href="#c-api-使用" aria-label="Permalink to &quot;c. API 使用&quot;">​</a></h3><div class="language-javascript vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 1. 创建 WebSocket 连接</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 第二个参数是可选的子协议数组，用于协商更高层的应用协议</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> socket</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> new</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> WebSocket</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;wss://example.com/socket&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, [</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;json-rpc&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;xml&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">]);</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 2. 监听连接打开事件</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">socket.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">onopen</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> function</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">event</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  console.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">log</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;Connection opened!&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">  // 连接成功后，可以开始发送数据</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  socket.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">send</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;Hello Server!&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">};</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 3. 监听消息事件</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">socket.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">onmessage</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> function</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">event</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  console.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">log</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;Message from server: &#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, event.data);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">};</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 4. 监听错误事件</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">socket.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">onerror</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> function</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">error</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  console.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">error</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;WebSocket Error: &#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, error);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">};</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 5. 监听连接关闭事件</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">socket.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">onclose</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> function</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">event</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  if</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (event.wasClean) {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    console.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">log</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">\`Connection closed cleanly, code=\${</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">event</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">.</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">code</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">}, reason=\${</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">event</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">.</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">reason</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">}\`</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  } </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">else</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    // 例如，服务器进程被杀死或网络中断</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    console.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">error</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;Connection died&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">};</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 6. 主动关闭连接</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// socket.close();</span></span></code></pre></div><h3 id="d-弱网环境下的健壮性策略" tabindex="-1">d. 弱网环境下的健壮性策略 <a class="header-anchor" href="#d-弱网环境下的健壮性策略" aria-label="Permalink to &quot;d. 弱网环境下的健壮性策略&quot;">​</a></h3><p>在移动端或不稳定的网络环境下，WebSocket 连接可能会频繁断开。为了保证通信的可靠性，通常需要实现以下策略：</p><ul><li><p><strong>1. 心跳机制 (Heartbeat)</strong></p><ul><li><strong>问题</strong>: 在弱网环境下，连接可能已经“假死”（TCP 连接未断开，但双方无法通信），客户端和服务器都无法及时感知。</li><li><strong>解决方案</strong>: WebSocket 协议本身定义了 <code>Ping</code> 和 <code>Pong</code> 控制帧。客户端可以定期（例如每 30 秒）向服务器发送一个 <code>Ping</code> 帧。如果服务器在一定时间内没有收到客户端的 <code>Ping</code> 帧，或者客户端发送 <code>Ping</code> 后没有及时收到服务器的 <code>Pong</code> 响应，就可以认为连接已经断开，然后主动关闭连接。这可以快速检测到“僵尸连接”，并且占用的带宽极小。</li></ul></li><li><p><strong>2. 自动重连 (Automatic Reconnection)</strong></p><ul><li><strong>问题</strong>: 连接断开后，需要一种机制来自动恢复。</li><li><strong>解决方案</strong>: 客户端应该监听 WebSocket 的 <code>onclose</code> 事件。一旦连接关闭，就启动重连逻辑。为了避免在服务器或网络暂时不可用时，客户端发起大量无效的重连请求，应该采用<strong>指数退避算法 (Exponential Backoff)</strong>。例如，第一次断开后立即重连，如果失败，则等待 2 秒，再次失败则等待 4 秒、8 秒... 直到达到一个最大重试间隔。</li></ul></li><li><p><strong>3. 消息队列与确认机制 (ACK)</strong></p><ul><li><strong>问题</strong>: <code>socket.send()</code> 方法只是将消息放入发送缓冲区，在弱网下消息容易丢失，它并不保证对方一定能收到。</li><li><strong>解决方案</strong>: 实现一个应用层的确认机制。 <ol><li>每条消息都带有一个唯一的 ID。</li><li>发送方发送消息后，将其存入一个“待确认”列表，并启动一个超时计时器。</li><li>接收方收到消息后，向发送方回复一个包含该消息 ID 的 ACK 消息。</li><li>发送方收到 ACK 后，将消息从“待确认”列表中移除。</li><li>如果超时仍未收到 ACK，发送方会重新发送该消息。</li></ol></li></ul></li><li><p><strong>4. 断线续传与状态同步</strong></p><ul><li><strong>问题</strong>: 重连成功后，客户端需要知道自己离线期间错过了哪些消息。</li><li><strong>解决方案</strong>: 为消息增加连续的序列号。客户端重连后，可以把自己最后收到的消息序列号发给服务器。服务器根据客户端的序列号，将所有后续的离线消息重新发送给客户端。</li></ul></li><li><p><strong>5. 数据压缩</strong></p><ul><li><strong>问题</strong>: 在带宽有限的弱网环境中，减少数据传输量可以有效提高通信效率。</li><li><strong>解决方案</strong>: WebSocket 协议支持 <code>permessage-deflate</code> 扩展，可以在协议层面对消息进行压缩。同时，也可以考虑使用更紧凑的应用层数据格式（如 Protocol Buffers）替代 JSON。</li></ul></li></ul><h2 id="_2-server-sent-events-sse" tabindex="-1">2. Server-Sent Events (SSE) <a class="header-anchor" href="#_2-server-sent-events-sse" aria-label="Permalink to &quot;2. Server-Sent Events (SSE)&quot;">​</a></h2><p>Server-Sent Events 是一种允许服务器<strong>单向</strong>向客户端推送事件和数据的技术。它基于标准的 HTTP 协议，非常轻量和易用。</p><h3 id="a-核心特点-1" tabindex="-1">a. 核心特点 <a class="header-anchor" href="#a-核心特点-1" aria-label="Permalink to &quot;a. 核心特点&quot;">​</a></h3><ul><li><strong>服务器单向推送</strong>：连接建立后，只有服务器可以向客户端发送数据。客户端无法通过此连接向服务器发送消息。</li><li><strong>基于 HTTP</strong>：SSE 运行在单个持久化的 HTTP 连接之上，无需新的协议。</li><li><strong>自动重连</strong>：SSE 内置了断线重连机制。如果连接意外中断，浏览器会在一段时间后自动尝试重新连接。</li><li><strong>事件流</strong>：服务器发送的数据是一个持续的事件流，可以为不同的消息定义事件类型。</li></ul><h3 id="b-协议与数据格式" tabindex="-1">b. 协议与数据格式 <a class="header-anchor" href="#b-协议与数据格式" aria-label="Permalink to &quot;b. 协议与数据格式&quot;">​</a></h3><p>服务器端的响应必须包含特定的 <code>Content-Type: text/event-stream</code> 头部。响应体由一系列的事件消息组成，每条消息由一个或多个 <code>key: value</code> 格式的行构成，并以两个换行符 <code>\\n\\n</code> 结尾。</p><ul><li><code>data</code>: 消息的数据内容。</li><li><code>event</code>: 事件类型，客户端可以据此监听不同类型的消息。</li><li><code>id</code>: 消息的唯一 ID。当连接断开并自动重连时，浏览器会自动在请求头中附带一个 <code>Last-Event-ID</code> 字段，其值就是上一次成功接收到的消息的 <code>id</code>。这样，服务器就可以根据这个 ID，补发所有客户端离线期间错过的消息。</li><li><code>retry</code>: 指示浏览器在断线后应该等待多少毫秒再尝试重连。</li></ul><p><strong>服务器端响应示例 (Node.js):</strong></p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>HTTP/1.1 200 OK</span></span>
<span class="line"><span>Content-Type: text/event-stream</span></span>
<span class="line"><span>Cache-Control: no-cache</span></span>
<span class="line"><span>Connection: keep-alive</span></span>
<span class="line"><span></span></span>
<span class="line"><span>// 发送一条简单的消息</span></span>
<span class="line"><span>data: Some message\\n\\n</span></span>
<span class="line"><span></span></span>
<span class="line"><span>// 发送一条带有事件类型的消息</span></span>
<span class="line"><span>event: user-login</span></span>
<span class="line"><span>data: {&quot;username&quot;: &quot;John&quot;}\\n\\n</span></span>
<span class="line"><span></span></span>
<span class="line"><span>// 发送一条带有 ID 和重试时间的消息</span></span>
<span class="line"><span>id: 12345</span></span>
<span class="line"><span>data: Another message</span></span>
<span class="line"><span>retry: 10000\\n\\n</span></span></code></pre></div><h3 id="c-api-使用-1" tabindex="-1">c. API 使用 <a class="header-anchor" href="#c-api-使用-1" aria-label="Permalink to &quot;c. API 使用&quot;">​</a></h3><div class="language-javascript vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 1. 创建 EventSource 实例</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> evtSource</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> new</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> EventSource</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;/events&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 2. 监听默认的 &#39;message&#39; 事件</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">evtSource.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">onmessage</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> function</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">event</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  console.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">log</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;Default message: &#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, event.data);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">};</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 3. 监听自定义的 &#39;user-login&#39; 事件</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">evtSource.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">addEventListener</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;user-login&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">function</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">event</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> userData</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> JSON</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">parse</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(event.data);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  console.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">log</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;User login: &#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, userData.username);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">});</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 4. 监听错误事件</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">evtSource.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">onerror</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> function</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">err</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  console.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">error</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;EventSource failed:&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, err);</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">  // 如果发生致命错误，可以关闭连接</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">  // evtSource.close();</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">};</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 5. 主动关闭连接</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// evtSource.close();</span></span></code></pre></div><h2 id="_3-websocket-vs-sse-总结与对比" tabindex="-1">3. WebSocket vs SSE - 总结与对比 <a class="header-anchor" href="#_3-websocket-vs-sse-总结与对比" aria-label="Permalink to &quot;3. WebSocket vs SSE - 总结与对比&quot;">​</a></h2><table tabindex="0"><thead><tr><th>特性</th><th>WebSocket</th><th>SSE (Server-Sent Events)</th></tr></thead><tbody><tr><td><strong>通信方向</strong></td><td><strong>双向通信 (全双工)</strong></td><td><strong>服务器 -&gt; 客户端 (单向)</strong></td></tr><tr><td><strong>底层协议</strong></td><td>独立的 <code>ws</code>/<code>wss</code> 协议</td><td>标准的 HTTP/HTTPS 协议</td></tr><tr><td><strong>自动重连</strong></td><td>否 (需要手动实现)</td><td><strong>是 (内置机制)</strong></td></tr><tr><td><strong>API</strong></td><td><code>WebSocket</code> API</td><td><code>EventSource</code> API</td></tr><tr><td><strong>数据类型</strong></td><td>文本、二进制数据</td><td>纯文本 (UTF-8)</td></tr><tr><td><strong>错误处理</strong></td><td>简单的 <code>onerror</code> 事件</td><td>相对更详细的错误处理</td></tr><tr><td><strong>兼容性</strong></td><td>现代浏览器普遍支持</td><td>所有现代浏览器支持 (IE/Edge Legacy 不支持)</td></tr></tbody></table><p><strong>如何选择？</strong></p><ul><li><p><strong>当你需要真正的双向通信时</strong>，例如：</p><ul><li>在线多人游戏</li><li>协同编辑应用</li><li>即时聊天室（客户端需要频繁发送消息）</li><li><strong>选择 <code>WebSocket</code></strong></li></ul></li><li><p><strong>当你只需要从服务器接收实时更新时</strong>，例如：</p><ul><li>股票价格、体育比分更新</li><li>新闻、动态资讯推送</li><li>站内信、新订单通知</li><li><strong>选择 <code>SSE</code></strong>。它更轻量、更简单，并且利用了现有的 HTTP 基础，更容易在现有架构上实现。</li></ul></li></ul>`,31)])])}const g=i(l,[["render",e]]);export{E as __pageData,g as default};
