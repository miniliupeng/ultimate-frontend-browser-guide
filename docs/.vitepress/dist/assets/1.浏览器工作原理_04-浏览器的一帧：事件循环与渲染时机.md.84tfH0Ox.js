import{_ as o,c as r,o as t,ae as a}from"./chunks/framework.DK_uz7nx.js";const _=JSON.parse('{"title":"04-浏览器的一帧：事件循环与渲染时机","description":"","frontmatter":{},"headers":[],"relativePath":"1.浏览器工作原理/04-浏览器的一帧：事件循环与渲染时机.md","filePath":"1.浏览器工作原理/04-浏览器的一帧：事件循环与渲染时机.md"}'),l={name:"1.浏览器工作原理/04-浏览器的一帧：事件循环与渲染时机.md"};function s(i,e,n,d,c,g){return t(),r("div",null,[...e[0]||(e[0]=[a('<h1 id="_04-浏览器的一帧-事件循环与渲染时机" tabindex="-1">04-浏览器的一帧：事件循环与渲染时机 <a class="header-anchor" href="#_04-浏览器的一帧-事件循环与渲染时机" aria-label="Permalink to &quot;04-浏览器的一帧：事件循环与渲染时机&quot;">​</a></h1><p>前面几节，我们深入探讨了浏览器如何从零开始加载并渲染一个页面。但Web应用的生命周期远不止于此。页面加载完成后，它会持续响应用户交互、播放动画、更新数据。理解浏览器如何处理这些“运行时”的工作，是性能优化的后半场，而这一切都围绕着一个核心概念展开——<strong>帧 (Frame)</strong>。</p><h2 id="_1-什么是帧-为什么是-16-6ms" tabindex="-1">1. 什么是帧？为什么是 16.6ms？ <a class="header-anchor" href="#_1-什么是帧-为什么是-16-6ms" aria-label="Permalink to &quot;1. 什么是帧？为什么是 16.6ms？&quot;">​</a></h2><p>现代显示器的刷新率通常是 <strong>60Hz</strong>，这意味着屏幕上的画面每秒会刷新60次。为了让用户感知到流畅的视觉效果，浏览器必须跟上这个节奏，在每次屏幕刷新前都准备好新的一帧画面。</p><p>因此，留给浏览器完成一帧所有工作的时间就是：<strong>1秒 / 60次 ≈ 16.67毫秒</strong>。</p><p>如果在 16.67ms 内，浏览器没有完成画面的计算和绘制，那么这一帧就会被“丢弃”，屏幕会继续显示上一帧的内容。这就是我们常说的<strong>掉帧 (Frame Drop)</strong>，在用户看来就是<strong>卡顿 (Jank)</strong>。</p><h2 id="_2-浏览器在一帧内会做什么" tabindex="-1">2. 浏览器在一帧内会做什么？ <a class="header-anchor" href="#_2-浏览器在一帧内会做什么" aria-label="Permalink to &quot;2. 浏览器在一帧内会做什么？&quot;">​</a></h2><p>浏览器的一帧可以看作是事件循环中一次特殊的、以渲染为目标的“tick”。它并非一个孤立的系统，而是与我们之前学习的事件循环模型紧密结合。</p><p>一帧的主要工作流程可以分解为以下几个阶段：</p><h3 id="阶段一-任务处理-task-processing" tabindex="-1">阶段一：任务处理 (Task Processing) <a class="header-anchor" href="#阶段一-任务处理-task-processing" aria-label="Permalink to &quot;阶段一：任务处理 (Task Processing)&quot;">​</a></h3><p>这是事件循环处理宏任务的阶段。浏览器会从宏任务队列中取出一个任务来执行。</p><ol><li><strong>处理输入事件 (Input Events)</strong>：首先处理用户的交互，如 <code>click</code>, <code>scroll</code>, <code>wheel</code> 等。及时响应用户输入是保证交互体验的关键。</li><li><strong>执行定时器 (Timers)</strong>：检查并执行到期的 <code>setTimeout</code> 或 <code>setInterval</code> 的回调函数。</li></ol><h3 id="阶段二-帧开始-begin-frame" tabindex="-1">阶段二：帧开始 (Begin Frame) <a class="header-anchor" href="#阶段二-帧开始-begin-frame" aria-label="Permalink to &quot;阶段二：帧开始 (Begin Frame)&quot;">​</a></h3><p>在处理完一些宏任务后，如果浏览器判断需要进行一次新的渲染（例如，有样式变更、DOM 操作或上一帧错过了渲染），就会进入这个阶段。</p><ol start="3"><li><strong>执行 <code>requestAnimationFrame</code> (rAF) 回调</strong>： <ul><li>这是执行动画更新的<strong>黄金时机</strong>。<code>rAF</code> 的回调函数会在每次页面重绘之前被调用。</li><li><strong>为什么用 rAF 而不是 <code>setTimeout</code> 做动画？</strong> 因为 <code>rAF</code> 的执行时机是由浏览器精确控制的，它能确保回调在最合适的时间点（紧邻渲染）执行，避免了不必要的计算和掉帧。而 <code>setTimeout</code> 的时间精度不高，且与渲染时机无关，容易导致动画卡顿。</li></ul></li></ol><h3 id="阶段三-渲染管道-render-pipeline" tabindex="-1">阶段三：渲染管道 (Render Pipeline) <a class="header-anchor" href="#阶段三-渲染管道-render-pipeline" aria-label="Permalink to &quot;阶段三：渲染管道 (Render Pipeline)&quot;">​</a></h3><p>这个阶段的目标是计算并生成新的像素画面。它基本复用了我们在“关键渲染路径”中学到的流程，但通常是针对页面的局部变化。</p><ol start="4"><li><strong>样式计算 (Style)</strong>：浏览器重新计算哪些元素的 CSS 规则受到了影响，并确定每个元素的最终样式。</li><li><strong>布局 (Layout/Reflow)</strong>：如果元素的几何属性（如宽度、高度、位置）发生变化，浏览器需要重新计算受影响元素的位置和大小。</li><li><strong>绘制 (Paint)</strong>：将元素的可见内容（背景、文字、边框等）的绘制指令记录下来。</li><li><strong>合成 (Composite)</strong>：合成器线程将所有图层按照正确的顺序合并，生成最终的图像，并提交给 GPU 渲染到屏幕上。</li></ol><p><strong>注意</strong>：微任务队列的清空会发生在<strong>阶段一</strong>的宏任务执行完毕后，以及<strong>阶段二</strong>的 rAF 回调执行完毕后。</p><h3 id="阶段四-空闲时间处理-idle-period" tabindex="-1">阶段四：空闲时间处理 (Idle Period) <a class="header-anchor" href="#阶段四-空闲时间处理-idle-period" aria-label="Permalink to &quot;阶段四：空闲时间处理 (Idle Period)&quot;">​</a></h3><ol start="8"><li><strong>执行 <code>requestIdleCallback</code> (rIC) 回调</strong>： <ul><li>如果在完成以上所有工作后，当前帧的 16.67ms 还有剩余时间，浏览器就会进入“空闲状态”。</li><li>此时，<code>requestIdleCallback</code> 注册的回调函数会被调用。</li><li><strong>适用场景</strong>：非常适合用来处理那些<strong>不紧急、但又需要执行</strong>的低优先级任务，例如发送数据分析报告、进行本地数据预存储等。这样可以最大化地利用每一帧的资源，同时避免阻塞关键的渲染和交互任务。</li></ul></li></ol><h2 id="_3-总结-一个完整的视图" tabindex="-1">3. 总结：一个完整的视图 <a class="header-anchor" href="#_3-总结-一个完整的视图" aria-label="Permalink to &quot;3. 总结：一个完整的视图&quot;">​</a></h2><p>将事件循环与帧渲染结合起来，我们可以得到一个更完整的浏览器工作模型：</p><ol><li>浏览器持续进行<strong>事件循环</strong>，处理宏任务队列中的任务（如用户输入、定时器）。</li><li>在每个宏任务执行完毕后，立即<strong>清空微任务队列</strong>。</li><li>在两次屏幕刷新之间（约16.6ms），浏览器会寻找一个合适的时机启动<strong>渲染流程</strong>。</li><li>渲染流程开始时，首先执行 <code>requestAnimationFrame</code> 回调，然后依次进行<strong>样式计算 -&gt; 布局 -&gt; 绘制 -&gt; 合成</strong>。</li><li>如果在一帧的时间内完成了所有工作还有富余，浏览器会调用 <code>requestIdleCallback</code> 执行低优先级任务。</li><li>这个过程周而复始，构成了 Web 应用流畅运行的脉搏。</li></ol><p>理解这个“帧”模型，是从“让页面能看”到“让页面好用”的关键一步，也是所有高级性能优化的理论基石。</p>',25)])])}const h=o(l,[["render",s]]);export{_ as __pageData,h as default};
