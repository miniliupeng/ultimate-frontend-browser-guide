import{_ as o,c as s,o as c,ae as t}from"./chunks/framework.DK_uz7nx.js";const g=JSON.parse('{"title":"05-内容安全策略（CSP）详解：构建坚不可摧的防线","description":"","frontmatter":{},"headers":[],"relativePath":"5.浏览器安全/05-内容安全策略（CSP）详解：构建坚不可摧的防线.md","filePath":"5.浏览器安全/05-内容安全策略（CSP）详解：构建坚不可摧的防线.md"}'),i={name:"5.浏览器安全/05-内容安全策略（CSP）详解：构建坚不可摧的防线.md"};function l(n,e,a,d,r,p){return c(),s("div",null,[...e[0]||(e[0]=[t(`<h1 id="_05-内容安全策略-csp-详解-构建坚不可摧的防线" tabindex="-1">05-内容安全策略（CSP）详解：构建坚不可摧的防线 <a class="header-anchor" href="#_05-内容安全策略-csp-详解-构建坚不可摧的防线" aria-label="Permalink to &quot;05-内容安全策略（CSP）详解：构建坚不可摧的防线&quot;">​</a></h1><p>在 Web 安全的攻防战中，跨站脚本攻击（XSS）无疑是最常见、最持久的威胁之一。尽管我们采取了输入过滤、输出转义等多种防御手段，但只要有任何一处疏漏，攻击者就可能成功注入恶意脚本。为了彻底改变这种被动的局面，浏览器提供了一项强大的“终极防御”机制——<strong>内容安全策略 (Content Security Policy, CSP)</strong>。</p><p>CSP 的核心思想非常简单：<strong>通过建立一个可信资源来源的“白名单”，让浏览器只执行和加载来自这些来源的资源，从而从根本上杜绝未知来源的脚本执行</strong>。即使攻击者成功地向页面注入了 <code>&lt;script&gt;</code> 标签，由于其来源不在白名单上，浏览器也会直接拒绝执行它。</p><p>CSP 是通过 <code>Content-Security-Policy</code> HTTP 头部来启用的。</p><h2 id="_1-核心指令详解" tabindex="-1">1. 核心指令详解 <a class="header-anchor" href="#_1-核心指令详解" aria-label="Permalink to &quot;1. 核心指令详解&quot;">​</a></h2><p>一个 CSP 策略由一系列指令（directives）组成，每个指令控制一类资源的加载策略。</p><ul><li><p><strong><code>default-src</code></strong>: 这是一个备用指令，用于设置其他所有指令（<code>*-src</code>）的默认值。如果某个特定指令（如 <code>script-src</code>）没有被设置，那么它就会继承 <code>default-src</code> 的值。</p><ul><li>示例：<code>default-src &#39;self&#39; https://trusted.com;</code> (只信任当前域名和 <code>trusted.com</code> 的资源)</li></ul></li><li><p><strong><code>script-src</code></strong>: 定义 JavaScript 的有效来源。这是 CSP 中<strong>最重要、最核心</strong>的指令。</p><ul><li>示例：<code>script-src &#39;self&#39; https://apis.google.com;</code> (只允许加载来自本域和 <code>apis.google.com</code> 的脚本)</li></ul></li><li><p><strong><code>style-src</code></strong>: 定义 CSS 样式表的有效来源。</p><ul><li>示例：<code>style-src &#39;self&#39; https://fonts.googleapis.com;</code></li></ul></li><li><p><strong><code>img-src</code></strong>: 定义图片和图标的有效来源。</p><ul><li>示例：<code>img-src &#39;self&#39; data:;</code> (允许来自本域和 <code>data:</code> URI 的图片)</li></ul></li><li><p><strong><code>connect-src</code></strong>: 定义了可以通过脚本接口（如 <code>Fetch</code>, <code>XHR</code>, <code>WebSocket</code>）加载的 URL。</p><ul><li>示例：<code>connect-src &#39;self&#39; wss://api.example.com;</code></li></ul></li><li><p><strong><code>font-src</code></strong>, <strong><code>media-src</code></strong>, <strong><code>object-src</code></strong>: 分别定义字体、音视频 (<code>&lt;audio&gt;</code>, <code>&lt;video&gt;</code>) 和插件 (<code>&lt;object&gt;</code>, <code>&lt;embed&gt;</code>) 的来源。</p></li></ul><p><strong>特殊源值</strong>:</p><ul><li><code>&#39;self&#39;</code>: 指向当前文档所在的源，但不包括其子域名。</li><li><code>&#39;none&#39;</code>: 阻止加载任何来源的资源。</li><li><code>&#39;unsafe-inline&#39;</code>: 允许使用内联资源，如内联的 <code>&lt;script&gt;</code> 元素、<code>javascript:</code> URI 或内联的事件处理器（如 <code>onclick</code>）。<strong>强烈不推荐使用</strong>。</li><li><code>&#39;unsafe-eval&#39;</code>: 允许使用 <code>eval()</code> 等通过字符串创建代码的机制。<strong>同样强烈不推荐</strong>。</li></ul><h2 id="_2-应对内联脚本-nonce-与-hash" tabindex="-1">2. 应对内联脚本：<code>nonce</code> 与 <code>hash</code> <a class="header-anchor" href="#_2-应对内联脚本-nonce-与-hash" aria-label="Permalink to &quot;2. 应对内联脚本：\`nonce\` 与 \`hash\`&quot;">​</a></h2><p>一个严格的 CSP 通常会禁止所有内联脚本（<code>&#39;unsafe-inline&#39;</code>），但这会给许多现有应用带来麻烦。CSP 提供了两种更安全的方式来允许特定的内联脚本执行。</p><ul><li><p><strong><code>nonce</code> (一次性随机数)</strong>：</p><ol><li>服务器为每个请求生成一个唯一的、随机的、无法猜测的 Base64 字符串（nonce）。</li><li>在 CSP 头部中指定这个 nonce：<code>script-src &#39;self&#39; &#39;nonce-R4nd0m...&#39;;</code></li><li>在 HTML 的内联 <code>&lt;script&gt;</code> 标签中也加入这个 nonce：<code>&lt;script nonce=&quot;R4nd0m...&quot;&gt;...&lt;/script&gt;</code></li><li>浏览器只会执行 nonce 值匹配的内联脚本。</li></ol></li><li><p><strong><code>hash</code> (哈希值)</strong>：</p><ol><li>对内联脚本的内容（不包括 <code>&lt;script&gt;</code> 标签）计算其 SHA256、SHA384 或 SHA512 哈希值。</li><li>在 CSP 头部中指定这个哈希值：<code>script-src &#39;self&#39; &#39;sha256-B2y...&#39;;</code></li><li>浏览器在执行内联脚本前，会计算其哈希值并与策略中的值进行比对。</li></ol></li></ul><p><code>nonce</code> 更适合动态生成的页面，而 <code>hash</code> 更适合静态页面。</p><h2 id="_3-监控与报告" tabindex="-1">3. 监控与报告 <a class="header-anchor" href="#_3-监控与报告" aria-label="Permalink to &quot;3. 监控与报告&quot;">​</a></h2><p>部署 CSP 的一个挑战是可能会意外地阻止正常的应用资源。为此，CSP 提供了报告机制。</p><ul><li><p><strong><code>Content-Security-Policy-Report-Only</code></strong>: 这是一个与主策略并行的 HTTP 头部。使用这个头部，浏览器<strong>不会实际阻止</strong>任何资源，但会将所有违反策略的行为<strong>上报</strong>到一个指定的端点。这对于在不破坏应用的前提下测试和迭代 CSP 策略至关重要。</p></li><li><p><strong><code>report-uri</code> / <code>report-to</code></strong>: 这两个指令用于告诉浏览器将违规报告发送到哪里。</p><ul><li>示例：<code>report-uri /csp-violation-report-endpoint;</code></li></ul></li></ul><h2 id="_4-实践案例-一个严格的-csp-配置" tabindex="-1">4. 实践案例：一个严格的 CSP 配置 <a class="header-anchor" href="#_4-实践案例-一个严格的-csp-配置" aria-label="Permalink to &quot;4. 实践案例：一个严格的 CSP 配置&quot;">​</a></h2><div class="language-http vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">http</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">Content-Security-Policy</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">:</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  default-src &#39;self&#39;;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  script-src &#39;self&#39; https://www.google-analytics.com &#39;nonce-abcdef123&#39;;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  style-src &#39;self&#39; https://fonts.googleapis.com;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  font-src https://fonts.gstatic.com;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  img-src &#39;self&#39; data: https://www.google-analytics.com;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  connect-src &#39;self&#39; https://www.google-analytics.com;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  object-src &#39;none&#39;;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  frame-ancestors &#39;none&#39;;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  report-uri /csp-reports;</span></span></code></pre></div><p>这个策略的含义是：</p><ul><li>默认只信任同源资源。</li><li>脚本只能来自同源和谷歌分析，并且允许一个 nonce 值为 <code>abcdef123</code> 的内联脚本。</li><li>样式表来自同源和谷歌字体。</li><li>字体只能来自 <code>fonts.gstatic.com</code>。</li><li>图片来自同源、<code>data:</code> URI 和谷歌分析。</li><li>API 请求只能发往同源和谷歌分析。</li><li>禁止加载任何插件 (<code>object-src &#39;none&#39;</code>)。</li><li>禁止页面被嵌入到 <code>&lt;iframe&gt;</code> 中 (<code>frame-ancestors &#39;none&#39;</code>)。</li><li>将所有违规行为上报到 <code>/csp-reports</code>。</li></ul><h2 id="总结" tabindex="-1">总结 <a class="header-anchor" href="#总结" aria-label="Permalink to &quot;总结&quot;">​</a></h2><p>内容安全策略（CSP）是现代 Web 应用纵深防御体系中威力最大、也最值得投入精力去配置的一环。它将防御的主动权从“亡羊补牢”式的过滤转义，转变为了“白名单授权”式的主动设防。虽然初次配置可能较为复杂，但一旦建立起一套严格的 CSP，它就能像一道坚不可摧的城墙，保护你的应用免受绝大多数内容注入类攻击的威胁。</p>`,22)])])}const u=o(i,[["render",l]]);export{g as __pageData,u as default};
