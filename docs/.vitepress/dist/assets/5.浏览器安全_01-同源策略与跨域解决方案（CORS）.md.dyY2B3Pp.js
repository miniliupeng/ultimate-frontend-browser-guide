import{_ as i,c as e,o as a,ae as t}from"./chunks/framework.DK_uz7nx.js";const k=JSON.parse('{"title":"13-同源策略与跨域解决方案","description":"","frontmatter":{},"headers":[],"relativePath":"5.浏览器安全/01-同源策略与跨域解决方案（CORS）.md","filePath":"5.浏览器安全/01-同源策略与跨域解决方案（CORS）.md"}'),n={name:"5.浏览器安全/01-同源策略与跨域解决方案（CORS）.md"};function l(o,s,h,r,d,p){return a(),e("div",null,[...s[0]||(s[0]=[t(`<h1 id="_13-同源策略与跨域解决方案" tabindex="-1">13-同源策略与跨域解决方案 <a class="header-anchor" href="#_13-同源策略与跨域解决方案" aria-label="Permalink to &quot;13-同源策略与跨域解决方案&quot;">​</a></h1><h2 id="_1-同源策略-same-origin-policy" tabindex="-1">1. 同源策略 (Same-Origin Policy) <a class="header-anchor" href="#_1-同源策略-same-origin-policy" aria-label="Permalink to &quot;1. 同源策略 (Same-Origin Policy)&quot;">​</a></h2><p><strong>同源策略</strong>是浏览器最核心、最重要的安全策略。它规定，一个源（origin）的文档或脚本，不能与另一个源的资源进行交互。这个策略旨在隔离潜在的恶意文件，保护用户数据安全。</p><h3 id="a-什么是-源-origin" tabindex="-1">a. 什么是“源” (Origin)？ <a class="header-anchor" href="#a-什么是-源-origin" aria-label="Permalink to &quot;a. 什么是“源” (Origin)？&quot;">​</a></h3><p>“源”由<strong>协议（protocol）</strong>、**域名（domain/host）<strong>和</strong>端口（port）**三部分共同定义。只有当这三者完全相同时，两个 URL 才被认为是同源的。</p><p><strong>示例</strong>：假设当前页面的 URL 是 <code>http://www.example.com/page.html</code></p><table tabindex="0"><thead><tr><th>待比较的 URL</th><th>结果</th><th>原因</th></tr></thead><tbody><tr><td><code>http://www.example.com/other.html</code></td><td>同源</td><td>协议、域名、端口均相同</td></tr><tr><td><code>https://www.example.com/page.html</code></td><td><strong>跨域</strong></td><td>协议不同 (<code>http</code> vs <code>https</code>)</td></tr><tr><td><code>http://api.example.com/data.json</code></td><td><strong>跨域</strong></td><td>域名不同（二级域名不同）</td></tr><tr><td><code>http://www.example.com:8080/page.html</code></td><td><strong>跨域</strong></td><td>端口不同（默认 80 vs 8080）</td></tr></tbody></table><h3 id="b-同源策略的限制" tabindex="-1">b. 同源策略的限制 <a class="header-anchor" href="#b-同源策略的限制" aria-label="Permalink to &quot;b. 同源策略的限制&quot;">​</a></h3><p>同源策略主要限制了以下三种行为：</p><ol><li><strong>Cookie, LocalStorage, IndexedDB 的访问</strong>：无法读取或设置非同源的客户端存储数据。</li><li><strong>DOM 访问</strong>：无法获取或操作非同源文档的 DOM 树。例如，一个页面无法通过 <code>iframe</code> 去操作另一个不同源的页面的 DOM。</li><li><strong>AJAX 请求</strong>：无法发送 <code>XMLHttpRequest</code> 或 <code>fetch</code> 请求到非同源的服务器地址。这是前端开发中最常遇到的限制。</li></ol><p><strong>值得注意的是</strong>，有一些标签天生就允许跨域加载资源，例如：</p><ul><li><code>&lt;script src=&quot;...&quot;&gt;</code></li><li><code>&lt;link rel=&quot;stylesheet&quot; href=&quot;...&quot;&gt;</code></li><li><code>&lt;img src=&quot;...&quot;&gt;</code></li><li><code>&lt;video src=&quot;...&quot;&gt;</code>, <code>&lt;audio src=&quot;...&quot;&gt;</code></li><li><code>&lt;iframe src=&quot;...&quot;&gt;</code></li></ul><p>这些标签加载的资源可以被执行（JS）、渲染（CSS, 图片），但加载它们的页面通常无法访问其<strong>内部数据</strong>，这也是同源策略的一种体现。</p><h2 id="_2-跨域解决方案" tabindex="-1">2. 跨域解决方案 <a class="header-anchor" href="#_2-跨域解决方案" aria-label="Permalink to &quot;2. 跨域解决方案&quot;">​</a></h2><p>“跨域”就是通过各种技术手段来绕过浏览器的同源策略限制，实现不同源之间的资源共享。</p><h3 id="a-cors-cross-origin-resource-sharing-跨源资源共享" tabindex="-1">a. CORS (Cross-Origin Resource Sharing) - 跨源资源共享 <a class="header-anchor" href="#a-cors-cross-origin-resource-sharing-跨源资源共享" aria-label="Permalink to &quot;a. CORS (Cross-Origin Resource Sharing) - 跨源资源共享&quot;">​</a></h3><p><strong>CORS 是目前官方推荐、也是最主流的跨域解决方案</strong>。它是一种<strong>服务器端</strong>的机制，允许服务器在响应头中声明哪些源站有权限访问其资源。</p><h4 id="简单请求-simple-request" tabindex="-1">简单请求 (Simple Request) <a class="header-anchor" href="#简单请求-simple-request" aria-label="Permalink to &quot;简单请求 (Simple Request)&quot;">​</a></h4><p>如果一个请求同时满足以下两个条件，它就是一个“简单请求”：</p><ol><li>请求方法是 <code>GET</code>, <code>HEAD</code>, <code>POST</code> 之一。</li><li>HTTP 头部信息不超出特定字段（如 <code>Accept</code>, <code>Content-Type</code> 等，且 <code>Content-Type</code> 的值仅限于 <code>text/plain</code>, <code>multipart/form-data</code>, <code>application/x-www-form-urlencoded</code>）。</li></ol><p><strong>流程</strong>：</p><ol><li>浏览器在请求头中自动添加一个 <code>Origin</code> 字段，表明该请求来自哪个源。 <code>Origin: http://www.example.com</code></li><li>服务器收到请求后，检查 <code>Origin</code> 字段。如果该源在服务器的许可名单内，服务器会在响应头中添加 <code>Access-Control-Allow-Origin</code> 字段。 <code>Access-Control-Allow-Origin: http://www.example.com</code> (或者 <code>*</code> 表示允许任何源)</li><li>浏览器接收到响应后，检查 <code>Access-Control-Allow-Origin</code> 的值是否匹配当前源。如果匹配，请求成功；否则，浏览器会拦截该响应，并在控制台报错。</li></ol><h4 id="预检请求-preflight-request" tabindex="-1">预检请求 (Preflight Request) <a class="header-anchor" href="#预检请求-preflight-request" aria-label="Permalink to &quot;预检请求 (Preflight Request)&quot;">​</a></h4><p>对于不满足“简单请求”条件的“非简单请求”（例如请求方法是 <code>PUT</code>, <code>DELETE</code>，或者 <code>Content-Type</code> 是 <code>application/json</code>），浏览器会在发送<strong>正式请求</strong>之前，自动发送一个<strong>预检请求</strong>。</p><p><strong>预检请求</strong>使用 <code>OPTIONS</code> 方法，其目的是向服务器“咨询”：即将发送的这个正式请求，是否在你的许可范围之内？</p><p><strong>流程</strong>：</p><ol><li><strong>浏览器发送预检请求 (<code>OPTIONS</code>)</strong>： <ul><li>请求头中包含 <code>Origin</code>。</li><li><code>Access-Control-Request-Method</code>: 告知服务器，正式请求将使用的方法（如 <code>PUT</code>）。</li><li><code>Access-Control-Request-Headers</code>: 告知服务器，正式请求将携带的自定义头部。</li></ul></li><li><strong>服务器响应预检请求</strong>： <ul><li>如果服务器允许该跨域请求，响应头中会包含： <ul><li><code>Access-Control-Allow-Origin</code>: 允许的源。</li><li><code>Access-Control-Allow-Methods</code>: 允许的方法列表（如 <code>GET, POST, PUT</code>）。</li><li><code>Access-Control-Allow-Headers</code>: 允许的头部列表。</li><li><code>Access-Control-Max-Age</code>: 预检请求的有效时间（秒），在此期间内，同样的请求无需再次发送预检。</li></ul></li></ul></li><li><strong>浏览器处理预检响应</strong>： <ul><li>如果预检响应中的许可信息与即将发送的正式请求匹配, 浏览器才会发送<strong>正式的跨域请求</strong>。</li><li>否则, 浏览器会在控制台报错, 正式请求不会被发出。</li></ul></li></ol><h4 id="携带凭证的请求-requests-with-credentials" tabindex="-1">携带凭证的请求 (Requests with Credentials) <a class="header-anchor" href="#携带凭证的请求-requests-with-credentials" aria-label="Permalink to &quot;携带凭证的请求 (Requests with Credentials)&quot;">​</a></h4><p>默认情况下，跨域的 <code>fetch</code> 或 <code>XMLHttpRequest</code> 请求是<strong>不会</strong>发送 <code>Cookie</code>、HTTP认证信息等凭证的。如果需要发送，则必须满足以下条件：</p><ol><li><strong>前端设置</strong>：在 <code>fetch</code> 请求中添加 <code>credentials: &#39;include&#39;</code> 选项。对于 <code>XMLHttpRequest</code>，则需要设置 <code>withCredentials = true</code>。</li><li><strong>服务器端设置</strong>： <ul><li>响应头中必须包含 <code>Access-Control-Allow-Credentials: true</code>。</li><li>响应头中的 <code>Access-Control-Allow-Origin</code> <strong>不能</strong>是通配符 <code>*</code>，必须是明确指定的、与请求源一致的域名。</li></ul></li></ol><h3 id="b-jsonp-json-with-padding" tabindex="-1">b. JSONP (JSON with Padding) <a class="header-anchor" href="#b-jsonp-json-with-padding" aria-label="Permalink to &quot;b. JSONP (JSON with Padding)&quot;">​</a></h3><ul><li><strong>原理</strong>：利用 <code>&lt;script&gt;</code> 标签没有跨域限制的“漏洞”。</li><li><strong>流程</strong>： <ol><li>前端定义一个全局回调函数（如 <code>handleResponse</code>）。</li><li>通过 <code>&lt;script&gt;</code> 标签请求一个跨域的 URL，并将回调函数名作为参数传递过去，例如 <code>http://api.others.com/data?callback=handleResponse</code>。</li><li>服务器收到请求后，将要返回的数据作为参数，包裹在一个对该回调函数的调用中，并返回一个 JavaScript 脚本，内容如 <code>handleResponse({ &quot;data&quot;: &quot;some value&quot; })</code>。</li><li>浏览器接收并执行这个脚本，从而触发了前端定义好的 <code>handleResponse</code> 函数，数据也就被成功获取。</li></ol></li><li><strong>缺点</strong>： <ul><li><strong>只支持 GET 请求</strong>。</li><li><strong>安全性差</strong>：容易遭受 XSS 攻击，因为它是直接执行外部脚本。</li><li><strong>实现相对复杂</strong>，不如 CORS 直观。</li><li>是一种<strong>历史遗留</strong>的解决方案，在现代 Web 开发中<strong>强烈不推荐</strong>使用，除非需要兼容极其古老的浏览器。</li></ul></li></ul><h3 id="c-代理-proxy" tabindex="-1">c. 代理 (Proxy) <a class="header-anchor" href="#c-代理-proxy" aria-label="Permalink to &quot;c. 代理 (Proxy)&quot;">​</a></h3><ul><li><strong>原理</strong>：利用服务器之间不存在跨域限制的特点。</li><li><strong>流程</strong>： <ol><li>前端将跨域请求发送给<strong>自己的同源服务器</strong>。</li><li>同源服务器作为一个“中间人”，再将请求转发给目标服务器。</li><li>目标服务器将响应返回给同源服务器。</li><li>同源服务器再将响应返回给前端。</li></ol></li><li><strong>实现</strong>：在开发环境中, 可以通过 Webpack 的 <code>devServer.proxy</code> 或 Vite 的 <code>server.proxy</code> 快速配置。在生产环境中, 通常通过 Nginx 等反向代理服务器来实现。</li><li><strong>优点</strong>：实现简单, 无需目标服务器做任何修改, 是解决跨域问题的一种常用且有效的方式。</li></ul><h3 id="d-其他跨域通信方式" tabindex="-1">d. 其他跨域通信方式 <a class="header-anchor" href="#d-其他跨域通信方式" aria-label="Permalink to &quot;d. 其他跨域通信方式&quot;">​</a></h3><p>除了上述主要用于解决 AJAX 请求跨域的方案外，还存在一些适用于特定场景的跨域通信技术。</p><h4 id="_1-window-postmessage-推荐" tabindex="-1">1. <code>window.postMessage</code> (推荐) <a class="header-anchor" href="#_1-window-postmessage-推荐" aria-label="Permalink to &quot;1. \`window.postMessage\` (推荐)&quot;">​</a></h4><p><code>window.postMessage</code> 是 HTML5 引入的 API，被认为是目前最安全、最推荐的<strong>跨窗口/iframe</strong>通信方式，无论窗口之间是否同源。</p><ul><li><p><strong>发送消息</strong>：<code>otherWindow.postMessage(message, targetOrigin, [transfer]);</code></p><ul><li><code>otherWindow</code>: 目标窗口的 <code>window</code> 对象引用。</li><li><code>message</code>: 要发送的数据。</li><li><code>targetOrigin</code>: 目标窗口的源，用于限制消息接收范围，确保安全。</li></ul></li><li><p><strong>接收消息</strong>：通过监听 <code>message</code> 事件。</p><ul><li><code>event.data</code>: 接收到的消息数据。</li><li><code>event.origin</code>: 发送方窗口的源。<strong>必须校验 <code>event.origin</code></strong>，确保消息来自可信的来源。</li></ul></li></ul><p><strong>示例：</strong></p><div class="language-html vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">html</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">&lt;!-- 父窗口: http://a.com/index.html --&gt;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">iframe</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> id</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;myFrame&quot;</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> src</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;http://b.com/iframe.html&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;&lt;/</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">iframe</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">script</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> myFrame</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> document.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">getElementById</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;myFrame&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    myFrame.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">onload</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> function</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        myFrame.contentWindow.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">postMessage</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;Hello from parent!&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;http://b.com&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    };</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    window.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">addEventListener</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;message&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">function</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">event</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">        // 必须校验来源</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">        if</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (event.origin </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">!==</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &#39;http://b.com&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">return</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        console.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">log</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;Received from iframe:&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, event.data);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    });</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;/</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">script</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">&lt;!-- 子窗口: http://b.com/iframe.html --&gt;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">script</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    window.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">addEventListener</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;message&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">function</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">event</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">        // 必须校验来源</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">        if</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (event.origin </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">!==</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &#39;http://a.com&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">return</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        console.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">log</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;Received from parent:&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, event.data);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        </span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">        // 向父窗口回送消息</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        event.source.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">postMessage</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;Hi, I am iframe!&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, event.origin);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    });</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;/</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">script</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;</span></span></code></pre></div><h4 id="_2-websocket" tabindex="-1">2. WebSocket <a class="header-anchor" href="#_2-websocket" aria-label="Permalink to &quot;2. WebSocket&quot;">​</a></h4><p>WebSocket 协议本身支持跨域通信。它的握手请求（一个 HTTP Upgrade 请求）遵循同源策略，因此可能需要服务器进行 CORS 验证。一旦连接成功建立，后续的数据帧传输就不再受同源策略的限制，可以实现持久化的全双工跨域通信。</p><h4 id="_3-历史方案-不推荐" tabindex="-1">3. 历史方案 (不推荐) <a class="header-anchor" href="#_3-历史方案-不推荐" aria-label="Permalink to &quot;3. 历史方案 (不推荐)&quot;">​</a></h4><p>以下是一些在 <code>postMessage</code> 出现之前被使用的“hack”方案，因实现复杂或有安全隐患，在现代开发中已基本被取代。</p><ul><li><strong><code>iframe + window.name</code></strong>: 利用 <code>window.name</code> 属性在一个窗口的生命周期内（即使 URL 变化）都保持不变的特点。通过让 <code>iframe</code> 先加载一个跨域页面，将数据赋给 <code>window.name</code>，然后再将 <code>iframe</code> 跳转回同源页面，此时父窗口就可以安全地读取 <code>iframe</code> 的 <code>window.name</code> 来获取数据。</li><li><strong><code>iframe + location.hash</code></strong>: 利用 URL 的 hash 值（<code>#</code> 后面的部分）发生改变不会导致页面刷新的特性。父窗口可以通过修改子窗口的 URL hash 来传递信息，子窗口可以通过定时器监听 <code>location.hash</code> 的变化来接收信息。通过一个同源的中间 <code>iframe</code>，可以实现更复杂的双向通信。</li></ul>`,46)])])}const g=i(n,[["render",l]]);export{k as __pageData,g as default};
