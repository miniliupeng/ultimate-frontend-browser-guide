import{_ as r,c as i,o as l,ae as e}from"./chunks/framework.DK_uz7nx.js";const u=JSON.parse('{"title":"07-现代 Web 渲染模式：CSR, SSR, SSG 与 ISR","description":"","frontmatter":{},"headers":[],"relativePath":"3.页面渲染与性能优化/07-现代Web渲染模式：SSR, SSG与ISR.md","filePath":"3.页面渲染与性能优化/07-现代Web渲染模式：SSR, SSG与ISR.md"}'),n={name:"3.页面渲染与性能优化/07-现代Web渲染模式：SSR, SSG与ISR.md"};function o(s,t,a,d,g,S){return l(),i("div",null,[...t[0]||(t[0]=[e('<h1 id="_07-现代-web-渲染模式-csr-ssr-ssg-与-isr" tabindex="-1">07-现代 Web 渲染模式：CSR, SSR, SSG 与 ISR <a class="header-anchor" href="#_07-现代-web-渲染模式-csr-ssr-ssg-与-isr" aria-label="Permalink to &quot;07-现代 Web 渲染模式：CSR, SSR, SSG 与 ISR&quot;">​</a></h1><p>前端性能优化的讨论，通常聚焦于如何减少重排、优化图片等“战术”层面。然而，一个 Web 应用的性能天花板，往往在项目初期选择<strong>渲染模式</strong>时就已经被决定了。理解不同的渲染模式及其利弊，是在“战略”层面构建高性能应用的基础。</p><h2 id="_1-客户端渲染-client-side-rendering-csr" tabindex="-1">1. 客户端渲染 (Client-Side Rendering, CSR) <a class="header-anchor" href="#_1-客户端渲染-client-side-rendering-csr" aria-label="Permalink to &quot;1. 客户端渲染 (Client-Side Rendering, CSR)&quot;">​</a></h2><p>这是现代单页应用（SPA）最基础、最常见的渲染模式。</p><ul><li><strong>工作流程</strong>： <ol><li>浏览器请求 URL，服务器返回一个几乎空白的 HTML “空壳”（通常只有一个 <code>&lt;div id=&quot;app&quot;&gt;&lt;/div&gt;</code>）和一个巨大的 JavaScript 包 (<code>bundle.js</code>)。</li><li>浏览器下载并执行 JavaScript。</li><li>JavaScript 代码（如 React, Vue）在客户端初始化，通过 API 获取数据，然后将整个页面内容渲染到 DOM 中。</li></ol></li><li><strong>优点</strong>： <ul><li><strong>服务器压力小</strong>：服务器只负责提供静态文件和 API，所有渲染逻辑都在客户端完成。</li><li><strong>优秀的后续导航体验</strong>：首屏渲染完成后，后续的页面切换（路由跳转）无需刷新页面，体验流畅，接近原生应用。</li></ul></li><li><strong>缺点</strong>： <ul><li><strong>首屏性能差 (FCP/LCP 慢)</strong>：在 JS 下载和执行完成前，用户看到的是一个白屏，这导致很差的首次加载体验。</li><li><strong>SEO 不友好</strong>：虽然现代搜索引擎爬虫对 JS 的执行能力有所提升，但仍不稳定。爬虫很可能只会看到一个空白的 HTML，无法抓取到页面内容。</li></ul></li></ul><h2 id="_2-服务器端渲染-server-side-rendering-ssr" tabindex="-1">2. 服务器端渲染 (Server-Side Rendering, SSR) <a class="header-anchor" href="#_2-服务器端渲染-server-side-rendering-ssr" aria-label="Permalink to &quot;2. 服务器端渲染 (Server-Side Rendering, SSR)&quot;">​</a></h2><p>SSR (有时也称“同构应用”或“通用应用”) 正是为了解决 CSR 的两大痛点而生。</p><ul><li><strong>工作流程</strong>： <ol><li>浏览器请求 URL。</li><li>服务器<strong>在 Node.js 环境中</strong>执行前端框架代码（如 React, Vue），获取数据，将组件渲染成完整的 HTML 字符串。</li><li>服务器将这个包含完整首屏内容的 HTML 直接返回给浏览器。</li><li>浏览器立即显示页面内容（<strong>首屏性能极佳</strong>）。</li><li>与此同时，浏览器在后台下载 JavaScript 包。</li><li>JS 下载执行完毕后，会进行一个称为“<strong>注水 (Hydration)</strong>”的过程，即接管由服务器渲染的静态 DOM，为其附加事件监听器，使其变为一个完全可交互的 SPA。</li></ol></li><li><strong>优点</strong>： <ul><li><strong>极佳的首屏性能 (FCP/LCP 快)</strong>：用户能以最快的速度看到页面内容。</li><li><strong>SEO 友好</strong>：返回给爬虫的是包含完整内容的 HTML。</li></ul></li><li><strong>缺点</strong>： <ul><li><strong>服务器压力大</strong>：每个请求都需要在服务器上实时进行一次完整的渲染。</li><li><strong>开发复杂性高</strong>：需要处理 Node.js 环境、组件生命周期、数据获取等在客户端和服务器端表现不一致的问题。</li><li><strong>TTI (可交互时间) 可能较长</strong>：虽然用户很快看到了内容，但在“注水”完成前，页面是无法交互的（例如点击按钮没反应）。</li></ul></li></ul><h2 id="_3-静态站点生成-static-site-generation-ssg" tabindex="-1">3. 静态站点生成 (Static Site Generation, SSG) <a class="header-anchor" href="#_3-静态站点生成-static-site-generation-ssg" aria-label="Permalink to &quot;3. 静态站点生成 (Static Site Generation, SSG)&quot;">​</a></h2><p>如果你的页面内容不是高度个性化的，并且不需要在每次请求时都发生变化，那么 SSG 可能是性能最优的选择。</p><ul><li><strong>工作流程</strong>： <ol><li>在<strong>构建阶段 (build time)</strong>，而不是请求阶段，预先抓取所有需要的数据。</li><li>为应用中的<strong>每一个页面</strong>都生成一个对应的、包含完整内容的静态 HTML 文件。</li><li>将这些生成的 HTML 文件和静态资源部署到 CDN 上。</li></ol></li><li><strong>优点</strong>： <ul><li><strong>极致的性能</strong>：用户访问的是 CDN 上的静态 HTML，加载速度无与伦比。</li><li><strong>高可靠性与安全性</strong>：没有服务器端逻辑，不受数据库或 API 故障的影响，攻击面也最小。</li><li><strong>SEO 友好</strong>。</li></ul></li><li><strong>缺点</strong>： <ul><li><strong>内容更新不灵活</strong>：每次内容变更（例如发布一篇新博客），都需要<strong>重新构建和部署</strong>整个网站。不适用于内容频繁变化或个性化的场景。</li><li><strong>构建时间长</strong>：对于大型网站（如上万篇博客），构建过程可能会非常耗时。</li></ul></li></ul><h2 id="_4-增量静态再生-incremental-static-regeneration-isr" tabindex="-1">4. 增量静态再生 (Incremental Static Regeneration, ISR) <a class="header-anchor" href="#_4-增量静态再生-incremental-static-regeneration-isr" aria-label="Permalink to &quot;4. 增量静态再生 (Incremental Static Regeneration, ISR)&quot;">​</a></h2><p>ISR 是由 Vercel (Next.js 的母公司) 提出的一种创新的渲染模式，它巧妙地结合了 SSG 的性能优势和 SSR 的内容动态性。</p><ul><li><strong>工作流程</strong>： <ol><li>行为与 SSG 非常相似，页面在构建时被静态生成。</li><li>但在部署后，当用户请求一个页面时，服务器会返回缓存的静态 HTML。</li><li>同时，可以配置一个<strong>再生 (revalidate) 周期</strong>（例如 60 秒）。如果页面访问发生在上次生成超过 60 秒后，服务器会在<strong>后台</strong>悄悄地重新生成这个页面。</li><li>生成成功后，会用新的页面替换掉旧的缓存。下一个访问该页面的用户将会看到最新的内容。</li></ol></li><li><strong>优点</strong>： <ul><li><strong>兼顾静态性能与内容更新</strong>：用户总是能快速地从缓存中获取页面，同时又能保证内容在一定周期后自动刷新。</li><li><strong>按需生成</strong>：对于未在构建时生成的页面，可以在第一次被访问时按需生成并缓存，解决了大型网站构建时间过长的问题。</li></ul></li><li><strong>缺点</strong>： <ul><li><strong>内容非实时</strong>：内容更新存在一定的延迟（取决于 <code>revalidate</code> 周期）。</li></ul></li></ul><h2 id="总结-如何选择" tabindex="-1">总结：如何选择？ <a class="header-anchor" href="#总结-如何选择" aria-label="Permalink to &quot;总结：如何选择？&quot;">​</a></h2><table tabindex="0"><thead><tr><th>渲染模式</th><th>性能 (FCP/LCP)</th><th>SEO</th><th>服务器成本</th><th>内容实时性</th><th>适用场景</th></tr></thead><tbody><tr><td><strong>CSR</strong></td><td>差</td><td>差</td><td>低</td><td>实时</td><td>后台管理系统、重交互的 Web 应用</td></tr><tr><td><strong>SSR</strong></td><td>优秀</td><td>优秀</td><td>高</td><td>实时</td><td>内容驱动、需要 SEO 和良好首屏的动态网站（如电商、新闻）</td></tr><tr><td><strong>SSG</strong></td><td>极致</td><td>优秀</td><td>极低</td><td>差（需重新构建）</td><td>内容不常变的网站（如博客、文档站、营销页）</td></tr><tr><td><strong>ISR</strong></td><td>极致</td><td>优秀</td><td>低</td><td>准实时</td><td>内容需要定期更新的大型内容网站</td></tr></tbody></table><p>现代前端框架（如 Next.js, Nuxt.js, SvelteKit）通常都提供了对上述多种渲染模式的内置支持，允许开发者根据不同页面的需求，灵活地选择最合适的渲染策略。</p>',17)])])}const h=r(n,[["render",o]]);export{u as __pageData,h as default};
