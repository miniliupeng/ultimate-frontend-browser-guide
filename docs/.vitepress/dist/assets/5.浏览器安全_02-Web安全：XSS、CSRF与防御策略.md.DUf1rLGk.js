import{_ as t,c as e,o as r,ae as i}from"./chunks/framework.DK_uz7nx.js";const u=JSON.parse('{"title":"14-Web安全：XSS、CSRF与防御策略","description":"","frontmatter":{},"headers":[],"relativePath":"5.浏览器安全/02-Web安全：XSS、CSRF与防御策略.md","filePath":"5.浏览器安全/02-Web安全：XSS、CSRF与防御策略.md"}'),s={name:"5.浏览器安全/02-Web安全：XSS、CSRF与防御策略.md"};function l(n,o,g,c,d,a){return r(),e("div",null,[...o[0]||(o[0]=[i('<h1 id="_14-web安全-xss、csrf与防御策略" tabindex="-1">14-Web安全：XSS、CSRF与防御策略 <a class="header-anchor" href="#_14-web安全-xss、csrf与防御策略" aria-label="Permalink to &quot;14-Web安全：XSS、CSRF与防御策略&quot;">​</a></h1><p>Web 安全是一个庞大的领域，其中，XSS 和 CSRF 是两种最常见、也最需要前端工程师深入理解的攻击类型。</p><h2 id="_1-xss-cross-site-scripting-跨站脚本攻击" tabindex="-1">1. XSS (Cross-Site Scripting) - 跨站脚本攻击 <a class="header-anchor" href="#_1-xss-cross-site-scripting-跨站脚本攻击" aria-label="Permalink to &quot;1. XSS (Cross-Site Scripting) - 跨站脚本攻击&quot;">​</a></h2><ul><li><strong>核心原理</strong>：攻击者通过某种方式，将<strong>恶意的 JavaScript 脚本注入</strong>到正常的网页中，当其他用户访问这个网页时，这些恶意脚本就会在用户的浏览器上执行。</li><li><strong>攻击目标</strong>：窃取用户的敏感信息（如 Cookie、LocalStorage）、劫持用户会话、伪造用户操作、在页面上展示钓鱼内容等。</li><li><strong>本质</strong>：XSS 的本质是<strong>代码注入</strong>，攻击者利用了网站对用户输入内容<strong>过度信任</strong>的漏洞。</li></ul><h3 id="a-xss-的类型" tabindex="-1">a. XSS 的类型 <a class="header-anchor" href="#a-xss-的类型" aria-label="Permalink to &quot;a. XSS 的类型&quot;">​</a></h3><ol><li><p><strong>存储型 XSS (Stored XSS)</strong></p><ul><li><strong>流程</strong>： <ol><li>攻击者将恶意脚本提交并<strong>存储</strong>到目标网站的<strong>数据库</strong>中（例如，通过发表一篇包含 <code>&lt;script&gt;</code> 标签的文章、或在个人简介中写入恶意代码）。</li><li>当其他用户访问展示这些内容的页面时，服务器会从数据库中读取并拼接出 HTML，恶意脚本作为正常内容的一部分被发送到用户的浏览器。</li><li>恶意脚本在用户的浏览器上执行。</li></ol></li><li><strong>特点</strong>：危害最大，影响范围最广，因为一次成功的攻击可以影响所有访问该页面的用户。</li></ul></li><li><p><strong>反射型 XSS (Reflected XSS)</strong></p><ul><li><strong>流程</strong>： <ol><li>攻击者构造一个包含恶意脚本的<strong>特制 URL</strong>，并诱导用户点击。</li><li>用户点击后，恶意脚本作为 URL 的一部分（通常是查询参数）被发送到服务器。</li><li>服务器从 URL 中获取参数，未经充分处理就<strong>反射</strong>回 HTML 响应中（例如，在搜索结果页面显示 &quot;您搜索的关键词是：&lt;恶意脚本&gt;&quot;）。</li><li>恶意脚本在用户的浏览器上执行。</li></ol></li><li><strong>特点</strong>：非持久化，攻击行为只发生在点击了特制 URL 的用户身上，是一次性的。</li></ul></li><li><p><strong>DOM 型 XSS (DOM-based XSS)</strong></p><ul><li><strong>流程</strong>：这是一种特殊类型的反射型 XSS。它的整个过程都发生在<strong>客户端</strong>。 <ol><li>攻击者构造一个包含恶意代码的 URL（通常在 <code>#</code> hash 部分）。</li><li>用户点击 URL 后，前端的 JavaScript 获取 URL 中的数据（如 <code>location.hash</code>），并且在<strong>未经转义</strong>的情况下，直接将其写入到页面的 DOM 中（例如通过 <code>innerHTML</code>）。</li><li>恶意脚本被当作 HTML 的一部分，在用户的浏览器上执行。</li></ol></li><li><strong>特点</strong>：服务器端可能完全感知不到这次攻击，因为恶意代码可能根本不会发送到服务器。</li></ul></li></ol><h3 id="b-xss-的防御策略" tabindex="-1">b. XSS 的防御策略 <a class="header-anchor" href="#b-xss-的防御策略" aria-label="Permalink to &quot;b. XSS 的防御策略&quot;">​</a></h3><p>核心思想是<strong>不信任任何用户输入</strong>。</p><ol><li><p><strong>输入过滤与输出转义 (核心)</strong></p><ul><li><strong>输入过滤 (Input Filtering)</strong>：在数据存入数据库<strong>之前</strong>，根据业务需求对用户的输入进行验证和过滤（例如，限制用户名只能是字母和数字）。但这不能作为主要的防御手段。</li><li><strong>输出转义 (Output Escaping)</strong>：在将数据插入到 HTML <strong>之前</strong>，对其进行 HTML 实体转义。这是<strong>最根本、最有效</strong>的防御方法。 <ul><li>将特殊字符（如 <code>&lt;</code>, <code>&gt;</code>, <code>&quot;</code>, <code>&#39;</code>, <code>&amp;</code>）转换成它们的 HTML 实体（如 <code>&amp;lt;</code>, <code>&amp;gt;</code>, <code>&amp;quot;</code>, <code>&amp;#39;</code>, <code>&amp;amp;</code>）。</li><li>现代前端框架（如 React, Vue）默认都会对动态插入的内容进行转义，大大降低了 XSS 的风险。</li><li><strong>警惕 <code>innerHTML</code>, <code>outerHTML</code>, <code>document.write()</code> 等 API</strong>，它们会直接将字符串作为 HTML 解析，应避免使用用户提供的内容来填充它们。如果必须使用，请确保内容经过了严格的过滤和转义。</li><li><strong>（新兴）使用 <code>Trusted Types</code></strong>：这是一个由浏览器提供的较新的 API，旨在从根本上消除 DOM XSS。它要求开发者在调用 <code>innerHTML</code> 等危险 API 之前，必须先将字符串数据封装成一个经过策略函数处理的“可信类型”对象，从而阻止未经验证的数据注入。</li></ul></li></ul></li><li><p><strong>内容安全策略 (Content Security Policy, CSP)</strong></p><ul><li><strong>原理</strong>：通过设置 HTTP 响应头 <code>Content-Security-Policy</code>，告知浏览器一个“白名单”，明确规定页面只允许加载和执行来自这些指定来源的资源（脚本、样式、图片等）。</li><li><strong>作用</strong>：即使攻击者成功注入了恶意脚本，由于脚本来源不在白名单内，浏览器也会拒绝执行它，从而提供了第二道坚实的防线。</li></ul></li><li><p><strong>设置 HttpOnly Cookie</strong></p><ul><li><strong>原理</strong>：为关键的 Cookie（如 Session ID）设置 <code>HttpOnly</code> 属性。</li><li><strong>作用</strong>：设置了 <code>HttpOnly</code> 的 Cookie 将<strong>无法通过 JavaScript 的 <code>document.cookie</code> API 来访问</strong>。这可以有效防止 XSS 攻击者通过脚本窃取用户的会话 Cookie。</li></ul></li><li><p><strong>使用 <code>iframe</code> 沙箱 (<code>sandbox</code>)</strong></p><ul><li><strong>原理</strong>：当需要展示来自用户或第三方的、不可信的 HTML 内容时，可以将其嵌入到一个设置了 <code>sandbox</code> 属性的 <code>&lt;iframe&gt;</code> 中。</li><li><strong>作用</strong>：<code>sandbox</code> 属性可以极大地限制 <code>iframe</code> 内部页面的权限，例如禁止执行脚本 (<code>allow-scripts</code>)、禁止访问父窗口的 DOM、禁止提交表单等，从而将潜在的 XSS 风险隔离在 <code>iframe</code> 内部。</li></ul></li></ol><h2 id="_2-csrf-cross-site-request-forgery-跨站请求伪造" tabindex="-1">2. CSRF (Cross-Site Request Forgery) - 跨站请求伪造 <a class="header-anchor" href="#_2-csrf-cross-site-request-forgery-跨站请求伪造" aria-label="Permalink to &quot;2. CSRF (Cross-Site Request Forgery) - 跨站请求伪造&quot;">​</a></h2><ul><li><strong>核心原理</strong>：攻击者<strong>诱导</strong>已登录的用户，在用户<strong>不知情</strong>的情况下，点击一个恶意链接或访问一个恶意页面，该页面会向被攻击的网站<strong>发送一个伪造的请求</strong>。</li><li><strong>攻击目标</strong>：利用用户已经获取的登录凭证（特别是 Cookie），冒充用户执行非本意的操作，如修改密码、转账、发表文章等。</li><li><strong>本质</strong>：CSRF 的本质是<strong>利用了浏览器会自动携带 Cookie 的机制</strong>，攻击者并没有窃取到 Cookie，只是“借用”了用户的身份。</li></ul><h3 id="a-csrf-的攻击流程-以-get-请求为例" tabindex="-1">a. CSRF 的攻击流程 (以 GET 请求为例) <a class="header-anchor" href="#a-csrf-的攻击流程-以-get-请求为例" aria-label="Permalink to &quot;a. CSRF 的攻击流程 (以 GET 请求为例)&quot;">​</a></h3><ol><li>用户登录了目标网站 A (<code>bank.com</code>)，浏览器中保存了 A 网站的登录凭证 Cookie。</li><li>用户在未退出的情况下，访问了攻击者精心构造的恶意网站 B。</li><li>网站 B 中可能有一个看似无害的图片标签：<code>&lt;img src=&quot;http://bank.com/transfer?to=attacker&amp;amount=1000&quot;&gt;</code>。</li><li>当用户的浏览器加载这个图片时，它会<strong>自动携带上 <code>bank.com</code> 的 Cookie</strong>，向 <code>bank.com</code> 的服务器发起一个 GET 请求。</li><li><code>bank.com</code> 的服务器验证 Cookie，确认是合法用户的请求，于是执行了转账操作。整个过程用户毫不知情。</li></ol><h3 id="b-csrf-的防御策略" tabindex="-1">b. CSRF 的防御策略 <a class="header-anchor" href="#b-csrf-的防御策略" aria-label="Permalink to &quot;b. CSRF 的防御策略&quot;">​</a></h3><p>核心思想是<strong>验证请求的来源</strong>，确保请求是用户主动发起的。</p><ol><li><p><strong>验证 Referer 头部</strong></p><ul><li><strong>原理</strong>：在服务器端检查 HTTP 请求头中的 <code>Referer</code> 字段，该字段表明了请求是从哪个页面发起的。可以设置一个白名单，只允许来自同源页面的请求。</li><li><strong>缺点</strong>：<code>Referer</code> 头部可以被用户或浏览器插件修改或禁用，因此不是一个完全可靠的防御手段。</li></ul></li><li><p><strong>使用 Anti-CSRF Token (核心)</strong></p><ul><li><strong>原理</strong>：这是目前最常用、最有效的有状态（Stateful）防御方法。</li><li><strong>流程</strong>： <ol><li>用户访问页面时，服务器生成一个<strong>随机的、不可预测的 Token</strong>，并将其与用户的会话（Session）绑定。</li><li>服务器将这个 Token 嵌入到页面的表单中（作为一个隐藏字段）或者通过 API 返回给前端。</li><li>当用户提交表单或发送请求时，前端需要将这个 Token 一起提交（可以放在请求体或请求头中）。</li><li>服务器在接收到请求后，<strong>验证提交的 Token 是否与会话中存储的 Token 一致</strong>。</li></ol></li><li><strong>作用</strong>：攻击者无法获取到这个与用户会话绑定的随机 Token，因此他们伪造的请求中将不包含或包含错误的 Token，服务器端验证失败，从而拒绝该请求。</li></ul></li><li><p><strong>双重 Cookie 验证 (Double Submit Cookie)</strong></p><ul><li><strong>原理</strong>：这是一种无状态（Stateless）的 CSRF 防御模式，对于不依赖 Session 的应用（如使用 JWT）非常有用。</li><li><strong>流程</strong>： <ol><li>用户登录后，服务器生成一个 Token 并将其设置在用户的 <strong>Cookie</strong> 中（非 <code>HttpOnly</code>）。</li><li>前端在发起请求时，通过 JavaScript 读取该 Cookie 的值，并将其作为请求头（如 <code>X-CSRF-Token</code>）或请求体的一部分发送给服务器。</li><li>服务器接收到请求后，<strong>同时验证请求中的 Token 和 Cookie 中的 Token 是否一致</strong>。</li></ol></li><li><strong>作用</strong>：攻击者可以伪造请求，但由于同源策略的限制，他们无法在自己的恶意网站上读取用户在被攻击网站下的 Cookie，因此无法构造出包含正确 Token 的请求。</li></ul></li><li><p><strong>设置 SameSite Cookie 属性</strong></p><ul><li><strong>原理</strong>：为 Cookie 设置 <code>SameSite</code> 属性，可以告知浏览器在跨站请求中是否应该携带这个 Cookie。</li><li><strong>属性值</strong>： <ul><li><code>Strict</code>：最严格。完全禁止在任何跨站请求中携带 Cookie。</li><li><code>Lax</code>：适度宽松。允许在一些顶层导航（如点击链接、GET 表单）的跨站请求中携带 Cookie，但在 <code>POST</code>, <code>iframe</code> 等场景下会禁止。这是目前很多浏览器的默认值。</li><li><code>None</code>：允许在所有跨站请求中携带 Cookie，但必须同时设置 <code>Secure</code> 属性（即只在 HTTPS 中生效）。</li></ul></li><li><strong>作用</strong>：将关键 Cookie 设置为 <code>SameSite=Strict</code> 或 <code>SameSite=Lax</code> 可以有效地防御大部分 CSRF 攻击。它是<strong>纵深防御体系</strong>中的重要一环，应与 Anti-CSRF Token 配合使用，以提供更全面的保护。</li></ul></li></ol><h2 id="_3-xss-vs-csrf-总结" tabindex="-1">3. XSS vs CSRF - 总结 <a class="header-anchor" href="#_3-xss-vs-csrf-总结" aria-label="Permalink to &quot;3. XSS vs CSRF - 总结&quot;">​</a></h2><table tabindex="0"><thead><tr><th>对比项</th><th>XSS (跨站脚本攻击)</th><th>CSRF (跨站请求伪造)</th></tr></thead><tbody><tr><td><strong>攻击原理</strong></td><td>向页面注入恶意脚本，在用户浏览器上执行</td><td>冒用用户的身份，发送用户非本意的请求</td></tr><tr><td><strong>攻击目标</strong></td><td><strong>窃取</strong>用户信息（如 Cookie）</td><td><strong>利用</strong>用户身份执行操作（不窃取）</td></tr><tr><td><strong>信任关系</strong></td><td>攻击者利用了网站对<strong>用户输入</strong>的信任</td><td>攻击者利用了浏览器对<strong>Cookie</strong>的信任（自动携带）</td></tr><tr><td><strong>主要防御</strong></td><td>输入过滤、输出转义、CSP、HttpOnly Cookie</td><td>Anti-CSRF Token、SameSite Cookie、验证 Referer</td></tr></tbody></table>',18)])])}const p=t(s,[["render",l]]);export{u as __pageData,p as default};
