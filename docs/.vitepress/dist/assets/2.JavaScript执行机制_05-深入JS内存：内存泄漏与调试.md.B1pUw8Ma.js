import{_ as i,c as a,o as n,ae as l}from"./chunks/framework.DK_uz7nx.js";const g=JSON.parse('{"title":"08-深入JS内存：内存泄漏与调试","description":"","frontmatter":{},"headers":[],"relativePath":"2.JavaScript执行机制/05-深入JS内存：内存泄漏与调试.md","filePath":"2.JavaScript执行机制/05-深入JS内存：内存泄漏与调试.md"}'),t={name:"2.JavaScript执行机制/05-深入JS内存：内存泄漏与调试.md"};function h(e,s,p,k,r,d){return n(),a("div",null,[...s[0]||(s[0]=[l(`<h1 id="_08-深入js内存-内存泄漏与调试" tabindex="-1">08-深入JS内存：内存泄漏与调试 <a class="header-anchor" href="#_08-深入js内存-内存泄漏与调试" aria-label="Permalink to &quot;08-深入JS内存：内存泄漏与调试&quot;">​</a></h1><p>内存泄漏（Memory Leak）是指应用程序中已分配的内存，由于某种原因未能被正确释放，导致其持续被占用。随着时间的推移，泄漏的内存会越积越多，可能导致应用性能下降、页面卡顿，甚至浏览器崩溃。</p><p>理解常见的内存泄漏场景并掌握调试工具，是每一位高级前端工程师的必备技能。</p><h2 id="_1-常见的内存泄漏场景-附示例" tabindex="-1">1. 常见的内存泄漏场景（附示例） <a class="header-anchor" href="#_1-常见的内存泄漏场景-附示例" aria-label="Permalink to &quot;1. 常见的内存泄漏场景（附示例）&quot;">​</a></h2><p>内存泄漏的根本原因是：<strong>一个不再需要的对象，仍然被一个可达的对象（或全局变量）直接或间接地引用着，导致垃圾回收（GC）无法回收它。</strong></p><h3 id="a-意外的全局变量" tabindex="-1">a. 意外的全局变量 <a class="header-anchor" href="#a-意外的全局变量" aria-label="Permalink to &quot;a. 意外的全局变量&quot;">​</a></h3><ul><li><strong>原因</strong>：在非严格模式下，给一个未声明的变量赋值，会在全局对象（<code>window</code>）上创建一个同名属性。如果这个变量引用了一个大对象，那么只要页面不关闭，这个对象就永远不会被回收。</li><li><strong>示例</strong>：<div class="language-javascript vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">function</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> createLeakingObject</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() {</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">  // &#39;leakingData&#39; 未经 &#39;var&#39;, &#39;let&#39; 或 &#39;const&#39; 声明</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  leakingData </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> new</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Array</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1000000</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">).</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">join</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;*&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">); </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 变成 window.leakingData</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">createLeakingObject</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">();</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 即使 createLeakingObject 执行完毕，leakingData 依然存在</span></span></code></pre></div></li><li><strong>如何避免</strong>：始终使用 <code>&#39;use strict&#39;;</code> 开启严格模式。</li></ul><h3 id="b-被遗忘的定时器或回调函数" tabindex="-1">b. 被遗忘的定时器或回调函数 <a class="header-anchor" href="#b-被遗忘的定时器或回调函数" aria-label="Permalink to &quot;b. 被遗忘的定时器或回调函数&quot;">​</a></h3><ul><li><p><strong>原因</strong>：<code>setInterval</code> 或 <code>setTimeout</code> 如果在组件销毁或不再需要时没有被清除，那么它们的回调函数以及回调函数所引用的外部变量（闭包），将一直无法被回收。</p></li><li><p><strong>示例</strong>：</p><div class="language-javascript vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">function</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> setupInterval</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> someLargeObject</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> { data: </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">new</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Array</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1000000</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">).</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">join</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;*&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) };</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  </span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">  setInterval</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(() </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    // 匿名回调函数引用了 someLargeObject</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    console.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">log</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(someLargeObject.data.</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">length</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  }, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1000</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  </span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">  // 没有调用 clearInterval</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">setupInterval</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">();</span></span></code></pre></div></li><li><p><strong>如何避免</strong>：在组件的销毁生命周期中（如 React 的 <code>useEffect</code> 的清理函数、Vue 的 <code>beforeDestroy</code>/<code>unmounted</code>），务必调用 <code>clearInterval</code> 或 <code>clearTimeout</code>。对于 <code>addEventListener</code> 等添加的事件监听，也要在组件销毁时调用 <code>removeEventListener</code>。</p></li></ul><h3 id="c-分离的-dom-节点-detached-dom" tabindex="-1">c. 分离的 DOM 节点 (Detached DOM) <a class="header-anchor" href="#c-分离的-dom-节点-detached-dom" aria-label="Permalink to &quot;c. 分离的 DOM 节点 (Detached DOM)&quot;">​</a></h3><ul><li><strong>原因</strong>：一个 DOM 节点已经从 DOM 树中被移除，但 JavaScript 代码中仍然保留着对它的引用。</li><li><strong>示例</strong>：<div class="language-javascript vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">let</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> detachedElement </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> null</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">function</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> createDetachedNode</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> ul</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> document.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">createElement</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;ul&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  for</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">let</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> i </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">; i </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&lt;</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 10</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">; i</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">++</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> li</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> document.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">createElement</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;li&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    ul.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">appendChild</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(li);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  }</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">  // 将 ul 存入一个全局可达的变量</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  detachedElement </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> ul;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">function</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> removeNodeFromDOM</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() {</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">  // 假设页面上有一个 id 为 &#39;container&#39; 的元素</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> container</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> document.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">getElementById</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;container&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">  // 将 detachedElement 从 DOM 树中移除</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  if</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (container </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&amp;&amp;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> container.firstChild) {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    container.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">removeChild</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(container.firstChild);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 1. 创建并引用</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">createDetachedNode</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(); </span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">document.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">getElementById</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;container&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">).</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">appendChild</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(detachedElement);</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 2. 从 DOM 中移除，但 JS 引用依然存在</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">removeNodeFromDOM</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(); </span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// detachedElement 及其所有子节点都无法被 GC 回收</span></span></code></pre></div></li><li><strong>如何避免</strong>：在移除 DOM 节点后，确保所有指向它的 JavaScript 引用都被设置为 <code>null</code>。</li></ul><h3 id="d-闭包的无意引用" tabindex="-1">d. 闭包的无意引用 <a class="header-anchor" href="#d-闭包的无意引用" aria-label="Permalink to &quot;d. 闭包的无意引用&quot;">​</a></h3><ul><li><strong>原因</strong>：闭包会使其外部函数的作用域持续存在。如果一个外部函数的变量引用了一个大对象，而这个变量又被一个生命周期很长的内部函数（闭包）所使用，就可能导致内存泄漏。</li><li><strong>示例</strong>：<div class="language-javascript vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">function</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> createClosure</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> largeObject</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> new</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Array</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1000000</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">).</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">join</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;*&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  </span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  return</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> function</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">name</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    // largeObject 在这里并没有被使用，但它依然存活于闭包的作用域链中</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    console.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">log</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">\`Hello, \${</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">name</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">}\`</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  };</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> myClosure</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> createClosure</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">();</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// myClosure 将一直存在，导致 largeObject 无法被回收</span></span></code></pre></div></li><li><strong>如何避免</strong>：谨慎设计闭包。如果内部函数不需要某个外部变量，应在不再使用时将其设置为 <code>null</code>，或通过重构避免不必要的引用。</li><li><strong>优化后示例</strong>：<div class="language-javascript vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">function</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> createClosureOptimized</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> largeObject</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> { data: </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">new</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Array</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1000000</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">).</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">join</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;*&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">), name: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;MyObject&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> };</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> name</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> largeObject.name; </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 只提取需要的数据</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  </span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  return</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> function</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() {</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    // 现在闭包只引用了 name, 而不是整个 largeObject</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    console.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">log</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">\`Hello, \${</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">name</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">}\`</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  };</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> myClosureOptimized</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> createClosureOptimized</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">();</span></span></code></pre></div></li></ul><h3 id="e-map-set-中的对象引用" tabindex="-1">e. Map/Set 中的对象引用 <a class="header-anchor" href="#e-map-set-中的对象引用" aria-label="Permalink to &quot;e. Map/Set 中的对象引用&quot;">​</a></h3><ul><li><strong>原因</strong>：当使用 <code>Map</code> 或 <code>Set</code> 存储对象时，如果这些对象在外部已经不再需要，但没有从 <code>Map</code>/<code>Set</code> 中显式地移除，那么 <code>Map</code>/<code>Set</code> 就会一直持有对这些对象的<strong>强引用</strong>，阻止它们被 GC 回收。</li><li><strong>示例</strong>：<div class="language-javascript vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> elementMap</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> new</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Map</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">();</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">function</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> watchElement</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">element</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  elementMap.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">set</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(element, { isWatched: </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">true</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> });</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">let</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> myElement </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> document.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">getElementById</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;my-element&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">watchElement</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(myElement);</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 稍后，DOM 节点从页面移除了</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">myElement.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">remove</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">();</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">myElement </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> null</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 此时，虽然 myElement 变量被清空，但 elementMap 依然持有对</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 那个 DOM 节点的引用，导致它和它的所有子节点都无法被回收。</span></span></code></pre></div></li><li><strong>如何避免（最佳实践）</strong>：使用 <strong><code>WeakMap</code></strong> 或 <strong><code>WeakSet</code></strong>。它们的键（对于 <code>WeakMap</code>）或值（对于 <code>WeakSet</code>）是<strong>弱引用</strong>的。这意味着，如果一个对象只被 <code>WeakMap</code>/<code>WeakSet</code> 所引用，那么 GC 会自动忽略这个引用并回收该对象，相应的条目也会从集合中自动消失。</li></ul><h2 id="_2-使用-devtools-memory-面板进行调试" tabindex="-1">2. 使用 DevTools Memory 面板进行调试 <a class="header-anchor" href="#_2-使用-devtools-memory-面板进行调试" aria-label="Permalink to &quot;2. 使用 DevTools Memory 面板进行调试&quot;">​</a></h2><p>Chrome DevTools 的 <code>Memory</code> 面板是定位内存泄漏的终极武器。它主要提供了三种工具：</p><ul><li><strong>Heap snapshot (堆快照)</strong>：这是定位内存泄漏最核心、最强大的工具。它能拍下某一时刻堆内存的完整视图，用于分析对象之间的引用关系。</li><li><strong>Allocation instrumentation on timeline (时间线上的分配检测)</strong>：这个工具可以记录下随时间发生的内存分配和释放活动。它非常适合用来定位那些因<strong>频繁创建和销毁临时对象</strong>而导致 GC 压力过大、引发页面卡顿的问题。</li><li><strong>Allocation sampling (分配采样)</strong>：这是一个开销较低的内存分析工具，它通过采样的方式来持续监控内存分配。它适合用来排查那些持续时间长、泄漏缓慢的问题。</li></ul><p>对于典型的内存泄漏问题，我们主要使用<strong>堆快照</strong>。</p><h3 id="调试流程" tabindex="-1">调试流程 <a class="header-anchor" href="#调试流程" aria-label="Permalink to &quot;调试流程&quot;">​</a></h3><ol><li><p><strong>打开页面并执行操作</strong>：</p><ul><li>以无痕模式打开你的页面，以避免插件干扰。</li><li>执行一系列你怀疑可能导致内存泄漏的操作。例如，反复打开和关闭一个弹窗组件。</li></ul></li><li><p><strong>拍摄第一个堆快照 (Baseline)</strong>：</p><ul><li>打开 DevTools → <code>Memory</code> 面板。</li><li>选择 <code>Heap snapshot</code>。</li><li>点击 <code>Take snapshot</code> 按钮。这将拍下当前时刻堆内存中所有对象的状态。</li></ul></li><li><p><strong>再次执行操作</strong>：</p><ul><li>回到页面，<strong>重复</strong>第一步中的操作。确保执行的次数和方式与第一次完全一致。</li></ul></li><li><p><strong>手动触发垃圾回收</strong>：</p><ul><li>在 <code>Memory</code> 面板中，点击左上角的<strong>垃圾桶图标 (Collect garbage)</strong>。这一步非常重要，它可以强制浏览器执行一次垃圾回收，清除那些可以被正常回收的内存，只留下真正“泄漏”的对象。</li></ul></li><li><p><strong>拍摄第二个堆快照</strong>：</p><ul><li>再次点击 <code>Take snapshot</code> 按钮。</li></ul></li><li><p><strong>对比两次快照</strong>：</p><ul><li>在快照列表中，选择第二次拍摄的快照。</li><li>在快照视图上方的下拉菜单中，选择 <strong><code>Comparison</code></strong> 模式，并将对比目标设置为第一个快照 (<code>Snapshot 1</code>)。</li><li>点击 <strong><code>Retainers</code></strong> 视图。</li></ul></li></ol><h3 id="如何分析对比结果" tabindex="-1">如何分析对比结果 <a class="header-anchor" href="#如何分析对比结果" aria-label="Permalink to &quot;如何分析对比结果&quot;">​</a></h3><ul><li><strong><code>Comparison</code> 视图</strong>：这个视图会显示两次快照之间，对象数量的变化。 <ul><li><strong><code># New</code></strong>: 在快照1之后、快照2之前新分配的对象数量。</li><li><strong><code># Delta</code></strong>: 对象的净增减数量。<strong>我们主要关注 <code># Delta</code> 为正值的对象</strong>，特别是那些我们预期在操作结束后应该被销毁的对象（例如组件实例）。</li></ul></li><li><strong><code>Retainers</code> 视图（支配树）</strong>： <ul><li>在 <code>Comparison</code> 视图中，找到一个你怀疑是泄漏了的对象（例如，某个组件的构造函数名，如 <code>MyComponent</code>）。</li><li>点击展开它，你会在下方的 <strong><code>Retainers</code></strong> 视图中看到一个<strong>引用链</strong>。这个链展示了<strong>为什么这个对象无法被垃圾回收</strong>——即它被谁直接或间接地引用着。</li><li>从你的目标对象开始，向上追溯这条引用链，直到找到一个你熟悉的代码对象（例如一个全局变量、一个事件监听器、一个定时器回调）。这个“源头”通常就是导致内存泄漏的根本原因。</li><li><strong>红色</strong>的条目通常表示“分离的 DOM 树”，是排查的重点。</li></ul></li></ul><p>通过这套“<strong>操作 → 快照 → 重复操作 → GC → 快照 → 对比</strong>”的流程，我们就可以精准地定位到那些在操作结束后未能被成功回收的对象，并通过分析其引用链找到问题的根源。</p>`,24)])])}const o=i(t,[["render",h]]);export{g as __pageData,o as default};
