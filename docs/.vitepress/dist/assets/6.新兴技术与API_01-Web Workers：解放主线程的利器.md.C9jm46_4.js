import{_ as i,c as a,o as e,ae as n}from"./chunks/framework.DK_uz7nx.js";const g=JSON.parse('{"title":"15-Web Workers：解放主线程的利器","description":"","frontmatter":{},"headers":[],"relativePath":"6.新兴技术与API/01-Web Workers：解放主线程的利器.md","filePath":"6.新兴技术与API/01-Web Workers：解放主线程的利器.md"}'),t={name:"6.新兴技术与API/01-Web Workers：解放主线程的利器.md"};function l(k,s,h,r,p,o){return e(),a("div",null,[...s[0]||(s[0]=[n(`<h1 id="_15-web-workers-解放主线程的利器" tabindex="-1">15-Web Workers：解放主线程的利器 <a class="header-anchor" href="#_15-web-workers-解放主线程的利器" aria-label="Permalink to &quot;15-Web Workers：解放主线程的利器&quot;">​</a></h1><p>我们在前面的章节中反复强调，JavaScript 是单线程的，长时间的同步代码会阻塞主线程，导致 UI 卡死。事件循环机制通过异步任务有效地解决了 <strong>I/O 密集型</strong>任务的阻塞问题，但它并不能解决 <strong>CPU 密集型</strong>任务带来的挑战。</p><h2 id="_1-为什么需要-web-worker-事件循环的局限" tabindex="-1">1. 为什么需要 Web Worker？事件循环的局限 <a class="header-anchor" href="#_1-为什么需要-web-worker-事件循环的局限" aria-label="Permalink to &quot;1. 为什么需要 Web Worker？事件循环的局限&quot;">​</a></h2><ul><li><p><strong>I/O 密集型任务 (I/O-Bound)</strong></p><ul><li><strong>特点</strong>：任务的大部分时间都在等待外部资源（如网络响应、磁盘读写），CPU 处于空闲状态。</li><li><strong>事件循环如何解决</strong>：通过异步回调，JS 主线程可以将 I/O 操作交给浏览器的其他线程处理，自己则继续响应用户交互和 UI 渲染，等 I/O 操作完成后再通过任务队列执行回调。</li></ul></li><li><p><strong>CPU 密集型任务 (CPU-Bound)</strong></p><ul><li><strong>特点</strong>：任务需要持续占用 CPU 进行大量的计算（如复杂的数学运算、图像处理、数据加解密等）。</li><li><strong>事件循环的无力</strong>：这类任务会持续霸占 JS 主线程的调用栈，直到计算完成。即使你把它放进 <code>setTimeout</code>，当它开始执行时，依然会冻结整个页面。</li></ul></li></ul><p>为了解决 CPU 密集型任务的阻塞问题，<strong>Web Worker</strong> 应运而生。它允许我们在<strong>后台线程</strong>中执行 JavaScript，这个线程完全独立于主线程，因此可以在不影响页面响应性的前提下处理耗时的计算任务。</p><h2 id="_2-web-worker-基础" tabindex="-1">2. Web Worker 基础 <a class="header-anchor" href="#_2-web-worker-基础" aria-label="Permalink to &quot;2. Web Worker 基础&quot;">​</a></h2><p>Web Worker 的核心思想是<strong>让主线程专注于 UI 交互，而将复杂的计算任务交给 Worker 线程</strong>。</p><h3 id="a-创建与启动-worker" tabindex="-1">a. 创建与启动 Worker <a class="header-anchor" href="#a-创建与启动-worker" aria-label="Permalink to &quot;a. 创建与启动 Worker&quot;">​</a></h3><p>创建一个 Worker 非常简单，只需提供一个独立的 JS 文件的路径即可：</p><div class="language-javascript vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// main.js (主线程)</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> myWorker</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> new</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Worker</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;worker.js&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span></code></pre></div><p><code>new Worker()</code> 的调用会创建一个新的操作系统级别的线程，并开始异步下载和执行 <code>worker.js</code> 文件中的代码。</p><blockquote><p><strong>现代化用法：模块化 Worker</strong> 现代浏览器允许我们创建模块化的 Worker，这使得我们可以在 Worker 脚本中使用 <code>import</code>/<code>export</code> 语法，更好地与现代前端工程化集成。</p><div class="language-javascript vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// main.js</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> myModuleWorker</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> new</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Worker</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;worker-module.js&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, { type: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;module&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> });</span></span></code></pre></div></blockquote><h3 id="b-主线程与-worker-线程的通信" tabindex="-1">b. 主线程与 Worker 线程的通信 <a class="header-anchor" href="#b-主线程与-worker-线程的通信" aria-label="Permalink to &quot;b. 主线程与 Worker 线程的通信&quot;">​</a></h3><p>主线程和 Worker 线程是完全隔离的，它们存在于不同的全局上下文中（Worker 中没有 <code>window</code> 和 <code>document</code> 对象）。它们之间唯一的通信方式是通过一个类似事件监听的机制：<code>postMessage()</code> 和 <code>onmessage</code> 事件。</p><p><strong>从主线程向 Worker 发送消息：</strong></p><div class="language-javascript vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// main.js (主线程)</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> myWorker</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> new</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Worker</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;worker.js&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 发送一个简单的字符串</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">myWorker.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">postMessage</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;Hello, Worker!&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 发送一个对象</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">myWorker.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">postMessage</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">({ command: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;start&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, data: [</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">2</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">3</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">] });</span></span></code></pre></div><p><strong>在 Worker 线程中接收并响应消息：</strong></p><div class="language-javascript vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// worker.js (Worker 线程)</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 监听来自主线程的消息</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">self.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">onmessage</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> function</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">event</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  console.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">log</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;Message received from main script:&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, event.data);</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">  // 进行一些耗时的计算</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> result</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> processData</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(event.data);</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">  // 将计算结果发送回主线程</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  self.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">postMessage</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(result);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">};</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 也可以使用 addEventListener</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// self.addEventListener(&#39;message&#39;, function(event) { ... });</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">function</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> processData</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">data</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">  // 模拟一个耗时的 CPU 密集型任务</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  let</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> sum </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  for</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">let</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> i </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">; i </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&lt;</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 1000000000</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">; i</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">++</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    sum </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">+=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> i;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  }</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  return</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> \`Processed data: \${</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">data</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">}, Result: \${</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">sum</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">}\`</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><p><strong>在主线程中接收来自 Worker 的消息：</strong></p><div class="language-javascript vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// main.js (主线程)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">myWorker.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">onmessage</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> function</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">event</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  console.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">log</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;Message received from worker:&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, event.data);</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">  // 在这里可以用 worker 返回的结果来更新 UI</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  document.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">getElementById</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;result&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">).textContent </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> event.data;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">};</span></span></code></pre></div><h3 id="c-终止-worker" tabindex="-1">c. 终止 Worker <a class="header-anchor" href="#c-终止-worker" aria-label="Permalink to &quot;c. 终止 Worker&quot;">​</a></h3><p>当不再需要 Worker 时，为了释放内存和系统资源，我们应该终止它。</p><ul><li><strong>从主线程终止</strong>：<div class="language-javascript vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">myWorker.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">terminate</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">();</span></span></code></pre></div></li><li><strong>从 Worker 内部自我终止</strong>：<div class="language-javascript vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// worker.js</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">self.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">close</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">();</span></span></code></pre></div></li></ul><h3 id="d-错误处理" tabindex="-1">d. 错误处理 <a class="header-anchor" href="#d-错误处理" aria-label="Permalink to &quot;d. 错误处理&quot;">​</a></h3><p>健壮的代码需要完善的错误处理机制。</p><ul><li><strong>在主线程中捕获错误</strong>：可以通过监听 Worker 实例的 <code>error</code> 事件来捕获 Worker 脚本中未被捕获的异常。<div class="language-javascript vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">myWorker.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">onerror</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> function</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">event</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  console.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">error</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;Error in worker:&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, event.message, </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;at&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, event.filename, </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;:&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, event.lineno);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">};</span></span></code></pre></div></li><li><strong>在 Worker 内部处理错误</strong>：在 Worker 内部，同样可以使用 <code>try...catch</code> 来捕获和处理错误，并通过 <code>postMessage</code> 将结构化的错误信息发送回主线程。</li></ul><h2 id="_3-worker-的类型-dedicated-vs-shared" tabindex="-1">3. Worker 的类型：Dedicated vs Shared <a class="header-anchor" href="#_3-worker-的类型-dedicated-vs-shared" aria-label="Permalink to &quot;3. Worker 的类型：Dedicated vs Shared&quot;">​</a></h2><p>我们上面讨论的 <code>Worker</code>，在规范中被称为 <strong>Dedicated Worker</strong>（专用 Worker），它的特点是<strong>只服务于创建它的那一个页面上下文</strong>。除此之外，Web Worker API 还提供了另一种类型：<code>SharedWorker</code>。</p><ul><li><strong><code>SharedWorker</code> (共享 Worker)</strong>： <ul><li><strong>特点</strong>：一个 <code>SharedWorker</code> 实例可以被<strong>多个同源的浏览上下文</strong>（如多个标签页、<code>iframe</code>）所共享和访问。</li><li><strong>用途</strong>：非常适合实现<strong>跨标签页的状态同步或通信</strong>，例如多页面应用的“消息总线”或“数据同步中心”。</li><li><strong>通信差异</strong>：与 <code>SharedWorker</code> 的通信需要通过其 <code>port</code> 对象进行。每个连接到 <code>SharedWorker</code> 的页面都会创建一个独立的端口（port）。<div class="language-javascript vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// main.js - 连接到一个 SharedWorker</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> mySharedWorker</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> new</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> SharedWorker</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;shared-worker.js&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">mySharedWorker.port.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">start</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(); </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 必须启动端口</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">mySharedWorker.port.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">postMessage</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;Hello from a page!&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span></code></pre></div></li></ul></li></ul><h2 id="_4-worker-的能力与限制" tabindex="-1">4. Worker 的能力与限制 <a class="header-anchor" href="#_4-worker-的能力与限制" aria-label="Permalink to &quot;4. Worker 的能力与限制&quot;">​</a></h2><h3 id="a-worker-可以做什么" tabindex="-1">a. Worker 可以做什么？ <a class="header-anchor" href="#a-worker-可以做什么" aria-label="Permalink to &quot;a. Worker 可以做什么？&quot;">​</a></h3><ul><li>执行任意复杂的 JavaScript 计算。</li><li>使用 <code>setTimeout</code> 和 <code>setInterval</code>。</li><li>访问 <code>navigator</code> 对象的大部分属性（如 <code>userAgent</code>, <code>geolocation</code>）。</li><li>发起网络请求（<code>XMLHttpRequest</code>, <code>fetch</code>）。</li><li>创建新的 Worker（子 Worker）。</li><li>使用 <code>IndexedDB</code> 进行数据存储。</li></ul><h3 id="b-worker-不能做什么" tabindex="-1">b. Worker 不能做什么？ <a class="header-anchor" href="#b-worker-不能做什么" aria-label="Permalink to &quot;b. Worker 不能做什么？&quot;">​</a></h3><ul><li><strong>无法直接访问 DOM</strong>：这是最重要的限制。因为 Worker 运行在与主线程不同的线程中，直接操作 DOM 会引发竞态条件。所有 UI 更新都必须通过 <code>postMessage</code> 通知主线程来完成。</li><li><strong>无法访问 <code>window</code> 和 <code>document</code> 对象</strong>。</li><li><strong>无法访问 <code>parent</code> 对象</strong>。</li></ul><h2 id="_5-数据传输-结构化克隆算法" tabindex="-1">5. 数据传输：结构化克隆算法 <a class="header-anchor" href="#_5-数据传输-结构化克隆算法" aria-label="Permalink to &quot;5. 数据传输：结构化克隆算法&quot;">​</a></h2><p>主线程和 Worker 之间通过 <code>postMessage</code> 传递数据时，并不是共享内存，而是<strong>复制数据</strong>。这个复制过程使用的是<strong>结构化克隆算法（Structured Clone Algorithm）</strong>。</p><ul><li><strong>优点</strong>：可以复制大多数复杂的 JavaScript 对象，包括 <code>Object</code>, <code>Array</code>, <code>Date</code>, <code>RegExp</code>，甚至 <code>File</code>, <code>Blob</code>, <code>ArrayBuffer</code> 等，解决了 <code>JSON.stringify</code> 无法处理循环引用和特定类型的问题。</li><li><strong>缺点</strong>：每次通信都涉及数据的复制，如果数据量巨大，可能会产生显著的性能开销。</li></ul><p>为了解决大数据传输的性能问题，Worker 提供了<strong>可转移对象（Transferable Objects）</strong> 的概念。通过它，可以实现内存的<strong>所有权转移</strong>，而不是复制。例如，在传输一个 <code>ArrayBuffer</code> 时，主线程会失去对它的控制权，将其所有权直接转移给 Worker，这是一个近乎瞬时的操作。</p><div class="language-javascript vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// main.js</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> buffer</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> new</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> ArrayBuffer</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1024</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">myWorker.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">postMessage</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(buffer, [buffer]); </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 第二个参数指定要转移的对象</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 此时，主线程中的 buffer 变量将无法再被访问</span></span></code></pre></div><h2 id="_6-典型应用场景" tabindex="-1">6. 典型应用场景 <a class="header-anchor" href="#_6-典型应用场景" aria-label="Permalink to &quot;6. 典型应用场景&quot;">​</a></h2><ul><li><strong>大规模数据处理</strong>：在前端解析和处理大型文件（如 CSV, JSON）、进行数据分析等。</li><li><strong>复杂科学计算</strong>：如图形学计算、物理模拟、生物信息学分析等。</li><li><strong>图像、音频、视频处理</strong>：在后台线程中对多媒体数据进行滤镜、编码解码、分析等操作。</li><li><strong>预取和缓存</strong>：在后台提前请求和缓存应用所需的数据，提升用户体验。</li><li><strong>后台同步</strong>：通过 Service Worker（一种特殊的 Worker）实现离线数据同步。</li></ul>`,41)])])}const E=i(t,[["render",l]]);export{g as __pageData,E as default};
