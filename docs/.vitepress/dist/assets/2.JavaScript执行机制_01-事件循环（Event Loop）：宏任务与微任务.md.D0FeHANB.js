import{_ as i,c as a,o as n,ae as t}from"./chunks/framework.DK_uz7nx.js";const d=JSON.parse('{"title":"04-事件循环（Event Loop）：宏任务与微任务","description":"","frontmatter":{},"headers":[],"relativePath":"2.JavaScript执行机制/01-事件循环（Event Loop）：宏任务与微任务.md","filePath":"2.JavaScript执行机制/01-事件循环（Event Loop）：宏任务与微任务.md"}'),l={name:"2.JavaScript执行机制/01-事件循环（Event Loop）：宏任务与微任务.md"};function e(h,s,p,k,o,r){return n(),a("div",null,[...s[0]||(s[0]=[t(`<h1 id="_04-事件循环-event-loop-宏任务与微任务" tabindex="-1">04-事件循环（Event Loop）：宏任务与微任务 <a class="header-anchor" href="#_04-事件循环-event-loop-宏任务与微任务" aria-label="Permalink to &quot;04-事件循环（Event Loop）：宏任务与微任务&quot;">​</a></h1><p>事件循环（Event Loop）是 JavaScript 解决单线程运行阻塞问题的核心机制，也是其异步编程模型的基石。要理解事件循环，我们首先需要了解几个关键的概念：调用栈、任务队列和事件循环本身的工作流程。</p><h2 id="_1-核心组件" tabindex="-1">1. 核心组件 <a class="header-anchor" href="#_1-核心组件" aria-label="Permalink to &quot;1. 核心组件&quot;">​</a></h2><h3 id="a-调用栈-call-stack" tabindex="-1">a. 调用栈 (Call Stack) <a class="header-anchor" href="#a-调用栈-call-stack" aria-label="Permalink to &quot;a. 调用栈 (Call Stack)&quot;">​</a></h3><p>JavaScript 是一门单线程语言，这意味着它只有一个<strong>调用栈</strong>。调用栈是一个后进先出（LIFO）的数据结构，用于存储和管理函数调用。</p><ul><li>当一个函数被调用时，它会被推入（push）到调用栈的顶部。</li><li>当函数执行完毕并返回时，它会从调用栈的顶部被弹出（pop）。</li><li>所有同步代码都会在调用栈中依次执行。</li></ul><div class="language-javascript vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">function</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> third</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  console.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">log</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;Third&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">function</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> second</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() {</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">  third</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">();</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">function</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> first</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() {</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">  second</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">();</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">first</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">();</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 调用栈变化过程:</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 1. first() 入栈</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 2. second() 入栈</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 3. third() 入栈</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 4. third() 执行完毕, 出栈</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 5. second() 执行完毕, 出栈</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 6. first() 执行完毕, 出栈</span></span></code></pre></div><h3 id="b-web-apis" tabindex="-1">b. Web APIs <a class="header-anchor" href="#b-web-apis" aria-label="Permalink to &quot;b. Web APIs&quot;">​</a></h3><p>对于异步操作，例如 <code>setTimeout</code>, <code>fetch</code> 请求或 DOM 事件监听，JS 引擎并不会自己处理。它会将这些任务交给<strong>浏览器</strong>提供的相应模块（Web APIs），例如定时器模块、网络模块等。这些模块通常在单独的线程中运行，因此不会阻塞 JS 主线程。</p><h3 id="c-任务队列-task-queue-callback-queue" tabindex="-1">c. 任务队列 (Task Queue / Callback Queue) <a class="header-anchor" href="#c-任务队列-task-queue-callback-queue" aria-label="Permalink to &quot;c. 任务队列 (Task Queue / Callback Queue)&quot;">​</a></h3><p>当 Web API 完成了它的任务（比如定时器时间到了，或者网络请求收到了响应），它并不会直接将结果返回给 JS 主线程，而是将需要执行的<strong>回调函数</strong>放入一个<strong>任务队列</strong>中。</p><p>任务队列是一个先进先出（FIFO）的数据结构，它存放着所有待处理的异步任务。</p><h2 id="_2-宏任务-macrotask-与-微任务-microtask" tabindex="-1">2. 宏任务 (Macrotask) 与 微任务 (Microtask) <a class="header-anchor" href="#_2-宏任务-macrotask-与-微任务-microtask" aria-label="Permalink to &quot;2. 宏任务 (Macrotask) 与 微任务 (Microtask)&quot;">​</a></h2><p>任务队列并非只有一个。根据任务类型的不同，它被分为两种：</p><h3 id="a-宏任务队列-macrotask-queue" tabindex="-1">a. 宏任务队列 (Macrotask Queue) <a class="header-anchor" href="#a-宏任务队列-macrotask-queue" aria-label="Permalink to &quot;a. 宏任务队列 (Macrotask Queue)&quot;">​</a></h3><ul><li><strong>定义</strong>：宏任务通常代表一个独立的、离散的工作单元。</li><li><strong>常见的宏任务</strong>： <ul><li><code>setTimeout</code>, <code>setInterval</code></li><li><code>script</code> (整体代码块)</li><li>I/O 操作（如网络请求 <code>fetch</code> 的回调）</li><li>UI 渲染（在某些标准中被视为宏任务）</li><li>DOM 事件监听回调</li></ul></li></ul><h3 id="b-微任务队列-microtask-queue" tabindex="-1">b. 微任务队列 (Microtask Queue) <a class="header-anchor" href="#b-微任务队列-microtask-queue" aria-label="Permalink to &quot;b. 微任务队列 (Microtask Queue)&quot;">​</a></h3><ul><li><strong>定义</strong>：微任务通常是需要在<strong>当前任务执行之后、下一个宏任务开始之前</strong>立即执行的短小任务。它们通常用于处理 <code>Promise</code> 的决议或执行一些需要在 DOM 更新前完成的清理工作。</li><li><strong>常见的微任务</strong>： <ul><li><code>Promise.then()</code>, <code>Promise.catch()</code>, <code>Promise.finally()</code></li><li><code>async/await</code>（<code>await</code> 后面的代码本质上是 <code>Promise.then</code> 的语法糖）</li><li><code>MutationObserver</code></li><li><code>queueMicrotask()</code></li></ul></li></ul><h3 id="c-深入-async-await" tabindex="-1">c. 深入 async/await <a class="header-anchor" href="#c-深入-async-await" aria-label="Permalink to &quot;c. 深入 async/await&quot;">​</a></h3><p><code>async/await</code> 让我们能用同步的方式写异步代码，但其本质依然是基于 <code>Promise</code> 和微任务。<code>await</code> 关键字会暂停 <code>async</code> 函数的执行，它后面的所有代码都可以看作是被包裹在一个 <code>.then()</code> 的回调中。</p><p>看一个例子：</p><div class="language-javascript vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">async</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> function</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> asyncFunc</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  console.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">log</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;asyncFunc start&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">); </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 2</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  await</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> someAsyncOperation</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(); </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// Promise会立即执行，然后暂停</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  console.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">log</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;asyncFunc end&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">); </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 5 (这部分进入微任务)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">function</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> someAsyncOperation</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  console.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">log</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;someAsyncOperation&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">); </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 3</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  return</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> Promise</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">resolve</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">();</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">console.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">log</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;script start&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">); </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 1</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">asyncFunc</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">();</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">console.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">log</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;script end&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">); </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 4</span></span></code></pre></div><p><strong>上述 <code>asyncFunc</code> 的执行可以理解为：</strong></p><div class="language-javascript vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">function</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> asyncFunc</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  console.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">log</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;asyncFunc start&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">  someAsyncOperation</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">().</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">then</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">function</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    console.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">log</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;asyncFunc end&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  });</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><p>因此，<code>&#39;asyncFunc end&#39;</code> 会作为微任务，在当前脚本的所有同步代码执行完毕后才执行。最终输出顺序为：<code>script start</code> -&gt; <code>asyncFunc start</code> -&gt; <code>someAsyncOperation</code> -&gt; <code>script end</code> -&gt; <code>asyncFunc end</code>。</p><h2 id="_3-事件循环-event-loop-的工作流程" tabindex="-1">3. 事件循环 (Event Loop) 的工作流程 <a class="header-anchor" href="#_3-事件循环-event-loop-的工作流程" aria-label="Permalink to &quot;3. 事件循环 (Event Loop) 的工作流程&quot;">​</a></h2><p>事件循环是一个持续不断的过程，它的基本工作就是反复检查调用栈和任务队列，并根据规则移动函数以供执行。</p><p>其核心算法可以描述如下：</p><ol><li><strong>执行一个宏任务</strong>：从宏任务队列中取出一个最旧的任务来执行。在第一次加载页面时，这个任务就是全局的 <code>&lt;script&gt;</code> 代码块。</li><li><strong>检查调用栈</strong>：执行该宏任务中的所有同步代码，直到调用栈为空。</li><li><strong>执行所有微任务</strong>：检查微任务队列。只要微任务队列不为空，就循环地取出队列头部的微任务来执行，直到<strong>整个微任务队列被清空</strong>。 <ul><li><strong>注意</strong>：如果在执行微任务的过程中，又产生了新的微任务，那么这些新的微任务也会被添加到队列的末尾，并在这个阶段被立即执行。</li></ul></li><li><strong>UI 渲染 (可选)</strong>：在执行完所有微任务后，浏览器可能会进行一次 UI 渲染（重绘/回流）。这个步骤不是每次事件循环都发生，而是由浏览器根据性能和时机来决定。</li><li><strong>返回步骤 1</strong>：结束当前的循环，回到步骤 1，准备从宏任务队列中取出下一个任务，开始新的循环。</li></ol><p>这个 &quot;取一个宏任务 -&gt; 执行所有微任务 -&gt; (可能)渲染&quot; 的过程，就是一次事件循环的 &quot;tick&quot;。</p><h2 id="_4-示例分析" tabindex="-1">4. 示例分析 <a class="header-anchor" href="#_4-示例分析" aria-label="Permalink to &quot;4. 示例分析&quot;">​</a></h2><p>让我们通过一个经典的例子来理解这个流程：</p><div class="language-javascript vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">console.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">log</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;script start&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">); </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 1</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">setTimeout</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">function</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  console.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">log</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;setTimeout&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">); </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 5</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Promise</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">resolve</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">().</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">then</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">function</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  console.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">log</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;promise1&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">); </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 3</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}).</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">then</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">function</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  console.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">log</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;promise2&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">); </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 4</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">});</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">console.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">log</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;script end&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">); </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 2</span></span></code></pre></div><p><strong>执行过程分析</strong>：</p><ol><li><p><strong>宏任务 #1 (script)</strong>:</p><ul><li><code>console.log(&#39;script start&#39;)</code> 被执行，输出 &quot;script start&quot;。</li><li>遇到 <code>setTimeout</code>，将其回调函数注册为一个新的<strong>宏任务</strong>，放入宏任务队列。</li><li>遇到 <code>Promise.resolve().then()</code>，第一个 <code>.then</code> 的回调被注册为一个<strong>微任务</strong>，放入微任务队列。</li><li><code>console.log(&#39;script end&#39;)</code> 被执行，输出 &quot;script end&quot;。</li><li>至此，第一个宏任务（全局脚本）中的同步代码执行完毕。</li></ul></li><li><p><strong>执行微任务</strong>:</p><ul><li>事件循环检查微任务队列，发现不为空。</li><li>取出第一个微任务 (<code>promise1</code> 的回调) 并执行，输出 &quot;promise1&quot;。</li><li>执行过程中，<code>promise1</code> 返回 <code>undefined</code>，并触发了链式调用的第二个 <code>.then</code>，因此一个新的微任务 (<code>promise2</code> 的回调) 被放入微任务队列。</li><li>事件循环再次检查微任务队列，发现仍然不为空。</li><li>取出第二个微任务 (<code>promise2</code> 的回调) 并执行，输出 &quot;promise2&quot;。</li><li>微任务队列现在为空。</li></ul></li><li><p><strong>(可选) UI 渲染</strong>: 浏览器可能会在此时进行渲染。</p></li><li><p><strong>宏任务 #2 (setTimeout)</strong>:</p><ul><li>事件循环从宏任务队列中取出 <code>setTimeout</code> 的回调任务。</li><li>执行该任务，输出 &quot;setTimeout&quot;。</li></ul></li></ol><p><strong>最终输出顺序</strong>: <code>script start</code> -&gt; <code>script end</code> -&gt; <code>promise1</code> -&gt; <code>promise2</code> -&gt; <code>setTimeout</code>。</p><h2 id="_5-综合示例分析" tabindex="-1">5. 综合示例分析 <a class="header-anchor" href="#_5-综合示例分析" aria-label="Permalink to &quot;5. 综合示例分析&quot;">​</a></h2><p>让我们来看一个更复杂的例子，它包含了微任务中创建宏任务，以及宏任务中创建微任务的场景。</p><div class="language-javascript vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">setTimeout</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">function</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  console.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">log</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;setTimeout1&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">  Promise</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">resolve</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">().</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">then</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">function</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    console.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">log</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;promise3&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  });</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">setTimeout</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">function</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  console.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">log</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;setTimeout2&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Promise</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">resolve</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">().</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">then</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">function</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  console.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">log</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;promise1&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">  setTimeout</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">function</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    console.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">log</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;setTimeout3 from promise1&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  }, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}).</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">then</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">function</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  console.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">log</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;promise2&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">});</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">console.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">log</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;script start&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span></code></pre></div><p><strong>执行过程分析</strong>：</p><ol><li><p><strong>宏任务 #1 (script)</strong>:</p><ul><li>遇到 <code>setTimeout1</code>，其回调被注册为<strong>宏任务 #2</strong>。</li><li>遇到 <code>setTimeout2</code>，其回调被注册为<strong>宏任务 #3</strong>。</li><li>遇到 <code>Promise.resolve().then()</code>，<code>promise1</code> 的回调被注册为<strong>微任务</strong>。</li><li><code>console.log(&#39;script start&#39;)</code> 被执行。</li><li>同步代码执行完毕。</li></ul></li><li><p><strong>执行微任务</strong>:</p><ul><li>执行 <code>promise1</code> 的回调，输出 &quot;promise1&quot;。</li><li>在执行过程中，遇到 <code>setTimeout3</code>，其回调被注册为<strong>宏任务 #4</strong>。</li><li><code>promise1</code> 的回调返回，触发链式调用，<code>promise2</code> 的回调被注册为<strong>微任务</strong>。</li><li>微任务队列还不为空，继续执行 <code>promise2</code> 的回调，输出 &quot;promise2&quot;。</li><li>微任务队列清空。</li></ul></li><li><p><strong>宏任务 #2 (setTimeout1)</strong>:</p><ul><li>执行 <code>setTimeout1</code> 的回调，输出 &quot;setTimeout1&quot;。</li><li>遇到 <code>Promise.resolve().then()</code>，<code>promise3</code> 的回调被注册为<strong>微任务</strong>。</li><li><code>setTimeout1</code> 的同步代码执行完毕。</li></ul></li><li><p><strong>执行微任务</strong>:</p><ul><li>执行 <code>promise3</code> 的回调，输出 &quot;promise3&quot;。</li><li>微任务队列清空。</li></ul></li><li><p><strong>宏任务 #3 (setTimeout2)</strong>:</p><ul><li>执行 <code>setTimeout2</code> 的回调，输出 &quot;setTimeout2&quot;。</li></ul></li><li><p><strong>宏任务 #4 (setTimeout3)</strong>:</p><ul><li>执行 <code>setTimeout3</code> 的回调，输出 &quot;setTimeout3 from promise1&quot;。</li></ul></li></ol><p><strong>最终输出顺序</strong>: <code>script start</code> -&gt; <code>promise1</code> -&gt; <code>promise2</code> -&gt; <code>setTimeout1</code> -&gt; <code>promise3</code> -&gt; <code>setTimeout2</code> -&gt; <code>setTimeout3 from promise1</code>。</p><h2 id="_6-与-node-js-事件循环的简要对比" tabindex="-1">6. 与 Node.js 事件循环的简要对比 <a class="header-anchor" href="#_6-与-node-js-事件循环的简要对比" aria-label="Permalink to &quot;6. 与 Node.js 事件循环的简要对比&quot;">​</a></h2><p>虽然本指南主要关注浏览器，但了解 Node.js 事件循环的差异有助于形成更完整的知识体系。</p><ul><li><strong>模型差异</strong>：旧版 Node.js (v10及之前) 的事件循环分为多个阶段 (timers, I/O, poll, check等)。其主要特点是：<strong>微任务会在每个阶段结束后执行</strong>，而不是像浏览器一样在单个宏任务执行完后就立即清空。</li><li><strong>趋于统一</strong>：<strong>新版 Node.js (v11及之后) 的事件循环机制已基本与浏览器保持一致</strong>。即在一个宏任务（如 timer 回调或 I/O 回调）执行完毕后，会立刻清空微任务队列。</li></ul><p>因此，对于现代 Node.js 开发而言，你可以放心地将在浏览器中学到的事件循环模型应用其中。</p>`,46)])])}const c=i(l,[["render",e]]);export{d as __pageData,c as default};
