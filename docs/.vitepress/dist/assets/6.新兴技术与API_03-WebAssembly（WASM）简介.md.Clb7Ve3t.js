import{_ as a,c as i,o as t,ae as n}from"./chunks/framework.DK_uz7nx.js";const c=JSON.parse('{"title":"17-WebAssembly (WASM) 简介","description":"","frontmatter":{},"headers":[],"relativePath":"6.新兴技术与API/03-WebAssembly（WASM）简介.md","filePath":"6.新兴技术与API/03-WebAssembly（WASM）简介.md"}'),e={name:"6.新兴技术与API/03-WebAssembly（WASM）简介.md"};function l(r,s,p,h,o,k){return t(),i("div",null,[...s[0]||(s[0]=[n(`<h1 id="_17-webassembly-wasm-简介" tabindex="-1">17-WebAssembly (WASM) 简介 <a class="header-anchor" href="#_17-webassembly-wasm-简介" aria-label="Permalink to &quot;17-WebAssembly (WASM) 简介&quot;">​</a></h1><p>WebAssembly (简称 Wasm) 是一种新兴的、开放的 Web 标准。它为 Web 浏览器定义了一种<strong>可移植的、体积小、加载快</strong>的<strong>二进制指令格式</strong>，旨在成为 Web 平台的高性能编译目标。</p><p>简单来说，WebAssembly 就是一种可以让 C, C++, Rust 等高性能语言编写的代码，以接近原生的速度在浏览器中运行的技术。</p><h2 id="_1-webassembly-不是要取代-javascript" tabindex="-1">1. WebAssembly 不是要取代 JavaScript <a class="header-anchor" href="#_1-webassembly-不是要取代-javascript" aria-label="Permalink to &quot;1. WebAssembly 不是要取代 JavaScript&quot;">​</a></h2><p>这是一个非常重要的核心概念：<strong>Wasm 并非 JavaScript 的替代品，而是其强大的伙伴。</strong></p><ul><li><strong>JavaScript</strong> 非常灵活、动态，拥有庞大的生态系统，非常适合用于处理 Web 应用的<strong>业务逻辑、DOM 操作、事件处理</strong>等“胶水层”的工作。</li><li><strong>WebAssembly</strong> 则专注于<strong>性能和计算密集型任务</strong>。它提供了一个类似于汇编的底层指令集，让那些对性能要求极高的模块（如游戏引擎、音视频处理、科学计算）可以发挥出接近原生的速度。</li></ul><p>两者的关系是<strong>互补</strong>的：JavaScript 负责应用的整体控制和与 Web API 的交互，当遇到性能瓶颈的计算任务时，就调用 Wasm 模块来高效地完成。</p><h2 id="_2-核心特性" tabindex="-1">2. 核心特性 <a class="header-anchor" href="#_2-核心特性" aria-label="Permalink to &quot;2. 核心特性&quot;">​</a></h2><h3 id="a-高性能-fast" tabindex="-1">a. 高性能 (Fast) <a class="header-anchor" href="#a-高性能-fast" aria-label="Permalink to &quot;a. 高性能 (Fast)&quot;">​</a></h3><p>Wasm 代码是一种底层的二进制格式，浏览器无需像解析 JavaScript 那样进行复杂的词法、语法分析和多次优化编译。它可以被非常快速地解码并直接编译成高效的机器码，因此其执行速度远超 JavaScript，非常接近原生应用的水平。</p><p>此外，Wasm 还支持 <strong>SIMD (单指令多数据流)</strong> 等高级硬件指令，允许对数据进行高效的并行计算，这在图像处理、多媒体编解码等领域能带来巨大的性能提升。</p><h3 id="b-可移植-portable" tabindex="-1">b. 可移植 (Portable) <a class="header-anchor" href="#b-可移植-portable" aria-label="Permalink to &quot;b. 可移植 (Portable)&quot;">​</a></h3><p>Wasm 被设计成独立于硬件、操作系统和编程语言的通用指令集。这意味着，用 C++/Rust 等语言编写的代码，只需一次编译成 <code>.wasm</code> 文件，就可以在所有支持 Wasm 的现代浏览器中以可预测的方式运行。</p><p>Wasm 的愿景不止于浏览器。通过 <strong>WASI (WebAssembly System Interface)</strong>，Wasm 可以在服务器、边缘计算节点等任何环境中，以标准化的方式与底层系统交互，真正实现“一次编写，到处运行”。</p><h3 id="c-安全-secure" tabindex="-1">c. 安全 (Secure) <a class="header-anchor" href="#c-安全-secure" aria-label="Permalink to &quot;c. 安全 (Secure)&quot;">​</a></h3><p>Wasm 代码运行在一个<strong>沙箱化 (Sandboxed)</strong> 的执行环境中，其内存是独立的。它无法直接访问或干扰外部的 JavaScript 上下文或操作系统的任意内存。Wasm 模块必须通过明确导入的 JavaScript 函数，才能与外部世界（如 DOM）进行交互，这保证了其安全性。</p><h2 id="_3-工作流程" tabindex="-1">3. 工作流程 <a class="header-anchor" href="#_3-工作流程" aria-label="Permalink to &quot;3. 工作流程&quot;">​</a></h2><p>WebAssembly 的使用通常遵循以下步骤：</p><ol><li><strong>编写</strong>：使用 C, C++, Rust, Go 等支持 Wasm 编译目标的语言编写源代码。</li><li><strong>编译</strong>：使用相应的工具链（如 Emscripten for C/C++, <code>wasm-pack</code> for Rust）将源代码编译成一个 <code>.wasm</code> 二进制文件。这个工具链通常还会生成一个 <code>.js</code> 的“胶水”文件，用于简化 Wasm 模块的加载和与 JavaScript 的交互。</li><li><strong>加载与实例化</strong>：在你的 Web 应用中，使用 JavaScript 来加载这个 <code>.wasm</code> 文件。 <ul><li>可以通过 <code>WebAssembly.instantiateStreaming(fetch(&#39;module.wasm&#39;))</code> API 来高效地流式加载和编译 Wasm 模块。</li></ul></li><li><strong>调用</strong>：一旦模块实例化成功，JavaScript 就可以像调用一个普通的 JS 对象的方法一样，调用从 Wasm 模块中<strong>导出 (export)</strong> 的函数。同时，Wasm 模块也可以调用从 JavaScript 中<strong>导入 (import)</strong> 的函数。</li></ol><p><strong>示例（伪代码）：</strong></p><div class="language-javascript vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// main.js</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 假设 &#39;module.wasm&#39; 导出了一个名为 &#39;add&#39; 的函数</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 准备一个导入对象，让 Wasm 可以调用 JS 函数</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> importObject</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  console: {</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    log</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: (</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">arg</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> console.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">log</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(arg)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">};</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">WebAssembly.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">instantiateStreaming</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">fetch</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;module.wasm&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">), importObject)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  .</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">then</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">obj</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    // 调用 Wasm 导出的 &#39;add&#39; 函数</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> result</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> obj.instance.exports.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">add</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">2</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">3</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    console.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">log</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(result); </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 输出 5</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  });</span></span></code></pre></div><h2 id="_4-与-javascript-的交互-内存模型" tabindex="-1">4. 与 JavaScript 的交互：内存模型 <a class="header-anchor" href="#_4-与-javascript-的交互-内存模型" aria-label="Permalink to &quot;4. 与 JavaScript 的交互：内存模型&quot;">​</a></h2><p>Wasm 与 JavaScript 之间的交互是其设计的核心。</p><ul><li><strong>数值类型</strong>：<code>i32</code>, <code>f64</code> 等数字类型可以直接、高效地在 JS 和 Wasm 函数的参数和返回值之间传递。</li><li><strong>复杂类型</strong>：对于字符串、数组、对象等复杂数据类型，<strong>无法直接传递</strong>。它们必须存储在 Wasm 模块的<strong>线性内存 (Linear Memory)</strong> 中。 <ul><li>线性内存是 Wasm 模块内部的一块连续的、可由 JS 读写的内存空间，表现为一个 <code>ArrayBuffer</code> 对象。</li><li>JS 需要通过 <code>Uint8Array</code> 等 <code>ArrayBuffer</code> 的视图，将数据写入或从这块内存中读出。</li><li><strong>“胶水”代码的作用</strong>：像 Emscripten 或 <code>wasm-pack</code> 这样的工具链，会自动生成 JavaScript “胶水”代码。这些代码的核心职责之一，就是<strong>封装复杂的内存读写操作</strong>，例如将 JS 字符串编码后写入 Wasm 内存，或从 Wasm 内存中解码出字符串返回给 JS，从而为开发者提供友好、易用的 API。</li></ul></li></ul><h2 id="_5-典型应用场景" tabindex="-1">5. 典型应用场景 <a class="header-anchor" href="#_5-典型应用场景" aria-label="Permalink to &quot;5. 典型应用场景&quot;">​</a></h2><p>WebAssembly 的核心价值在于将那些以往受限于性能而无法在 Web 上流畅运行的应用变为可能。</p><ul><li><strong>游戏</strong>：大型 3D 游戏引擎（如 Unity, Unreal Engine）可以将它们的核心代码编译成 Wasm，让复杂的 3D 游戏可以直接在浏览器中以高性能运行。</li><li><strong>音视频处理</strong>：实时视频编辑、音频混音、编解码等计算密集型任务。</li><li><strong>科学计算与数据可视化</strong>：物理模拟、生物信息学分析、大规模数据可视化等。</li><li><strong>CAD 与 3D 设计软件</strong>：像 AutoCAD, Figma 等桌面级复杂应用，可以通过 Wasm 将其核心功能移植到 Web 平台。</li><li><strong>遗留系统移植</strong>：将一些用 C/C++ 编写的、经过长期验证的桌面应用或库，平滑地迁移到 Web 环境中。</li></ul><h2 id="总结" tabindex="-1">总结 <a class="header-anchor" href="#总结" aria-label="Permalink to &quot;总结&quot;">​</a></h2><p>WebAssembly 为 Web 平台开启了性能的新纪元。它通过提供一个安全、快速、可移植的二进制格式，让 C++/Rust 等高性能语言生态与 JavaScript 生态实现了完美的结合。它使得浏览器不再仅仅是一个文档查看器，而真正成为了一个能够承载桌面级复杂应用的强大平台。</p>`,29)])])}const g=a(e,[["render",l]]);export{c as __pageData,g as default};
