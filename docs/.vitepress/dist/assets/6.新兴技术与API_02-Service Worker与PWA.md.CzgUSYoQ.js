import{_ as i,c as a,o as n,ae as e}from"./chunks/framework.DK_uz7nx.js";const o=JSON.parse('{"title":"16-Service Worker 与 PWA","description":"","frontmatter":{},"headers":[],"relativePath":"6.新兴技术与API/02-Service Worker与PWA.md","filePath":"6.新兴技术与API/02-Service Worker与PWA.md"}'),l={name:"6.新兴技术与API/02-Service Worker与PWA.md"};function t(h,s,p,k,r,E){return n(),a("div",null,[...s[0]||(s[0]=[e(`<h1 id="_16-service-worker-与-pwa" tabindex="-1">16-Service Worker 与 PWA <a class="header-anchor" href="#_16-service-worker-与-pwa" aria-label="Permalink to &quot;16-Service Worker 与 PWA&quot;">​</a></h1><h2 id="_1-service-worker-pwa-的心脏" tabindex="-1">1. Service Worker: PWA 的心脏 <a class="header-anchor" href="#_1-service-worker-pwa-的心脏" aria-label="Permalink to &quot;1. Service Worker: PWA 的心脏&quot;">​</a></h2><p><strong>Service Worker</strong> 是一个在浏览器后台独立于网页运行的<strong>事件驱动型</strong>脚本。它扮演着一个<strong>网络代理</strong>的角色，能够拦截、处理和响应页面发出的网络请求。这项能力是实现 PWA（渐进式 Web 应用）诸多核心功能的基石。</p><p>与普通的 Web Worker 相比，Service Worker（简称 SW）具有更强大的能力和更特殊的生命周期。</p><h3 id="a-核心特性" tabindex="-1">a. 核心特性 <a class="header-anchor" href="#a-核心特性" aria-label="Permalink to &quot;a. 核心特性&quot;">​</a></h3><ul><li><strong>后台运行</strong>：SW 在其作用域下的页面关闭后，依然可以在后台运行。</li><li><strong>网络代理</strong>：通过 <code>fetch</code> 事件，可以拦截网络请求，从而实现离线缓存、自定义响应等功能。</li><li><strong>无法访问 DOM</strong>：和 Web Worker 一样，SW 无法直接操作 DOM。它通过 <code>postMessage</code> API 与页面进行通信。</li><li><strong>必须在 HTTPS 环境下运行</strong>：出于安全考虑，Service Worker 只能在 HTTPS 协议的网站上注册和使用（<code>localhost</code> 除外）。</li></ul><h3 id="b-生命周期-lifecycle" tabindex="-1">b. 生命周期 (Lifecycle) <a class="header-anchor" href="#b-生命周期-lifecycle" aria-label="Permalink to &quot;b. 生命周期 (Lifecycle)&quot;">​</a></h3><p>Service Worker 的生命周期是其最重要也最复杂的概念之一，它独立于页面，由浏览器严格控制。</p><ol><li><p><strong>注册 (Register)</strong></p><ul><li>在主线程的 JS 中，我们首先检查浏览器是否支持 SW，然后调用 <code>navigator.serviceWorker.register()</code> 来注册一个 SW 脚本。</li><li><div class="language-javascript vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// main.js</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">if</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;serviceWorker&#39;</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> in</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> navigator) {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  navigator.serviceWorker.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">register</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;/sw.js&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    .</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">then</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">registration</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> console.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">log</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;Service Worker registered:&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, registration))</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    .</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">catch</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">error</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> console.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">log</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;Service Worker registration failed:&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, error));</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div></li><li><code>register()</code> 方法会返回一个 Promise，并且<strong>每次页面加载时都会执行</strong>。浏览器会智能地判断 SW 脚本文件是否有变化，只有在文件内容发生改变时，才会触发后续的安装和激活流程。</li></ul></li><li><p><strong>安装 (Install) 与 Cache API</strong></p><ul><li><p>注册成功后，浏览器会下载并解析 SW 脚本，触发其内部的 <code>install</code> 事件。</p></li><li><p><code>install</code> 事件只会在 SW <strong>首次注册</strong>或<strong>脚本文件更新</strong>时触发一次。</p></li><li><p>这是进行<strong>静态资源缓存</strong>的最佳时机。这里使用的核心技术就是 <strong>Cache API</strong>。</p></li><li><p><strong>深入 Cache API</strong>:</p><ul><li><strong>独立性</strong>: Cache API 是一个<strong>独立的、可用于主线程和 Worker 的 Web API</strong>。它提供了一个由开发者完全控制的、持久化的 Request/Response 对象存储机制。它不是 HTTP 缓存，而是 Service Worker 实现复杂缓存策略的“弹药库”。</li><li><strong>核心方法</strong>: <ul><li><code>caches.open(cacheName)</code>: 打开一个指定名称的缓存，如果不存在则创建。返回一个 Promise，resolve 为 cache 对象。</li><li><code>cache.add(url)</code> / <code>cache.addAll(urls)</code>: 发起网络请求获取资源，并将响应对象存入缓存。这是一个原子操作，如果请求失败或响应不是 2xx，整个操作会失败。</li><li><code>cache.put(request, response)</code>: 将一个请求和对应的响应键值对直接存入缓存。更灵活，可以存储非 GET 请求的缓存或自定义的响应。</li><li><code>caches.match(request)</code>: 在所有缓存中查找与该请求匹配的第一个响应。</li><li><code>caches.delete(cacheName)</code>: 删除指定名称的缓存。</li><li><code>cache.keys()</code>: 获取缓存中所有的请求对象。</li></ul></li></ul></li><li><p>在 <code>install</code> 事件中，可以通过 <code>event.waitUntil()</code> 方法来延长事件的生命周期，直到传入的 Promise 完成。这可以确保在 SW 安装完成之前，所有核心资源都已被成功缓存。</p></li><li><div class="language-javascript vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// sw.js</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> CACHE_NAME</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &#39;my-app-cache-v1&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> urlsToCache</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> [</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;/&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;/styles/main.css&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;/script/main.js&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">];</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">self.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">addEventListener</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;install&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">event</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  event.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">waitUntil</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    caches.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">open</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">CACHE_NAME</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">      .</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">then</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">cache</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        console.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">log</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;Opened cache&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">        return</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> cache.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">addAll</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(urlsToCache);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">      })</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  );</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">});</span></span></code></pre></div></li></ul><p><strong>4. 加速更新流程：<code>skipWaiting</code> 与 <code>clients.claim</code></strong></p><p>默认情况下，当一个新的 SW 安装成功后，它会进入 <code>waiting</code> 状态，直到用户关闭所有受当前旧 SW 控制的页面。这种机制确保了页面不会在访问过程中突然被新的 SW 接管，保证了一致性。</p><p>但在很多场景下，我们希望用户能尽快用上最新的版本。这时就需要手动控制更新流程：</p><ul><li><code>self.skipWaiting()</code>: 在 <code>install</code> 事件中调用此方法，可以让新的 SW 在安装成功后<strong>立即跳过等待，直接进入 <code>activate</code> 阶段</strong>。</li><li><code>self.clients.claim()</code>: 在 <code>activate</code> 事件中调用此方法，可以让 SW <strong>立即接管</strong>当前所有在其作用域内的页面，而无需等待页面刷新。</li></ul><div class="language-javascript vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// sw.js - 立即更新的示例</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">self.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">addEventListener</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;install&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">event</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">  // ... 缓存资源 ...</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  self.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">skipWaiting</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(); </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 安装后立即激活</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">});</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">self.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">addEventListener</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;activate&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">event</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">  // ... 清理旧缓存 ...</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  event.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">waitUntil</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(self.clients.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">claim</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()); </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 激活后立即控制页面</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">});</span></span></code></pre></div></li><li><p><strong>激活 (Activate)</strong></p><ul><li>当 SW 安装成功后，它会进入 <code>waiting</code> 状态，等待旧的、当前正控制页面的 SW 终止。</li><li>一旦旧的 SW 停止工作（例如用户关闭了所有相关的标签页），新的 SW 就会接管控制权，并触发 <code>activate</code> 事件。</li><li><code>activate</code> 事件是<strong>清理旧缓存</strong>的最佳时机。我们可以在这里遍历所有的缓存，删除那些不再需要的旧版本缓存。</li><li>同样，<code>event.waitUntil()</code> 也可以用来确保清理工作完成后再处理其他事件。</li><li><div class="language-javascript vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// sw.js</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">self.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">addEventListener</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;activate&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">event</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> cacheWhitelist</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> [</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;my-app-cache-v1&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">];</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  event.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">waitUntil</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    caches.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">keys</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">().</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">then</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">cacheNames</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">      return</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> Promise</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">all</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        cacheNames.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">map</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">cacheName</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">          if</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (cacheWhitelist.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">indexOf</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(cacheName) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">===</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> -</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">            return</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> caches.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">delete</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(cacheName);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">          }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        })</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">      );</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    })</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  );</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">});</span></span></code></pre></div></li></ul></li></ol><h3 id="c-核心事件-fetch" tabindex="-1">c. 核心事件：<code>fetch</code> <a class="header-anchor" href="#c-核心事件-fetch" aria-label="Permalink to &quot;c. 核心事件：\`fetch\`&quot;">​</a></h3><p><code>fetch</code> 事件是 Service Worker 发挥网络代理能力的核心。当 SW 激活并控制页面后，页面上发出的任何网络请求（<code>fetch</code> API, <code>&lt;img&gt;</code> 标签, XHR 等）都会触发 SW 中的 <code>fetch</code> 事件。</p><p>在这个事件的回调函数中，我们可以：</p><ul><li><strong>拦截请求</strong>：通过 <code>event.request</code> 对象获取请求的详细信息。</li><li><strong>自定义响应</strong>：通过 <code>event.respondWith()</code> 方法返回一个自定义的 <code>Response</code> 对象。</li></ul><p><strong>缓存优先 (Cache First) 策略示例：</strong></p><div class="language-javascript vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// sw.js</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">self.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">addEventListener</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;fetch&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">event</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  event.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">respondWith</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    caches.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">match</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(event.request)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">      .</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">then</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">response</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">        // 如果在缓存中找到了匹配的响应，则直接返回它</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">        if</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (response) {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">          return</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> response;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        }</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">        // 否则，发起网络请求，并让浏览器正常处理</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">        return</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> fetch</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(event.request);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">      })</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  );</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">});</span></span></code></pre></div><p>通过这种方式，我们可以轻松实现离线访问。如果资源在缓存中，即使用户断网，页面依然可以从缓存中加载并显示。</p><p><strong>多样化的缓存策略</strong></p><p>除了“缓存优先”，SW 的灵活性还允许我们实现多种缓存策略：</p><ul><li><strong>网络优先 (Network First)</strong>：优先尝试从网络获取资源。如果成功，则更新缓存；如果失败（如离线），则从缓存中读取。适用于对实时性要求高的资源，如 API 数据。</li><li><strong>仅缓存 (Cache Only)</strong>：只从缓存中读取，绝不访问网络。适用于应用外壳（App Shell）中那些一经缓存就不会改变的静态资源。</li><li><strong>仅网络 (Network Only)</strong>：总是从网络获取，从不使用缓存。适用于非 GET 请求或一些必须实时获取的数据。</li><li><strong>Stale-While-Revalidate</strong>：响应缓存中的版本（实现快速加载），同时在后台发起网络请求获取最新版本并更新缓存，供下次使用。这是平衡性能和内容新鲜度的绝佳策略。</li></ul><h3 id="d-其他核心事件-push-与-sync" tabindex="-1">d. 其他核心事件：<code>push</code> 与 <code>sync</code> <a class="header-anchor" href="#d-其他核心事件-push-与-sync" aria-label="Permalink to &quot;d. 其他核心事件：\`push\` 与 \`sync\`&quot;">​</a></h3><ul><li><strong><code>push</code> 事件</strong>：这是实现<strong>消息推送 (Push Notifications)</strong> 的入口。当应用服务器通过推送服务向用户发送消息时，浏览器会唤醒对应的 SW 并触发 <code>push</code> 事件，允许我们在后台处理消息，并通过 <code>self.registration.showNotification()</code> 向用户显示系统通知。</li><li><strong><code>sync</code> 事件 (Background Sync)</strong>：允许应用在网络恢复时<strong>同步后台数据</strong>。例如，用户在离线状态下提交了一个表单，我们可以将请求存入 IndexedDB，然后注册一个 <code>sync</code> 事件。当网络连接恢复时，浏览器会自动触发该事件，让 SW 读取之前存储的请求并重新发送。</li></ul><h2 id="_2-pwa-progressive-web-apps-渐进式-web-应用" tabindex="-1">2. PWA (Progressive Web Apps) - 渐进式 Web 应用 <a class="header-anchor" href="#_2-pwa-progressive-web-apps-渐进式-web-应用" aria-label="Permalink to &quot;2. PWA (Progressive Web Apps) - 渐进式 Web 应用&quot;">​</a></h2><p>PWA 不是一项单一的技术，而是一套<strong>理念和技术的集合</strong>，其目标是让 Web 应用拥有接近原生应用的体验。Service Worker 是实现 PWA 的技术核心，但一个完整的 PWA 还需要满足其他几个条件。</p><h3 id="a-pwa-的核心特征" tabindex="-1">a. PWA 的核心特征 <a class="header-anchor" href="#a-pwa-的核心特征" aria-label="Permalink to &quot;a. PWA 的核心特征&quot;">​</a></h3><ul><li><strong>可靠 (Reliable)</strong>：通过 Service Worker 实现离线或在弱网环境下也能快速加载和使用。</li><li><strong>快速 (Fast)</strong>：对用户交互提供快速响应，动画流畅。</li><li><strong>可安装 (Installable)</strong>：通过 <strong>Web App Manifest</strong> 文件，用户可以将应用“添加至主屏幕”，像原生应用一样拥有独立的图标和启动体验。</li><li><strong>吸引人 (Engaging)</strong>：通过 <strong>推送通知 (Push Notifications)</strong> 等功能，可以主动与用户互动，提升用户粘性。</li></ul><h3 id="b-web-app-manifest-应用清单文件" tabindex="-1">b. Web App Manifest (应用清单文件) <a class="header-anchor" href="#b-web-app-manifest-应用清单文件" aria-label="Permalink to &quot;b. Web App Manifest (应用清单文件)&quot;">​</a></h3><ul><li>这是一个简单的 <code>manifest.json</code> 文件，用于向浏览器提供关于该 Web 应用的元数据信息。</li><li><strong>内容</strong>：包括应用的名称 (<code>name</code>, <code>short_name</code>)、图标 (<code>icons</code>)、启动 URL (<code>start_url</code>)、显示模式 (<code>display</code>: <code>standalone</code>, <code>fullscreen</code> 等)、主题颜色 (<code>theme_color</code>) 等。</li><li><strong>作用</strong>：浏览器根据这个文件来展示“添加到主屏幕”的提示，并决定应用安装后的外观和行为。</li></ul><div class="language-json vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">json</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">{</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">  &quot;short_name&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;My App&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">  &quot;name&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;My Awesome App&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">  &quot;icons&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: [</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    {</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">      &quot;src&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;/images/icons-192.png&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">      &quot;type&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;image/png&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">      &quot;sizes&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;192x192&quot;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  ],</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">  &quot;start_url&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;/?source=pwa&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">  &quot;display&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;standalone&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">  &quot;theme_color&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;#3367D6&quot;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><p>通过将 Service Worker（负责可靠性）、Web App Manifest（负责可安装性）以及其他 Web 技术（如 HTTPS、响应式设计）结合起来，我们就能构建出一个完整的、体验优秀的 PWA。</p>`,29)])])}const c=i(l,[["render",t]]);export{o as __pageData,c as default};
