import{_ as o,c as t,o as a,ae as c}from"./chunks/framework.DK_uz7nx.js";const k=JSON.parse('{"title":"06-认证与授权：JWT 安全最佳实践","description":"","frontmatter":{},"headers":[],"relativePath":"5.浏览器安全/06-认证与授权：JWT安全最佳实践.md","filePath":"5.浏览器安全/06-认证与授权：JWT安全最佳实践.md"}'),s={name:"5.浏览器安全/06-认证与授权：JWT安全最佳实践.md"};function i(r,e,l,d,n,g){return a(),t("div",null,[...e[0]||(e[0]=[c('<h1 id="_06-认证与授权-jwt-安全最佳实践" tabindex="-1">06-认证与授权：JWT 安全最佳实践 <a class="header-anchor" href="#_06-认证与授权-jwt-安全最佳实践" aria-label="Permalink to &quot;06-认证与授权：JWT 安全最佳实践&quot;">​</a></h1><p>在现代 Web 应用，尤其是单页应用（SPA）中，JSON Web Token (JWT) 已成为事实上的标准认证授权方案。它通过一个紧凑且自包含的字符串，在客户端和服务端之间安全地传递用户信息。然而，JWT 的广泛使用也带来了新的安全挑战，其中最核心的问题就是：<strong>JWT 应该如何安全地存储在浏览器端？</strong></p><h2 id="_1-jwt-结构回顾" tabindex="-1">1. JWT 结构回顾 <a class="header-anchor" href="#_1-jwt-结构回顾" aria-label="Permalink to &quot;1. JWT 结构回顾&quot;">​</a></h2><p>一个 JWT 由三部分组成，通过 <code>.</code> 分隔： <code>Header.Payload.Signature</code></p><ul><li><strong>Header (头部)</strong>：包含了令牌的类型（<code>typ</code>: &quot;JWT&quot;）和所使用的签名算法（如 <code>alg</code>: &quot;HS256&quot;）。</li><li><strong>Payload (载荷)</strong>：包含了“声明 (claims)”，是关于实体（通常是用户）和其他数据的陈述。例如 <code>sub</code> (主题), <code>name</code> (用户名), <code>exp</code> (过期时间)。<strong>Payload 中的数据是 Base64 编码的，并非加密，因此绝对不能存放敏感信息！</strong></li><li><strong>Signature (签名)</strong>：用于验证消息在传递过程中没有被篡改。它是通过对编码后的 <code>Header</code> 和 <code>Payload</code>、一个密钥 (<code>secret</code>) 以及 <code>Header</code> 中指定的算法进行计算得出的。</li></ul><h2 id="_2-核心问题-jwt-的存储" tabindex="-1">2. 核心问题：JWT 的存储 <a class="header-anchor" href="#_2-核心问题-jwt-的存储" aria-label="Permalink to &quot;2. 核心问题：JWT 的存储&quot;">​</a></h2><p>这是一个长期以来在前端社区中激烈辩论的话题。主要有两种方案，它们各自权衡了不同的安全风险。</p><h3 id="a-方案一-存储在-localstorage-sessionstorage" tabindex="-1">a. 方案一：存储在 <code>LocalStorage</code> / <code>SessionStorage</code> <a class="header-anchor" href="#a-方案一-存储在-localstorage-sessionstorage" aria-label="Permalink to &quot;a. 方案一：存储在 `LocalStorage` / `SessionStorage`&quot;">​</a></h3><p>这是最简单直接的方式。客户端在登录后将获取到的 JWT 存入 <code>LocalStorage</code>，之后在每个需要认证的 API 请求中，通过 JavaScript 读取它，并放入 <code>Authorization</code> HTTP 头部。</p><ul><li><strong>优点</strong>： <ul><li>API 简单，使用方便。</li><li>服务端无需关心 CSRF 防御，因为浏览器不会自动携带 <code>LocalStorage</code> 中的数据。</li></ul></li><li><strong>致命缺点：易受 XSS 攻击</strong>： <ul><li>如果应用存在任何 XSS 漏洞，攻击者注入的恶意脚本就可以<strong>直接读取</strong> <code>LocalStorage</code> 中的所有数据，从而轻松窃取 JWT。一旦 JWT 被盗，攻击者就可以在有效期内冒充用户身份，为所欲为。</li></ul></li></ul><p><strong>结论</strong>：由于 XSS 漏洞在复杂应用中难以完全根除，将 JWT 存储在 <code>LocalStorage</code> 中被认为是一种<strong>高风险、不推荐</strong>的做法。</p><h3 id="b-方案二-推荐-存储在-httponly-cookie" tabindex="-1">b. 方案二（推荐）：存储在 <code>HttpOnly</code> Cookie <a class="header-anchor" href="#b-方案二-推荐-存储在-httponly-cookie" aria-label="Permalink to &quot;b. 方案二（推荐）：存储在 `HttpOnly` Cookie&quot;">​</a></h3><p>在这种方案中，服务端在用户登录成功后，通过 <code>Set-Cookie</code> HTTP 头部将 JWT 写入浏览器的 Cookie。</p><div class="language-http vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">http</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">Set-Cookie</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">:</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> accessToken=...; HttpOnly; Secure; SameSite=Strict</span></span></code></pre></div><ul><li><strong>优点</strong>： <ul><li><strong>有效防御 XSS</strong>：<code>HttpOnly</code> 标志使得该 Cookie <strong>无法通过 JavaScript (<code>document.cookie</code>) 访问</strong>。这意味着，即使应用存在 XSS 漏洞，攻击者的脚本也无法读取到这个 Cookie，从而保护了 JWT 不被窃取。</li><li><strong>自动发送</strong>：浏览器会在后续的每个同源请求中自动携带这个 Cookie，无需前端手动处理。</li></ul></li><li><strong>需要应对的风险：CSRF 攻击</strong>： <ul><li>由于 Cookie 会被自动发送，这使得应用面临 CSRF 攻击的风险。幸运的是，我们可以通过设置 Cookie 的 <code>SameSite</code> 属性来有效缓解。</li><li><code>SameSite=Strict</code>：最严格的模式，完全禁止第三方 Cookie，可以完全防御 CSRF，但可能会影响某些跨站链接的用户体验。</li><li><code>SameSite=Lax</code>：默认值。允许在用户从外部网站导航到你的网站时（如点击链接）发送 Cookie，但在跨域的 <code>POST</code> 请求等场景下会阻止，能防御大部分 CSRF 攻击。</li><li><code>Secure</code> 标志确保 Cookie 只在 HTTPS 连接中被发送。</li></ul></li></ul><p><strong>结论</strong>：将 JWT 存储在配置了 <code>HttpOnly</code>, <code>Secure</code> 和 <code>SameSite</code> 属性的 Cookie 中，是目前公认的<strong>最安全、最推荐</strong>的最佳实践。</p><h2 id="_3-refresh-token-模式-提升长期安全性" tabindex="-1">3. Refresh Token 模式：提升长期安全性 <a class="header-anchor" href="#_3-refresh-token-模式-提升长期安全性" aria-label="Permalink to &quot;3. Refresh Token 模式：提升长期安全性&quot;">​</a></h2><p>直接存储的 JWT（<code>Access Token</code>）通常生命周期很短（如15分钟-1小时），以减少泄露后的风险。但这会导致用户需要频繁重新登录。为了解决这个问题，引入了 <code>Refresh Token</code> 模式。</p><ul><li><strong>Access Token</strong>：用于访问受保护的资源，生命周期<strong>短</strong>。它可以被存储在内存中，或者如上所述的 <code>HttpOnly</code> Cookie 里。</li><li><strong>Refresh Token</strong>：用于获取新的 <code>Access Token</code>，生命周期<strong>长</strong>（如几天或几周）。它<strong>必须被极其安全地存储</strong>，通常是在一个独立的、设置了 <code>HttpOnly</code> 和 <code>Path</code>（指向刷新API的特定路径）的 Cookie 中。</li></ul><p><strong>流程</strong>：</p><ol><li>用户登录，服务器返回一个短期的 <code>Access Token</code> 和一个长期的 <code>Refresh Token</code>。</li><li>客户端使用 <code>Access Token</code> 访问 API。</li><li>当 <code>Access Token</code> 过期时，API 返回 401 错误。</li><li>客户端自动向一个特定的刷新端点（如 <code>/refresh_token</code>）发送 <code>Refresh Token</code>。</li><li>服务器验证 <code>Refresh Token</code>，如果有效，则签发一个新的 <code>Access Token</code>，客户端用新令牌重试刚才失败的请求。</li><li>如果 <code>Refresh Token</code> 也过期了，用户才需要重新登录。</li></ol><h2 id="_4-jwt-安全清单" tabindex="-1">4. JWT 安全清单 <a class="header-anchor" href="#_4-jwt-安全清单" aria-label="Permalink to &quot;4. JWT 安全清单&quot;">​</a></h2><ul><li>[ ] <strong>始终使用 HTTPS</strong> 来传输 JWT。</li><li>[ ] <strong>不要在 Payload 中存放任何敏感信息</strong>。</li><li>[ ] <strong>使用 <code>HttpOnly</code>、<code>Secure</code>、<code>SameSite</code> Cookie</strong> 来存储 JWT，防御 XSS 和 CSRF。</li><li>[ ] <strong>设置一个合理的、较短的过期时间</strong> (<code>exp</code>) 给 <code>Access Token</code>。</li><li>[ ] <strong>采用 Refresh Token 模式</strong> 来改善用户体验和长期安全性。</li><li>[ ] <strong>考虑实现 Refresh Token 的吊销机制</strong>，以便在用户登出或密码修改时能立即废止其所有会话。</li></ul><h2 id="总结" tabindex="-1">总结 <a class="header-anchor" href="#总结" aria-label="Permalink to &quot;总结&quot;">​</a></h2><p>JWT 的安全性高度依赖于其正确的实现和存储策略。通过将 JWT 存储在配置严格的 <code>HttpOnly</code> Cookie 中，并配合 Refresh Token 模式，我们可以在防御 XSS 和 CSRF 攻击之间找到最佳平衡点，为现代 Web 应用构建一个强大而可靠的认证授权体系。</p>',25)])])}const p=o(s,[["render",i]]);export{k as __pageData,p as default};
