import{_ as i,c as a,o as n,ae as l}from"./chunks/framework.DK_uz7nx.js";const c=JSON.parse('{"title":"07-File System Access API：让Web应用操作本地文件","description":"","frontmatter":{},"headers":[],"relativePath":"6.新兴技术与API/07-File System Access API：让Web应用操作本地文件.md","filePath":"6.新兴技术与API/07-File System Access API：让Web应用操作本地文件.md"}'),e={name:"6.新兴技术与API/07-File System Access API：让Web应用操作本地文件.md"};function t(h,s,p,k,r,E){return n(),a("div",null,[...s[0]||(s[0]=[l(`<h1 id="_07-file-system-access-api-让web应用操作本地文件" tabindex="-1">07-File System Access API：让Web应用操作本地文件 <a class="header-anchor" href="#_07-file-system-access-api-让web应用操作本地文件" aria-label="Permalink to &quot;07-File System Access API：让Web应用操作本地文件&quot;">​</a></h1><p>传统的 Web 应用被严格限制在浏览器的沙箱内，与用户本地文件系统的交互仅限于 <code>&lt;input type=&quot;file&quot;&gt;</code> 的上传和 <code>&lt;a&gt;</code> 标签的下载。这种模式流程繁琐，限制了 Web 应用作为生产力工具的潜力。<code>File System Access API</code> 的出现，彻底改变了这一现状。</p><p>这个 API 是一套允许 Web 应用在用户明确授权后，直接与用户设备上的文件和目录进行交互的接口。它为构建功能强大的、体验媲美原生应用的 Web App（如在线 IDE、设计工具、富文本编辑器）铺平了道路。</p><h2 id="_1-核心概念与安全模型" tabindex="-1">1. 核心概念与安全模型 <a class="header-anchor" href="#_1-核心概念与安全模型" aria-label="Permalink to &quot;1. 核心概念与安全模型&quot;">​</a></h2><p><code>File System Access API</code> 的设计将用户安全放在首位。</p><ul><li><strong>用户授权是前提</strong>：对文件或目录的任何访问都必须由用户通过一个明确的交互（如点击按钮）来发起，并由浏览器弹出的文件/目录选择器进行确认。浏览器会记住授权，在会话期间无需重复询问。</li><li><strong>句柄 (Handle) 模型</strong>：当用户选择一个文件或目录后，API 会返回一个句柄对象（<code>FileSystemFileHandle</code> 或 <code>FileSystemDirectoryHandle</code>）。这个句柄是后续所有交互的入口，它代表了对该文件或目录的访问权限。</li><li><strong>安全上下文</strong>：此 API 仅在安全上下文 (HTTPS) 中可用。</li></ul><h2 id="_2-读取本地文件" tabindex="-1">2. 读取本地文件 <a class="header-anchor" href="#_2-读取本地文件" aria-label="Permalink to &quot;2. 读取本地文件&quot;">​</a></h2><p>读取文件是最常见的操作。</p><div class="language-javascript vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> button</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> document.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">getElementById</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;open-file-btn&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">button.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">addEventListener</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;click&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">async</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> () </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  try</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    // 弹出文件选择器，让用户选择一个文件</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    // 返回的是一个包含文件句柄的数组</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    const</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> [</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">fileHandle</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">] </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> await</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> window.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">showOpenFilePicker</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">();</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    // 从句柄中获取文件对象</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> file</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> await</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> fileHandle.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">getFile</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">();</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    // 读取文件内容</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> contents</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> await</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> file.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">text</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">();</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    console.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">log</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(contents);</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  } </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">catch</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (err) {</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    // 用户取消选择或发生其他错误</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    console.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">error</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(err.name, err.message);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">});</span></span></code></pre></div><p><code>showOpenFilePicker()</code> 方法可以接受一个选项对象，用于配置可选的文件类型、是否允许多选等。</p><h2 id="_3-写入本地文件" tabindex="-1">3. 写入本地文件 <a class="header-anchor" href="#_3-写入本地文件" aria-label="Permalink to &quot;3. 写入本地文件&quot;">​</a></h2><p>写入文件同样直观，并且 API 的设计考虑了数据写入的原子性和安全性。</p><div class="language-javascript vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">let</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> fileHandle; </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 在某处获取并保存文件句柄</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">async</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> function</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> saveFile</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">contents</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  try</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    if</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">!</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">fileHandle) {</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">      // 如果没有句柄，则弹出“另存为”对话框</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">      fileHandle </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> await</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> window.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">showSaveFilePicker</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">();</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    }</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    // 创建一个可写入的流</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> writable</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> await</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> fileHandle.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">createWritable</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">();</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    // 写入内容</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    await</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> writable.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">write</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(contents);</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    // 关闭流，确保所有内容都已写入磁盘</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    await</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> writable.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">close</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">();</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    console.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">log</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;File saved successfully!&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  } </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">catch</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (err) {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    console.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">error</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(err.name, err.message);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><p><strong>关键点</strong>：</p><ul><li><code>showSaveFilePicker()</code> 用于让用户选择保存位置或创建一个新文件。</li><li>写入操作是通过 <code>createWritable()</code> 创建一个 <code>FileSystemWritableFileStream</code> 来完成的，这种流式写入的方式对大文件非常友好。</li><li><code>writable.close()</code> 是一个至关重要的步骤，它标志着写入操作的完成。</li></ul><h2 id="_4-更多能力" tabindex="-1">4. 更多能力 <a class="header-anchor" href="#_4-更多能力" aria-label="Permalink to &quot;4. 更多能力&quot;">​</a></h2><p>除了读写单个文件，<code>File System Access API</code> 还提供了：</p><ul><li><strong>目录访问</strong>：通过 <code>window.showDirectoryPicker()</code> 获取目录句柄，可以遍历目录下的文件和子目录，实现像 VS Code 打开项目文件夹一样的功能。</li><li><strong>拖放集成</strong>：可以与 HTML 的拖放 API 结合，获取拖入文件的句柄。</li></ul><h2 id="总结" tabindex="-1">总结 <a class="header-anchor" href="#总结" aria-label="Permalink to &quot;总结&quot;">​</a></h2><p><code>File System Access API</code> 是将 Web 从一个“文档查看平台”转变为“应用运行平台”的关键一步。它极大地拓展了 Web 应用的能力边界，让开发者能够构建出更加强大、无缝和用户友好的在线工具。虽然目前还在不断发展中，但它所代表的方向无疑是 Web 的未来。</p>`,20)])])}const g=i(e,[["render",t]]);export{c as __pageData,g as default};
