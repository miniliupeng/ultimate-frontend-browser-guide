import{_ as i,c as a,o as t,ae as n}from"./chunks/framework.DK_uz7nx.js";const g=JSON.parse('{"title":"07-渲染流程：布局、绘制与合成","description":"","frontmatter":{},"headers":[],"relativePath":"3.页面渲染与性能优化/01-渲染流程：重排（Reflow）与重绘（Repaint）.md","filePath":"3.页面渲染与性能优化/01-渲染流程：重排（Reflow）与重绘（Repaint）.md"}'),l={name:"3.页面渲染与性能优化/01-渲染流程：重排（Reflow）与重绘（Repaint）.md"};function e(h,s,o,p,r,k){return t(),a("div",null,[...s[0]||(s[0]=[n(`<h1 id="_07-渲染流程-布局、绘制与合成" tabindex="-1">07-渲染流程：布局、绘制与合成 <a class="header-anchor" href="#_07-渲染流程-布局、绘制与合成" aria-label="Permalink to &quot;07-渲染流程：布局、绘制与合成&quot;">​</a></h1><p>我们在“关键渲染路径”一章中已经了解了浏览器渲染页面的基本流程。当页面元素的样式或结构发生变化时，浏览器需要重新执行这个流程的一部分，这些后续的更新操作是影响前端性能的关键。</p><p>我们可以将这些更新操作按其对性能的影响，从高到低分为三个层次：<strong>布局 (Layout)</strong>、<strong>绘制 (Paint)</strong> 和 <strong>合成 (Composite)</strong>。性能优化的核心目标就是：<strong>尽可能地将操作限制在“合成”层，避免“绘制”，极力规避“布局”</strong>。</p><h2 id="_1-概念定义" tabindex="-1">1. 概念定义 <a class="header-anchor" href="#_1-概念定义" aria-label="Permalink to &quot;1. 概念定义&quot;">​</a></h2><h3 id="a-布局-layout-reflow" tabindex="-1">a. 布局 (Layout / Reflow) <a class="header-anchor" href="#a-布局-layout-reflow" aria-label="Permalink to &quot;a. 布局 (Layout / Reflow)&quot;">​</a></h3><ul><li><strong>定义</strong>：当 DOM 的<strong>几何属性</strong>（如宽度、高度、位置、边距等）发生变化，导致浏览器需要<strong>重新计算元素的几何信息</strong>，并重新构建页面布局的过程，就称为布局（也称重排 Reflow）。</li><li><strong>核心</strong>：任何会改变元素在文档流中<strong>位置</strong>和<strong>尺寸</strong>的操作，都可能触发布局。</li></ul><h3 id="b-绘制-paint-repaint" tabindex="-1">b. 绘制 (Paint / Repaint) <a class="header-anchor" href="#b-绘制-paint-repaint" aria-label="Permalink to &quot;b. 绘制 (Paint / Repaint)&quot;">​</a></h3><ul><li><strong>定义</strong>：当 DOM 的<strong>外观属性</strong>（如颜色、背景、阴影等）发生变化，但<strong>不影响其几何属性</strong>时，浏览器需要<strong>重新将元素绘制成像素</strong>的过程，就称为绘制（也称重绘 Repaint）。</li><li><strong>核心</strong>：只改变视觉效果，不改变几何布局。</li></ul><h3 id="c-合成-composite" tabindex="-1">c. 合成 (Composite) <a class="header-anchor" href="#c-合成-composite" aria-label="Permalink to &quot;c. 合成 (Composite)&quot;">​</a></h3><ul><li><strong>定义</strong>：当一个元素被提升到独立的<strong>图层 (Layer)</strong> 后，如果它发生的变更既不影响布局也不影响绘制（通常是 <code>transform</code> 和 <code>opacity</code> 属性的改变），浏览器就会跳过布局和绘制，直接在 GPU 中将多个图层合并，生成最终的屏幕图像。这个过程就是合成。</li><li><strong>核心</strong>：不涉及主线程的布局和绘制计算，性能开销最低。</li></ul><h2 id="_2-关系-性能开销金字塔" tabindex="-1">2. 关系：性能开销金字塔 <a class="header-anchor" href="#_2-关系-性能开销金字塔" aria-label="Permalink to &quot;2. 关系：性能开销金字塔&quot;">​</a></h2><p><strong>布局 (Layout) 的成本远高于绘制 (Paint)，而绘制的成本又远高于合成 (Composite)。</strong></p><p>它们的关系可以看作一个金字塔：</p><ol><li><strong>布局 (Layout)</strong>：如果你移动了房间里的一个大沙发，你需要重新规划整个房间的布局。</li><li><strong>绘制 (Paint)</strong>：布局改变后，沙发的新旧位置的地板都需要重新“画”出来。</li><li><strong>合成 (Composite)</strong>：如果你只是通过魔法让沙发悬浮起来并移动，它没有挤占任何新的地面空间，也无需重新粉刷地板，只需要最后把它和其他东西的影像合并起来即可。</li></ol><p>因此，<strong>一次布局必定会触发绘制和合成</strong>。反之，一次绘制不一定会触发布局，但通常会触发合成。而一次合成，则不会触发布局和绘制。</p><h2 id="_3-触发条件" tabindex="-1">3. 触发条件 <a class="header-anchor" href="#_3-触发条件" aria-label="Permalink to &quot;3. 触发条件&quot;">​</a></h2><ul><li><strong>查询实用工具</strong>：对于任何一个 CSS 属性，想知道修改它会触发哪个流程，可以查询 <strong>CSS Triggers</strong> (<a href="https://csstriggers.com/" target="_blank" rel="noreferrer">https://csstriggers.com/</a>) 网站。</li></ul><h3 id="a-触发布局-layout-的常见操作" tabindex="-1">a. 触发布局 (Layout) 的常见操作 <a class="header-anchor" href="#a-触发布局-layout-的常见操作" aria-label="Permalink to &quot;a. 触发布局 (Layout) 的常见操作&quot;">​</a></h3><ul><li><strong>页面首次渲染</strong>：这是最大规模的一次布局。</li><li><strong>添加或删除可见的 DOM 节点</strong>。</li><li><strong>元素尺寸或位置的改变</strong>：修改 <code>width</code>, <code>height</code>, <code>margin</code>, <code>padding</code>, <code>border</code>, <code>left</code>, <code>top</code> 等属性。</li><li><strong>内容改变</strong>：例如，文本数量的增减，导致元素尺寸变化。</li><li><strong>浏览器窗口尺寸改变（resize）</strong>。</li><li><strong>获取布局信息</strong>：这是一个非常关键且容易被忽略的点。当你读取某些需要即时计算的 DOM 属性时，浏览器为了返回最精确的值，会强制提前执行布局流程。 <ul><li>常见的属性包括：<code>offsetTop</code>, <code>offsetLeft</code>, <code>offsetWidth</code>, <code>offsetHeight</code>, <code>scrollTop</code>, <code>scrollLeft</code>, <code>scrollWidth</code>, <code>scrollHeight</code> 等。</li><li>调用 <code>getComputedStyle()</code> 或 <code>getBoundingClientRect()</code> 方法。</li></ul></li></ul><h3 id="b-仅触发绘制-paint-的常见操作" tabindex="-1">b. 仅触发绘制 (Paint) 的常见操作 <a class="header-anchor" href="#b-仅触发绘制-paint-的常见操作" aria-label="Permalink to &quot;b. 仅触发绘制 (Paint) 的常见操作&quot;">​</a></h3><ul><li>修改 <code>color</code>, <code>background-color</code>, <code>border-color</code>, <code>outline-style</code>, <code>visibility</code>, <code>text-decoration</code> 等不影响几何布局的样式。</li></ul><h3 id="c-仅触发合成-composite-的常见操作" tabindex="-1">c. 仅触发合成 (Composite) 的常见操作 <a class="header-anchor" href="#c-仅触发合成-composite-的常见操作" aria-label="Permalink to &quot;c. 仅触发合成 (Composite) 的常见操作&quot;">​</a></h3><ul><li>通常只有 <code>transform</code> 和 <code>opacity</code> 这两个属性的改变能被高度优化，仅触发合成。</li></ul><h2 id="_4-浏览器优化策略-渲染队列" tabindex="-1">4. 浏览器优化策略：渲染队列 <a class="header-anchor" href="#_4-浏览器优化策略-渲染队列" aria-label="Permalink to &quot;4. 浏览器优化策略：渲染队列&quot;">​</a></h2><p>考虑到频繁的重排和重绘会严重影响性能，现代浏览器实现了一套**渲染队列（Render Queue）**机制来进行优化。</p><ul><li><strong>机制</strong>：当你的代码触发了重排或重绘时，浏览器并不会立即执行，而是将这个“待处理”的变更放入一个队列中。浏览器会继续执行后续的 JS 代码。</li><li><strong>批量执行</strong>：浏览器会等到一个合适的时机（比如当前 JS 代码块执行完毕，或者队列中的变更积累到一定程度），然后<strong>一次性地</strong>将队列中的所有变更批量处理掉，这样多次的重排/重绘就有可能被合并为一次。</li></ul><p><strong>但是</strong>，正如上面提到的，如果你在代码中<strong>读取了需要即时计算的布局属性</strong>，就会破坏这个优化机制。浏览器为了给你返回最准确的值，不得不<strong>强制清空渲染队列</strong>，立即执行一次重排/重绘。</p><p><strong>一个反面教材：</strong></p><div class="language-javascript vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> elements</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> document.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">querySelectorAll</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;.box&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">elements.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">forEach</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">el</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">  // 每次循环都强制浏览器重排，因为要读取 offsetWidth</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  el.style.width </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> el.offsetWidth </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">+</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 10</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> +</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &#39;px&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">});</span></span></code></pre></div><p>这个循环有 N 个元素，就会导致 N 次布局，性能极差。</p><h2 id="_5-如何优化-向-合成层-看齐" tabindex="-1">5. 如何优化：向“合成层”看齐 <a class="header-anchor" href="#_5-如何优化-向-合成层-看齐" aria-label="Permalink to &quot;5. 如何优化：向“合成层”看齐&quot;">​</a></h2><ol><li><p><strong>样式集中改变</strong>：</p><ul><li>避免逐条修改样式，而是通过切换 CSS class 或使用 <code>cssText</code> 属性一次性修改。</li></ul><div class="language-javascript vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 不推荐</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">el.style.width </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &#39;100px&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">el.style.height </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &#39;100px&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">el.style.margin </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &#39;10px&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 推荐</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">el.className </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">+=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &#39; new-style&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">; </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 或者 el.classList.add(&#39;new-style&#39;)</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 或者</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">el.style.cssText </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &#39;width: 100px; height: 100px; margin: 10px;&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span></code></pre></div></li><li><p><strong>批量操作 DOM</strong>：</p><ul><li>当需要对 DOM 进行多次操作时，使用 <code>DocumentFragment</code> 作为临时容器，在内存中完成所有修改，然后一次性地将其添加到真实 DOM 中。</li><li>或者，可以先将元素 <code>display: none</code>，对其进行多次修改后，再恢复显示。</li></ul></li><li><p><strong>避免强制同步布局</strong>：</p><ul><li>在修改样式后，避免立即读取会触发强制同步布局的属性。可以先将需要读取的值缓存到一个变量中。</li></ul><div class="language-javascript vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 优化版</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> elements</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> document.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">querySelectorAll</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;.box&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> widths</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> [];</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">elements.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">forEach</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">el</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> widths.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">push</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(el.offsetWidth)); </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 先统一读</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">elements.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">forEach</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">((</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">el</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">i</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  el.style.width </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> widths[i] </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">+</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 10</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> +</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &#39;px&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">; </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 再统一写</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">});</span></span></code></pre></div></li><li><p><strong>拥抱合成层动画</strong>：</p><ul><li><strong>优先使用 <code>transform</code> 和 <code>opacity</code></strong>：实现位移、缩放、旋转和淡入淡出等动画时，优先使用这两个属性。</li><li><strong>原理回顾</strong>：正如我们在第一章所学，合成操作主要由<strong>合成器线程</strong>和 <strong>GPU</strong> 负责，它完全<strong>独立于主线程</strong>（JS 和布局/绘制所在线程）。因此，即使主线程繁忙，由 <code>transform</code> 和 <code>opacity</code> 驱动的动画依然能保持丝滑流畅。</li></ul></li><li><p><strong>提升为合成层 (<code>will-change</code>)</strong>：</p><ul><li>对于即将要进行频繁变换的元素，可以使用 <code>will-change</code> 属性（例如 <code>will-change: transform;</code>）提前“通知”浏览器。浏览器会为该元素创建一个独立的合成层，使其后续的变换开销更小。</li><li><strong>注意</strong>：不要滥用 <code>will-change</code>。为太多元素创建合成层会占用大量内存和 GPU 资源，反而可能降低性能。应只对关键的、复杂的动画元素使用。</li></ul></li></ol>`,32)])])}const c=i(l,[["render",e]]);export{g as __pageData,c as default};
