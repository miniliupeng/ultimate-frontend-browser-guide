import{_ as r,c as o,o as l,ae as n}from"./chunks/framework.DK_uz7nx.js";const S=JSON.parse('{"title":"12-HTTPS详解：让数据安全传输","description":"","frontmatter":{},"headers":[],"relativePath":"4.网络与存储/03-HTTPS详解：让数据安全传输.md","filePath":"4.网络与存储/03-HTTPS详解：让数据安全传输.md"}'),s={name:"4.网络与存储/03-HTTPS详解：让数据安全传输.md"};function i(g,t,a,e,T,u){return l(),o("div",null,[...t[0]||(t[0]=[n('<h1 id="_12-https详解-让数据安全传输" tabindex="-1">12-HTTPS详解：让数据安全传输 <a class="header-anchor" href="#_12-https详解-让数据安全传输" aria-label="Permalink to &quot;12-HTTPS详解：让数据安全传输&quot;">​</a></h1><p>HTTPS (HyperText Transfer Protocol Secure) 并非一个全新的应用层协议，它的核心思想是在 HTTP 之下增加一个安全层。因此，HTTPS = <strong>HTTP + SSL/TLS</strong>。这个安全层（SSL/TLS）负责对 HTTP 传输的数据进行加密、身份认证和完整性校验，从而保护通信内容不被窃听、篡改和冒充。</p><h2 id="_1-https-解决了什么问题" tabindex="-1">1. HTTPS 解决了什么问题？ <a class="header-anchor" href="#_1-https-解决了什么问题" aria-label="Permalink to &quot;1. HTTPS 解决了什么问题？&quot;">​</a></h2><p>传统的 HTTP 协议以<strong>明文</strong>方式传输数据，存在三大安全风险：</p><ol><li><strong>窃听风险 (Eavesdropping)</strong>：通信内容可能被中间人（如网络运营商、黑客）截获并直接读取。</li><li><strong>篡改风险 (Tampering)</strong>：中间人可以修改通信内容，例如在页面中插入广告或恶意脚本。</li><li><strong>冒充风险 (Impersonation)</strong>：无法验证通信对方的真实身份，可能遭遇“钓鱼”网站。</li></ol><p>HTTPS 通过以下三大核心机制来解决这些问题：</p><ul><li><strong>数据加密 (Encryption)</strong>：通过混合使用对称和非对称加密，确保传输的数据是加密的，即使被截获也无法解读。</li><li><strong>身份认证 (Authentication)</strong>：通过<strong>数字证书</strong>来验证服务器的身份，确保你正在与期望的服务器通信。</li><li><strong>数据完整性 (Integrity)</strong>：通过消息认证码（MAC）来校验数据，确保其在传输过程中未被篡改。</li></ul><h2 id="_2-核心技术-对称加密-vs-非对称加密" tabindex="-1">2. 核心技术：对称加密 vs 非对称加密 <a class="header-anchor" href="#_2-核心技术-对称加密-vs-非对称加密" aria-label="Permalink to &quot;2. 核心技术：对称加密 vs 非对称加密&quot;">​</a></h2><h3 id="a-对称加密" tabindex="-1">a. 对称加密 <a class="header-anchor" href="#a-对称加密" aria-label="Permalink to &quot;a. 对称加密&quot;">​</a></h3><ul><li><strong>原理</strong>：加密和解密使用<strong>同一个密钥</strong>。</li><li><strong>优点</strong>：加解密速度非常快，性能好。</li><li><strong>缺点</strong>：<strong>密钥分发困难</strong>。如何安全地将密钥告知通信的另一方是一个巨大的难题。如果在网络上明文传输密钥，密钥本身就会被窃听。</li><li><strong>常见算法</strong>：AES, DES。</li></ul><h3 id="b-非对称加密" tabindex="-1">b. 非对称加密 <a class="header-anchor" href="#b-非对称加密" aria-label="Permalink to &quot;b. 非对称加密&quot;">​</a></h3><ul><li><strong>原理</strong>：使用一对密钥：<strong>公钥 (Public Key)</strong> 和 <strong>私钥 (Private Key)</strong>。 <ul><li>公钥是公开的，任何人都可以获取。</li><li>私钥是保密的，只有持有者知道。</li><li>用公钥加密的数据，只能用对应的私钥才能解密。</li><li>用私钥加密的数据（数字签名），可以用公钥来验证。</li></ul></li><li><strong>优点</strong>：解决了密钥分发问题。客户端可以用服务器的公钥加密数据，只有服务器用自己的私钥才能解开，无需在网络上传输私钥。</li><li><strong>缺点</strong>：加解密速度非常慢，性能开销巨大。</li><li><strong>常见算法</strong>：RSA, ECC。</li></ul><h2 id="_3-tls-握手过程-https-的精华" tabindex="-1">3. TLS 握手过程：HTTPS 的精华 <a class="header-anchor" href="#_3-tls-握手过程-https-的精华" aria-label="Permalink to &quot;3. TLS 握手过程：HTTPS 的精华&quot;">​</a></h2><p>由于对称加密性能好但密钥分发困难，非对称加密解决了密钥分发问题但性能差，HTTPS 巧妙地将两者结合，其核心就在于 <strong>TLS 握手</strong>过程。</p><p>TLS 握手的<strong>最终目的</strong>是：<strong>安全地协商出一个用于后续通信的对称加密密钥</strong>。</p><p>以下是 TLS 1.2 握手的简化流程：</p><ol><li><p><strong>客户端 Hello (Client Hello)</strong></p><ul><li>客户端向服务器发送一个“问候”，包含以下信息： <ul><li>客户端支持的 <strong>TLS 版本号</strong>。</li><li>一个<strong>客户端生成的随机数 (Random 1)</strong>。</li><li>客户端支持的<strong>加密算法套件</strong>列表。</li></ul></li></ul></li><li><p><strong>服务器 Hello (Server Hello)</strong></p><ul><li>服务器收到后，也返回一个“问候”，包含： <ul><li>确认使用的 <strong>TLS 版本号</strong>。</li><li>一个<strong>服务器生成的随机数 (Random 2)</strong>。</li><li>从客户端列表中选定的一个<strong>加密算法套件</strong>。</li></ul></li></ul></li><li><p><strong>服务器证书 (Server Certificate)</strong></p><ul><li>服务器将其<strong>数字证书</strong>发送给客户端。这个证书包含了服务器的<strong>公钥</strong>，以及由权威的 <strong>CA (Certificate Authority, 证书颁发机构)</strong> 颁发的数字签名。</li></ul></li><li><p><strong>客户端验证证书 &amp; 生成预主密钥</strong></p><ul><li>客户端收到证书后，会<strong>验证其有效性</strong>： <ul><li>检查证书是否过期。</li><li>检查证书的域名是否与当前访问的域名匹配。</li><li><strong>验证 CA 签名</strong>：这一步是信任链的核心。CA 机构会先对服务器证书的关键信息（如域名、公钥）进行哈希运算得到一个摘要，然后用 <strong>CA 自己的私钥</strong>对这个摘要进行加密，这个加密后的结果就是“数字签名”。客户端则用内置于操作系统或浏览器中的 <strong>CA 公钥</strong>来解密这个签名，如果能成功解密并与自己重新计算的哈希值匹配，就证明了证书的真实性与完整性。</li></ul></li><li>证书验证通过后，客户端<strong>生成第三个随机数</strong>，称为<strong>预主密钥 (Pre-Master Secret)</strong>。</li><li>客户端使用从服务器证书中获取的<strong>服务器公钥</strong>，对这个<strong>预主密钥</strong>进行<strong>非对称加密</strong>。</li></ul></li><li><p><strong>客户端密钥交换 (Client Key Exchange)</strong></p><ul><li>客户端将<strong>加密后的预主密钥</strong>发送给服务器。</li></ul></li><li><p><strong>客户端完成 &amp; 服务器解密</strong></p><ul><li>客户端发送一个“加密通信切换通知”，表示自己后续将使用协商好的密钥进行加密通信。</li><li>服务器收到加密的预主密钥后，使用自己的<strong>私钥</strong>进行<strong>非对称解密</strong>，获取到预主密钥。</li></ul></li><li><p><strong>生成会话密钥</strong></p><ul><li>现在，<strong>客户端和服务器双方都拥有了相同的三个随机数</strong>：Random 1, Random 2, Pre-Master Secret。</li><li>双方使用<strong>相同的算法</strong>，将这三个随机数混合生成一个<strong>最终的、独一无二的对称加密密钥</strong>，这个密钥被称为<strong>会话密钥 (Session Key)</strong>。</li></ul></li><li><p><strong>服务器完成</strong></p><ul><li>服务器也发送一个“加密通信切换通知”。</li><li>至此，TLS 握手完成。</li></ul></li></ol><h2 id="_4-握手后的通信" tabindex="-1">4. 握手后的通信 <a class="header-anchor" href="#_4-握手后的通信" aria-label="Permalink to &quot;4. 握手后的通信&quot;">​</a></h2><p>握手过程结束后，后续所有的 HTTP 数据都将使用这个<strong>会话密钥</strong>进行<strong>对称加密</strong>传输。由于对称加密的性能非常高，因此 HTTPS 在握手完成后的通信效率得到了保证。</p><p>为了保证<strong>数据完整性</strong>，通信双方还会使用协商好的<strong>消息认证码（MAC）算法</strong>（如 HMAC），为每一条要发送的加密消息计算出一个“摘要”或“签名”并附加在消息尾部。接收方在解密后，会用同样的密钥和算法重新计算摘要，如果两个摘要一致，就证明数据在传输过程中没有被篡改。</p><h2 id="_5-tls-1-3-的演进-更快、更安全" tabindex="-1">5. TLS 1.3 的演进：更快、更安全 <a class="header-anchor" href="#_5-tls-1-3-的演进-更快、更安全" aria-label="Permalink to &quot;5. TLS 1.3 的演进：更快、更安全&quot;">​</a></h2><p>目前业界主流已从 TLS 1.2 过渡到 <strong>TLS 1.3</strong>，它在性能和安全性上都有了巨大提升。</p><ul><li><strong>性能提升 (1-RTT 握手)</strong>：TLS 1.3 将握手过程从 TLS 1.2 的 2-RTT（2个往返时间）优化到了 <strong>1-RTT</strong>。它通过在客户端的第一个 <code>ClientHello</code> 消息中就带上密钥交换所需的参数，大幅减少了客户端和服务器之间的通信回合，显著降低了连接建立的延迟。</li><li><strong>安全性增强</strong>：废弃了一系列过时和不安全的加密算法套件（如 RSA 密钥交换、SHA-1 等），并对握手过程中的更多消息进行了加密，提供了更好的前向保密性。</li></ul><h2 id="总结" tabindex="-1">总结 <a class="header-anchor" href="#总结" aria-label="Permalink to &quot;总结&quot;">​</a></h2><ul><li>HTTPS 通过 <strong>SSL/TLS</strong> 安全层解决了 HTTP 的窃听、篡改和冒充风险。</li><li>它巧妙地结合了<strong>非对称加密</strong>和<strong>对称加密</strong>的优点。</li><li>在 <strong>TLS 握手</strong>阶段，使用<strong>非对称加密</strong>来<strong>安全地协商和交换</strong>生成<strong>对称加密密钥</strong>所需的材料。</li><li><strong>数字证书 (CA)</strong> 在握手过程中起到了<strong>身份认证</strong>的关键作用，确保了服务器公钥的真实性。</li><li>握手完成后，后续的通信全部使用高效的<strong>对称加密</strong>来进行，以保证性能。</li></ul>',25)])])}const h=r(s,[["render",i]]);export{S as __pageData,h as default};
