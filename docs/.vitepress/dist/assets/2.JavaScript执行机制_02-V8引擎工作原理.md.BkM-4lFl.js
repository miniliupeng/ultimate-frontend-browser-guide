import{_ as r,c as t,o as n,ae as a}from"./chunks/framework.DK_uz7nx.js";const u=JSON.parse('{"title":"05-V8引擎工作原理","description":"","frontmatter":{},"headers":[],"relativePath":"2.JavaScript执行机制/02-V8引擎工作原理.md","filePath":"2.JavaScript执行机制/02-V8引擎工作原理.md"}'),e={name:"2.JavaScript执行机制/02-V8引擎工作原理.md"};function i(s,o,l,g,c,d){return n(),t("div",null,[...o[0]||(o[0]=[a('<h1 id="_05-v8引擎工作原理" tabindex="-1">05-V8引擎工作原理 <a class="header-anchor" href="#_05-v8引擎工作原理" aria-label="Permalink to &quot;05-V8引擎工作原理&quot;">​</a></h1><p>V8 是由 Google 开发的一款开源、高性能的 JavaScript 和 WebAssembly 引擎，用 C++ 编写。它是 Chrome 浏览器和 Node.js 的核心组成部分。V8 的主要任务就是将我们编写的 JavaScript 代码编译成高效的机器码，然后执行它。</p><p>V8 的工作流程并非简单地解释一行执行一行，而是一个高度优化的编译管线，其核心在于<strong>即时编译（Just-In-Time, JIT）</strong> 技术。</p><h2 id="_1-v8-的核心流程" tabindex="-1">1. V8 的核心流程 <a class="header-anchor" href="#_1-v8-的核心流程" aria-label="Permalink to &quot;1. V8 的核心流程&quot;">​</a></h2><p>V8 执行 JavaScript 代码的整个过程可以概括为以下几个步骤：</p><p><code>JavaScript 源码</code> → <code>解析器 (Parser)</code> → <code>抽象语法树 (AST)</code> → <code>解释器 (Ignition)</code> → <code>字节码 (Bytecode)</code> → <code>分析探针 (Profiler)</code> → <code>优化编译器 (TurboFan)</code> → <code>优化的机器码</code></p><h3 id="a-解析器-parser" tabindex="-1">a. 解析器 (Parser) <a class="header-anchor" href="#a-解析器-parser" aria-label="Permalink to &quot;a. 解析器 (Parser)&quot;">​</a></h3><ul><li><strong>职责</strong>：当 V8 引擎拿到 JavaScript 源码后，解析器会对其进行<strong>词法分析</strong>和<strong>语法分析</strong>。 <ul><li><strong>词法分析 (Lexical Analysis)</strong>：将字符串形式的代码分解成一个个不可再分的、有意义的代码块，称为<strong>词法单元 (Token)</strong>。例如，<code>var name = &quot;v8&quot;;</code> 会被分解成 <code>var</code>, <code>name</code>, <code>=</code>, <code>&quot;v8&quot;</code>, <code>;</code> 等。</li><li><strong>语法分析 (Syntax Analysis)</strong>：在词法分析的基础上，将词法单元转换成一个能够表达程序语法结构的树状结构，这个结构就是<strong>抽象语法树 (Abstract Syntax Tree, AST)</strong>。同时，这个阶段会检查语法错误。</li><li><strong>预解析 (Pre-parsing)</strong>：V8 在此阶段还有一个重要的优化——<strong>惰性解析 (Lazy Parsing)</strong>。如果解析器遇到一个函数定义，它并不会立即去完整地解析函数体内的代码。相反，它只会解析函数签名和外部结构，并将函数体标记为待解析。只有当这个函数<strong>真正被调用</strong>时，V8 才会回过头来对函数体进行完整的解析和编译。这极大地减少了首次加载和解析大型JS文件的时间。</li></ul></li></ul><h3 id="b-抽象语法树-ast" tabindex="-1">b. 抽象语法树 (AST) <a class="header-anchor" href="#b-抽象语法树-ast" aria-label="Permalink to &quot;b. 抽象语法树 (AST)&quot;">​</a></h3><p>AST 是源代码语法结构的树状表示，它不关心代码的具体写法（例如分号、空格），只关心其核心的语法结构。AST 是后续所有处理步骤的基础。</p><h3 id="c-解释器-ignition" tabindex="-1">c. 解释器 (Ignition) <a class="header-anchor" href="#c-解释器-ignition" aria-label="Permalink to &quot;c. 解释器 (Ignition)&quot;">​</a></h3><p>在 V8 的现代架构中，AST 会被送入<strong>解释器 Ignition</strong>。</p><ul><li><strong>职责</strong>：Ignition 会将 AST 转换成一种体积更小、更易于执行的<strong>字节码 (Bytecode)</strong>。</li><li><strong>优势</strong>： <ul><li><strong>快速启动</strong>：相比于直接编译成机器码，生成字节码的速度非常快，这减少了代码的启动时间。</li><li><strong>跨平台</strong>：字节码是一种中间代码，不直接与特定 CPU 架构绑定，使得 V8 的移植性更好。</li><li><strong>内存优化</strong>：字节码相比 AST 和机器码，占用的内存更少。</li><li><strong>作为反优化的安全点</strong>：当优化的机器码因为假设失败而需要被废弃时，程序可以安全、快速地回退到执行字节码，而无需重新从源码开始解析。</li></ul></li></ul><p>解释器会逐条执行字节码。这个过程足以让代码运行起来，但对于频繁执行的热点代码，其性能并不是最优的。</p><h3 id="c-快照-snapshot" tabindex="-1">c. 快照 (Snapshot) <a class="header-anchor" href="#c-快照-snapshot" aria-label="Permalink to &quot;c. 快照 (Snapshot)&quot;">​</a></h3><p>为了进一步提升启动速度，V8 还使用了<strong>快照技术</strong>。V8 可以将某一个时间点的堆内存状态（包含了编译好的字节码、内置对象等）序列化成一个“快照”文件。当浏览器或 Node.js 启动时，可以直接反序列化这个快照来恢复内存状态，从而<strong>跳过</strong>了对内置 JavaScript 源码的解析和编译过程，极大地加快了引擎的初始化速度。</p><h2 id="_2-即时编译-jit-与优化" tabindex="-1">2. 即时编译 (JIT) 与优化 <a class="header-anchor" href="#_2-即时编译-jit-与优化" aria-label="Permalink to &quot;2. 即时编译 (JIT) 与优化&quot;">​</a></h2><p>为了解决解释执行的性能问题，V8 引入了 JIT 技术。</p><h3 id="d-分析探针-profiler" tabindex="-1">d. 分析探针 (Profiler) <a class="header-anchor" href="#d-分析探针-profiler" aria-label="Permalink to &quot;d. 分析探针 (Profiler)&quot;">​</a></h3><p>在 Ignition 解释执行字节码的同时，一个内置的<strong>分析探针 (Profiler)</strong> 会监控代码的执行情况。</p><ul><li><strong>职责</strong>：Profiler 负责收集代码运行时的信息，例如一个函数被调用了多少次、函数参数的类型等。</li><li><strong>目的</strong>：识别出那些被频繁执行的<strong>热点代码 (Hot Code)</strong>。</li></ul><h3 id="e-优化编译器-turbofan" tabindex="-1">e. 优化编译器 (TurboFan) <a class="header-anchor" href="#e-优化编译器-turbofan" aria-label="Permalink to &quot;e. 优化编译器 (TurboFan)&quot;">​</a></h3><p>当 Profiler 识别出一段代码是热点代码后，V8 就会启动<strong>优化编译器 TurboFan</strong>。</p><ul><li><strong>职责</strong>：TurboFan 会将这段热点代码的<strong>字节码</strong>，连同 Profiler 收集到的类型信息，一起作为输入，将其编译成<strong>高度优化的机器码</strong>。</li><li><strong>优化策略</strong>：TurboFan 会进行很多激进的优化，例如： <ul><li><strong>类型特化</strong>：如果 Profiler 发现一个函数每次调用时，传入的参数都是数字类型，TurboFan 就会假设这个函数只处理数字，并生成专门针对数字操作的、更快的机器码。</li><li><strong>内联 (Inlining)</strong>：将函数调用处的代码直接替换为函数体本身，减少函数调用的开销。</li></ul></li></ul><h3 id="f-反优化-deoptimization" tabindex="-1">f. 反优化 (Deoptimization) <a class="header-anchor" href="#f-反优化-deoptimization" aria-label="Permalink to &quot;f. 反优化 (Deoptimization)&quot;">​</a></h3><p>TurboFan 的优化是建立在“假设”之上的。如果某段热点代码在未来的执行中，不满足之前的假设（例如，之前一直传入数字的函数，突然被传入了一个字符串），那么这块优化的机器码就不能再使用了。</p><p>这时，V8 会执行<strong>反优化</strong>操作，抛弃掉之前生成的优化机器码，回退到执行解释器的字节码版本。这个过程保证了代码执行的正确性。如果后续这段代码再次成为热点，V8 会尝试重新进行优化。</p><h2 id="_3-内存管理" tabindex="-1">3. 内存管理 <a class="header-anchor" href="#_3-内存管理" aria-label="Permalink to &quot;3. 内存管理&quot;">​</a></h2><p>V8 使用<strong>堆 (Heap)</strong> 和<strong>栈 (Stack)</strong> 来管理内存。代码在运行时需要内存来存储数据，这部分内存就被分为这两个主要区域。</p><h3 id="a-栈内存-stack" tabindex="-1">a. 栈内存 (Stack) <a class="header-anchor" href="#a-栈内存-stack" aria-label="Permalink to &quot;a. 栈内存 (Stack)&quot;">​</a></h3><ul><li><strong>结构</strong>：一种后进先出（LIFO）的数据结构。</li><li><strong>存储内容</strong>： <ul><li><strong>原始类型 (Primitive Types)</strong> 的值（如 <code>Number</code>, <code>Boolean</code>, <code>null</code>, <code>undefined</code>）。</li><li><strong>引用类型 (Reference Types)</strong> 的 <strong>引用地址（指针）</strong>。</li><li>函数的执行上下文（包括作用域链、变量等）。</li></ul></li><li><strong>特点</strong>： <ul><li><strong>大小固定</strong>：在编译时或函数调用时，大小就已经确定。</li><li><strong>访问速度快</strong>：内存是连续分配的，通过指针移动即可访问，速度非常快。</li><li><strong>自动管理</strong>：当一个函数执行完毕，它的执行上下文会从栈中弹出，其中所有的变量内存都会被自动释放。</li></ul></li></ul><h3 id="b-堆内存-heap" tabindex="-1">b. 堆内存 (Heap) <a class="header-anchor" href="#b-堆内存-heap" aria-label="Permalink to &quot;b. 堆内存 (Heap)&quot;">​</a></h3><ul><li><strong>结构</strong>：一种树状的、无序的数据结构。可以把它想象成一个杂乱的仓库。</li><li><strong>存储内容</strong>： <ul><li><strong>引用类型 (Reference Types)</strong> 的 <strong>实际对象</strong>。比如 <code>Object</code>、<code>Array</code>、<code>Function</code> 等。</li></ul></li><li><strong>特点</strong>： <ul><li><strong>大小不固定</strong>：可以动态地分配和释放内存，大小是可变的。</li><li><strong>访问速度慢</strong>：因为内存是非连续的，需要先从栈中读取引用地址，再根据地址去堆中找到对应的对象。</li><li><strong>自动管理</strong>：内存的分配是动态的，释放则依赖于<strong>垃圾回收机制（GC）</strong>。V8 的 GC 主要就是针对堆内存。</li></ul></li></ul><p>V8 的堆内存是<strong>分代</strong>的，这是其垃圾回收策略的基础。堆内存主要被划分为两个区域：</p><ol><li><p><strong>新生代 (New Space)</strong></p><ul><li><strong>特点</strong>：空间较小（通常只有几 MB 到几十 MB），专门用于存放<strong>存活时间短</strong>的“年轻”对象。</li><li><strong>垃圾回收</strong>：新生代的垃圾回收非常频繁，采用一种称为 <strong>Scavenge</strong> 的算法，它速度快，但会牺牲一些空间。新生代内部又被分为两个等大的空间：From-Space 和 To-Space。</li></ul></li><li><p><strong>老生代 (Old Space)</strong></p><ul><li><strong>特点</strong>：空间较大，用于存放<strong>存活时间长</strong>的“年老”对象，或者从新生代“晋升”过来的对象。</li><li><strong>晋升条件</strong>：一个对象如果经过了多轮新生代的垃圾回收后依然存活，就会被移动到老生代。</li><li><strong>垃圾回收</strong>：老生代的垃圾回收频率较低，但执行起来更耗时。它主要采用 <strong>Mark-Sweep（标记-清除）</strong> 和 <strong>Mark-Compact（标记-整理）</strong> 的算法。</li></ul></li></ol><p>这种分代的设计，使得 V8 可以针对不同生命周期的对象采用不同的回收策略，从而极大地提升了垃圾回收的效率。</p><h2 id="总结" tabindex="-1">总结 <a class="header-anchor" href="#总结" aria-label="Permalink to &quot;总结&quot;">​</a></h2><p>V8 的工作原理是一个<strong>解释执行</strong>和<strong>编译执行</strong>相结合的混合模型：</p><ol><li><strong>快速启动</strong>：通过解析器和解释器（Ignition）将代码快速转换为字节码并执行，保证了应用的启动速度。</li><li><strong>性能优化</strong>：通过分析探针（Profiler）找出热点代码，再由优化编译器（TurboFan）将其编译成高效的机器码，以获得极致的运行性能。</li><li><strong>动态调整</strong>：通过反优化机制来应对代码在运行时可能发生的类型变化，保证了灵活性和正确性。</li></ol><p>这种精巧的设计，使得 JavaScript 这样一门动态语言，也能在 V8 引擎的加持下获得接近原生编译语言的运行效率。</p>',40)])])}const h=r(e,[["render",i]]);export{u as __pageData,h as default};
