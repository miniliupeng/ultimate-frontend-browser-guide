import{_ as t,c as e,o as r,ae as n}from"./chunks/framework.DK_uz7nx.js";const S=JSON.parse('{"title":"03-关键渲染路径（Critical Rendering Path）","description":"","frontmatter":{},"headers":[],"relativePath":"1.浏览器工作原理/03-关键渲染路径（Critical Rendering Path）.md","filePath":"1.浏览器工作原理/03-关键渲染路径（Critical Rendering Path）.md"}'),a={name:"1.浏览器工作原理/03-关键渲染路径（Critical Rendering Path）.md"};function l(i,o,s,c,d,g){return r(),e("div",null,[...o[0]||(o[0]=[n(`<h1 id="_03-关键渲染路径-critical-rendering-path" tabindex="-1">03-关键渲染路径（Critical Rendering Path） <a class="header-anchor" href="#_03-关键渲染路径-critical-rendering-path" aria-label="Permalink to &quot;03-关键渲染路径（Critical Rendering Path）&quot;">​</a></h1><p>关键渲染路径（CRP）是指浏览器从接收到 HTML、CSS 和 JavaScript 资源开始，到最终将它们渲染成像素显示在屏幕上所经历的一系列步骤。<strong>优化关键渲染路径是提升页面首屏加载速度的核心</strong>。</p><p>我们可以将 CRP 的核心依赖关系总结如下：</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>HTML -&gt; DOM</span></span>
<span class="line"><span>CSS -&gt; CSSOM</span></span>
<span class="line"><span>(DOM + CSSOM) -&gt; Render Tree</span></span>
<span class="line"><span>Render Tree -&gt; Layout -&gt; Paint -&gt; Composite</span></span></code></pre></div><p>每个阶段都依赖于前一阶段的完成，优化 CRP 的本质就是加速这个链条的执行。</p><h2 id="_1-构建对象模型-object-model" tabindex="-1">1. 构建对象模型 (Object Model) <a class="header-anchor" href="#_1-构建对象模型-object-model" aria-label="Permalink to &quot;1. 构建对象模型 (Object Model)&quot;">​</a></h2><p>当渲染进程接收到导航确认，开始解析数据时，主线程首先会将 HTML 和 CSS 文本转换成浏览器能够理解的内部数据结构。</p><h3 id="a-构建-dom-树-document-object-model" tabindex="-1">a. 构建 DOM 树 (Document Object Model) <a class="header-anchor" href="#a-构建-dom-树-document-object-model" aria-label="Permalink to &quot;a. 构建 DOM 树 (Document Object Model)&quot;">​</a></h3><ul><li><strong>输入</strong>：HTML 文本。</li><li><strong>过程</strong>：UI 渲染线程自上而下解析 HTML 标记，逐个生成节点对象，并根据它们之间的嵌套关系构建起一个树状结构。</li><li><strong>输出</strong>：DOM 树。</li></ul><p>这个过程是<strong>渐进式</strong>的。浏览器不需要等到整个 HTML 文档下载完毕才开始解析和构建 DOM，而是一边接收数据一边进行。</p><h3 id="b-构建-cssom-树-css-object-model" tabindex="-1">b. 构建 CSSOM 树 (CSS Object Model) <a class="header-anchor" href="#b-构建-cssom-树-css-object-model" aria-label="Permalink to &quot;b. 构建 CSSOM 树 (CSS Object Model)&quot;">​</a></h3><ul><li><strong>输入</strong>：CSS 代码（来自 <code>&lt;link&gt;</code> 标签、<code>&lt;style&gt;</code> 标签或内联样式）。</li><li><strong>过程</strong>：UI 渲染线程解析 CSS 规则。与 HTML 不同，CSS 的解析<strong>不是渐进式</strong>的，因为后面的规则可能会覆盖前面的规则。浏览器需要下载并解析完所有的 CSS 代码，才能确认每个 DOM 节点的最终样式。</li><li><strong>输出</strong>：CSSOM 树。</li></ul><p><strong>注意：CSSOM 会阻塞渲染和 JS 执行。</strong></p><ul><li><strong>阻塞渲染</strong>：在 CSSOM 树完全构建完成之前，浏览器不会进入后续的渲染树构建、布局和绘制阶段。这就是为什么我们通常建议将 CSS <code>&lt;link&gt;</code> 标签放在 HTML 的 <code>&lt;head&gt;</code> 部分，以便浏览器能尽早发现并下载 CSS，从而缩短阻塞时间。</li><li><strong>阻塞 JS 执行</strong>：如果 JS 在执行时试图查询节点的样式（例如 <code>getComputedStyle</code>），它必须等待所有 CSS 都被下载和解析完毕。因此，浏览器会推迟脚本执行，直到 CSSOM 构建完成。</li></ul><h2 id="_2-javascript-的影响-解析器阻塞" tabindex="-1">2. JavaScript 的影响：解析器阻塞 <a class="header-anchor" href="#_2-javascript-的影响-解析器阻塞" aria-label="Permalink to &quot;2. JavaScript 的影响：解析器阻塞&quot;">​</a></h2><p>当 HTML 解析器在构建 DOM 的过程中遇到 <code>&lt;script&gt;</code> 标签时，情况会变得特殊。</p><ul><li><strong>默认行为（无 <code>async</code> 或 <code>defer</code>）</strong>： <ol><li>HTML 解析暂停。</li><li>浏览器开始下载 JavaScript 文件。</li><li>下载完成后，JS 引擎线程立即执行该脚本。</li><li>脚本执行完毕后，HTML 解析器才恢复工作。</li></ol></li></ul><p><strong>为什么 JS 会阻塞 DOM 构建？</strong> 因为 JavaScript 可以通过 <code>document.write()</code> 或其他 DOM API 来修改 DOM 结构。浏览器无法预知脚本会做什么，所以它必须停下来，等待脚本执行完毕，以确保后续的 DOM 构建是基于一个确定的、未被修改的状态。</p><p><strong>JS 同样会被 CSSOM 阻塞</strong>。如上所述，如果脚本试图查询一个节点的样式，它必须等待所有 CSS 都被下载和解析完毕。因此，JS 的执行也依赖于 CSSOM 的构建。</p><p><strong>优化方案：<code>async</code> 和 <code>defer</code></strong> 为了减少 JS 阻塞带来的性能影响，我们可以使用这两个属性：</p><ul><li><strong><code>async</code></strong>：脚本的下载和 HTML 解析可以并行进行。一旦脚本下载完成，HTML 解析会立即暂停，开始执行脚本。执行完毕后，再恢复 HTML 解析。它不保证脚本的执行顺序。</li><li><strong><code>defer</code></strong>：脚本的下载和 HTML 解析也可以并行进行。但脚本的执行会被推迟到整个 HTML 文档解析完毕（DOM 构建完成）之后，<code>DOMContentLoaded</code> 事件触发之前。它会按照脚本在 HTML 中出现的顺序来执行。</li></ul><h2 id="_3-构建渲染树-render-tree" tabindex="-1">3. 构建渲染树 (Render Tree) <a class="header-anchor" href="#_3-构建渲染树-render-tree" aria-label="Permalink to &quot;3. 构建渲染树 (Render Tree)&quot;">​</a></h2><p>当浏览器同时拥有了 DOM 树和 CSSOM 树之后，就可以将它们结合起来，创建<strong>渲染树</strong>。</p><ul><li><strong>过程</strong>：浏览器会从 DOM 树的根节点开始遍历，对于每个<strong>可见</strong>的节点，找到它在 CSSOM 树中对应的样式规则，并应用它们。</li><li><strong>关键点</strong>：渲染树只包含页面上实际可见的元素。像 <code>&lt;head&gt;</code>、<code>&lt;script&gt;</code> 标签，或者设置了 <code>display: none;</code> 的节点，都不会被包含在渲染树中。而 <code>visibility: hidden;</code> 的节点虽然不可见，但仍然占据布局空间，所以会包含在渲染树里。</li></ul><h2 id="_4-布局-layout-reflow" tabindex="-1">4. 布局 (Layout / Reflow) <a class="header-anchor" href="#_4-布局-layout-reflow" aria-label="Permalink to &quot;4. 布局 (Layout / Reflow)&quot;">​</a></h2><p>有了渲染树，浏览器就知道了哪些节点需要被渲染以及它们的样式，但还不知道它们在屏幕上的确切位置和大小。<strong>布局</strong>阶段就是为了计算这些几何信息。</p><ul><li><strong>过程</strong>：浏览器从渲染树的根节点开始，递归地计算每个节点的几何信息（位置、尺寸）。</li><li><strong>输出</strong>：一个包含了所有元素精确位置和大小信息的“盒子模型”。</li></ul><p>页面上的任何一个微小的改动，比如窗口大小变化、元素尺寸变化、内容改变导致的高度变化等，都可能引发整个或部分渲染树的<strong>重新布局</strong>，这个过程也叫<strong>回流 (Reflow)</strong>。回流是一个非常耗费性能的操作。</p><h2 id="_5-绘制-paint" tabindex="-1">5. 绘制 (Paint) <a class="header-anchor" href="#_5-绘制-paint" aria-label="Permalink to &quot;5. 绘制 (Paint)&quot;">​</a></h2><p>布局阶段完成后，浏览器知道了每个元素的几何信息和样式。<strong>绘制</strong>阶段就是将这些信息转换成屏幕上的实际像素。</p><ul><li><strong>过程</strong>：UI 渲染线程会遍历渲染树，调用图形库的 API，将每个节点的背景、颜色、边框、文字等内容绘制出来，生成一系列的绘制指令（Painting Records）。</li></ul><p>当元素的样式改变不影响其几何位置时（例如 <code>background-color</code>, <code>color</code> 的改变），浏览器会跳过布局阶段，直接进入绘制阶段。这个过程称为<strong>重绘 (Repaint)</strong>。</p><h2 id="_6-合成-compositing" tabindex="-1">6. 合成 (Compositing) <a class="header-anchor" href="#_6-合成-compositing" aria-label="Permalink to &quot;6. 合成 (Compositing)&quot;">​</a></h2><p>在绘制之后，为了进一步提升性能，现代浏览器引入了<strong>图层 (Layer)</strong> 和<strong>合成</strong>机制。这部分工作主要由<strong>合成器线程</strong>和 <strong>GPU 进程</strong>协作完成。</p><ul><li><strong>图层提升 (Layer Promotion)</strong>：在布局和绘制之后，主线程会识别出页面的某些部分（例如有 <code>transform: translateZ(0)</code> 或 <code>will-change</code> 属性的元素），并将它们提升为独立的图层。这个过程也被称为<strong>显式合成</strong>。 <ul><li><strong>隐式合成</strong>：此外，如果一个普通元素覆盖在一个合成层之上，那么这个普通元素也会被“隐式”地提升为一个新图层，以保证正确的层叠顺序。过度使用可能导致“图层爆炸”，消耗大量内存。</li></ul></li><li><strong>栅格化 (Rasterization)</strong>：主线程将图层信息提交给合成器线程。<strong>合成器线程</strong>会调度其内部的<strong>光栅线程</strong>，将每个图层的绘制指令列表转换成位图（Bitmap）。这个过程通常在 GPU 中进行以加速处理。</li><li><strong>合成与显示</strong>：光栅化完成后，合成器线程会生成一个“合成器帧”，并通过 IPC 将其发送给 <strong>GPU 进程</strong>。GPU 进程负责将所有这些图层合成为一个完整的页面，然后显示在屏幕上。</li></ul><p><strong>合成的优势</strong>：对于那些只影响图层变换（如 <code>transform</code>, <code>opacity</code>）的动画，浏览器可以跳过主线程的布局和绘制，直接在合成器线程和 GPU 中进行处理。这极大地提高了动画的流畅度，因为它完全脱离了主线程的负担。</p><h2 id="_7-优化-crp-的最佳实践" tabindex="-1">7. 优化 CRP 的最佳实践 <a class="header-anchor" href="#_7-优化-crp-的最佳实践" aria-label="Permalink to &quot;7. 优化 CRP 的最佳实践&quot;">​</a></h2><ul><li><strong>减少关键资源的数量和大小</strong>：尽可能地压缩、合并 CSS 和 JS 文件，移除未使用的代码。</li><li><strong>优化关键资源的加载顺序</strong>： <ul><li>将 CSS <code>&lt;link&gt;</code> 标签放在文档的 <code>&lt;head&gt;</code> 中，尽早开始下载。</li><li>将阻塞渲染的 <code>&lt;script&gt;</code> 标签（特别是未使用 <code>async</code> 或 <code>defer</code> 的）放在 <code>&lt;body&gt;</code> 的末尾。</li></ul></li><li><strong>避免阻塞渲染</strong>： <ul><li>对非关键的 CSS（如打印样式、非首屏样式）使用 <code>media</code> 属性进行标记，或异步加载。</li><li>对 JavaScript 使用 <code>async</code> 或 <code>defer</code> 属性，消除对 DOM 构建的阻塞。</li></ul></li><li><strong>利用合成层优化动画和交互</strong>：对于需要频繁变化的元素，使用 <code>will-change</code> 或 <code>transform: translateZ(0)</code> 将其提升到合成层，多使用 <code>transform</code> 和 <code>opacity</code> 来实现动画，以利用 GPU 加速。</li></ul>`,38)])])}const h=t(a,[["render",l]]);export{S as __pageData,h as default};
