import{_ as s,c as e,o as a,ae as t}from"./chunks/framework.DK_uz7nx.js";const k=JSON.parse('{"title":"07-JS核心理论：执行上下文、作用域链与闭包","description":"","frontmatter":{},"headers":[],"relativePath":"2.JavaScript执行机制/04-JS核心理论：执行上下文、作用域链与闭包.md","filePath":"2.JavaScript执行机制/04-JS核心理论：执行上下文、作用域链与闭包.md"}'),o={name:"2.JavaScript执行机制/04-JS核心理论：执行上下文、作用域链与闭包.md"};function n(l,i,d,r,c,h){return a(),e("div",null,[...i[0]||(i[0]=[t(`<h1 id="_07-js核心理论-执行上下文、作用域链与闭包" tabindex="-1">07-JS核心理论：执行上下文、作用域链与闭包 <a class="header-anchor" href="#_07-js核心理论-执行上下文、作用域链与闭包" aria-label="Permalink to &quot;07-JS核心理论：执行上下文、作用域链与闭包&quot;">​</a></h1><p>要真正掌握 JavaScript，就必须理解其代码在执行时内部发生了什么。执行上下文、作用域链和闭包是 JS 语言最核心、最底层的概念，它们共同决定了变量和函数的可访问性以及 <code>this</code> 的指向。</p><h2 id="_1-执行上下文-execution-context-ec" tabindex="-1">1. 执行上下文 (Execution Context, EC) <a class="header-anchor" href="#_1-执行上下文-execution-context-ec" aria-label="Permalink to &quot;1. 执行上下文 (Execution Context, EC)&quot;">​</a></h2><p><strong>执行上下文</strong>可以理解为是 JavaScript 代码被<strong>执行时</strong>所需的环境。当 JS 引擎运行代码时，它会为不同类型的代码创建不同类型的执行上下文。</p><ul><li><strong>全局执行上下文 (Global EC)</strong>：这是最基础的上下文。当 JS 文件被加载和执行时，引擎会首先创建一个全局执行上下文。这个上下文在整个页面生命周期中只有一个，并且在浏览器关闭时被销毁。在浏览器环境中，全局对象就是 <code>window</code>，<code>this</code> 在全局上下文中也指向 <code>window</code>。</li><li><strong>函数执行上下文 (Function EC)</strong>：每当一个<strong>函数被调用</strong>时，就会为该函数创建一个新的执行上下文。每个函数都有自己独立的执行上下文。</li><li><strong>Eval 执行上下文</strong>：通过 <code>eval()</code> 函数执行的代码也有自己的执行上下文（不推荐使用）。</li></ul><h3 id="执行上下文的创建过程" tabindex="-1">执行上下文的创建过程 <a class="header-anchor" href="#执行上下文的创建过程" aria-label="Permalink to &quot;执行上下文的创建过程&quot;">​</a></h3><p>一个执行上下文的创建分为两个阶段：<strong>创建阶段</strong>和<strong>执行阶段</strong>。</p><h4 id="a-创建阶段-creation-phase" tabindex="-1">a. 创建阶段 (Creation Phase) <a class="header-anchor" href="#a-创建阶段-creation-phase" aria-label="Permalink to &quot;a. 创建阶段 (Creation Phase)&quot;">​</a></h4><p>在代码被逐行执行<strong>之前</strong>，JS 引擎会先在“幕后”做一些准备工作，即创建执行上下文。这个阶段发生了三件重要的事情：</p><ol><li><p><strong>确定 <code>this</code> 的值 (This Binding)</strong>：</p><ul><li>在全局上下文中，<code>this</code> 指向全局对象 (<code>window</code>)。</li><li>在函数上下文中，<code>this</code> 的值取决于函数的<strong>调用方式</strong>。其绑定规则有以下几种，优先级从高到低： <ol><li><strong><code>new</code> 绑定</strong>：通过 <code>new</code> 关键字调用构造函数时，<code>this</code> 会被绑定到新创建的实例对象上。</li><li><strong>显式绑定</strong>：通过 <code>call()</code>, <code>apply()</code>, <code>bind()</code> 方法调用函数时，<code>this</code> 会被显式地绑定到传入的第一个参数上。</li><li><strong>隐式绑定</strong>：当函数作为对象的方法被调用时（如 <code>obj.myFunc()</code>），<code>this</code> 会被绑定到调用该方法的对象（<code>obj</code>）上。</li><li><strong>默认绑定</strong>：在独立的函数调用中（不符合以上任何规则），非严格模式下 <code>this</code> 指向全局对象 <code>window</code>，严格模式 (<code>&#39;use strict&#39;</code>) 下为 <code>undefined</code>。</li></ol></li><li><strong>箭头函数的特殊性</strong>：箭头函数 (<code>=&gt;</code>) 没有自己的 <code>this</code> 绑定。它会捕获其<strong>定义时</strong>所在词法作用域的 <code>this</code> 值，一旦确定，就不会再改变。</li></ul></li><li><p><strong>创建词法环境 (Lexical Environment)</strong>：</p><ul><li><strong>词法环境</strong>是一个内部数据结构，用于存储当前上下文中的<strong>变量和函数声明</strong>。它由两部分组成： <ul><li><strong>环境记录 (Environment Record)</strong>：存储变量和函数声明的实际位置。</li><li><strong>对外部环境的引用 (Outer Environment Reference)</strong>：一个指向其<strong>外部</strong>词法环境的链接，这构成了作用域链的基础。</li></ul></li><li>在这个阶段，JS 引擎会扫描当前上下文中的函数声明、<code>var</code> 变量声明，并将它们记录下来。这就是<strong>变量提升 (Hoisting)</strong> 的来源： <ul><li>对于<strong>函数声明 (function declaration)</strong>，会完整地创建函数并存储其引用。</li><li>对于 <strong><code>var</code> 声明的变量</strong>，会为其分配内存并初始化为 <code>undefined</code>。</li><li>对于 <strong><code>let</code> 和 <code>const</code> 声明的变量</strong>，也会被记录下来，但<strong>不会被初始化</strong>。它们被置于一个“<strong>暂时性死区 (Temporal Dead Zone, TDZ)</strong>”中，在声明语句执行之前访问它们会抛出错误。</li></ul></li></ul></li><li><p><strong>创建变量环境 (Variable Environment)</strong>：</p><ul><li>它也是一个词法环境，但只用于存储 <code>var</code> 声明的变量。<code>let</code> 和 <code>const</code> 的声明则存储在词法环境中。</li></ul></li></ol><h4 id="b-执行阶段-execution-phase" tabindex="-1">b. 执行阶段 (Execution Phase) <a class="header-anchor" href="#b-执行阶段-execution-phase" aria-label="Permalink to &quot;b. 执行阶段 (Execution Phase)&quot;">​</a></h4><p>在创建阶段完成后，JS 引擎开始逐行执行代码。在这个阶段，引擎会完成变量的赋值、执行函数调用等操作。</p><h2 id="_2-调用栈-call-stack" tabindex="-1">2. 调用栈 (Call Stack) <a class="header-anchor" href="#_2-调用栈-call-stack" aria-label="Permalink to &quot;2. 调用栈 (Call Stack)&quot;">​</a></h2><p>我们在“事件循环”一章中已经介绍过调用栈。现在我们可以更精确地定义它：调用栈是一个后进先出（LIFO）的栈，专门用于<strong>存储和管理执行上下文</strong>。</p><ul><li>当 JS 引擎开始执行代码时，它首先将<strong>全局执行上下文</strong>压入栈底。</li><li>每当一个函数被调用时，就会创建一个新的<strong>函数执行上下文</strong>，并将其压入栈顶。</li><li>当栈顶的函数执行完毕后，其对应的执行上下文就会从栈中弹出。</li><li>最终，当所有代码执行完毕，全局执行上下文也会被弹出，调用栈清空。</li></ul><h2 id="_3-作用域链-scope-chain" tabindex="-1">3. 作用域链 (Scope Chain) <a class="header-anchor" href="#_3-作用域链-scope-chain" aria-label="Permalink to &quot;3. 作用域链 (Scope Chain)&quot;">​</a></h2><p><strong>作用域 (Scope)</strong> 定义了变量和函数在代码中的可访问区域。JavaScript 采用的是<strong>词法作用域 (Lexical Scoping)</strong>，也叫静态作用域。</p><ul><li><strong>词法作用域</strong>：意味着变量和函数的可访问性，在<strong>代码编写时</strong>就已经被确定下来了，并且不会在运行时改变。它取决于代码块（<code>{}</code>）和函数的嵌套关系。</li></ul><p><strong>作用域链</strong>是在执行上下文的<strong>创建阶段</strong>，通过<strong>词法环境</strong>的“<strong>对外部环境的引用 (Outer)</strong>”这个链接建立起来的。</p><ul><li><strong>工作原理</strong>：当代码在一个执行环境中需要访问一个变量时： <ol><li>JS 引擎首先在<strong>当前</strong>执行上下文的词法环境中查找。</li><li>如果找不到，它就会顺着“外部环境引用”这个“链条”，去<strong>外部</strong>（父级）的词法环境中查找。</li><li>这个过程会一直持续下去，沿着作用域链一直向上，直到找到该变量，或者到达最顶层的<strong>全局执行上下文</strong>。</li><li>如果在全局上下文中仍然找不到，就会抛出 <code>ReferenceError</code>。</li></ol></li></ul><h2 id="_4-闭包-closure" tabindex="-1">4. 闭包 (Closure) <a class="header-anchor" href="#_4-闭包-closure" aria-label="Permalink to &quot;4. 闭包 (Closure)&quot;">​</a></h2><p><strong>闭包</strong>是 JavaScript 中一个强大而独特的概念。一个被广为接受的定义是：</p><blockquote><p><strong>当一个函数能够记住并访问其所在的词法作用域时，即使该函数在其词法作用域之外执行，也会产生闭包。</strong></p></blockquote><p>简单来说，闭包就是 <strong>“一个函数”</strong> 和 <strong>“它在创建时所能访问的作用域”</strong> 的组合。</p><div class="language-javascript vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">function</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> outer</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> outerVar</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &#39;I am outside!&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  </span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  function</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> inner</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() {</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    // inner 函数访问了其外部函数 outer 的变量 outerVar</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    console.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">log</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(outerVar);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  </span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  return</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> inner; </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 返回了 inner 函数</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> myClosure</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> outer</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(); </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// outer() 执行完毕，其执行上下文已从调用栈中弹出</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">myClosure</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(); </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 但 inner 函数依然可以访问 outerVar，输出 &quot;I am outside!&quot;</span></span></code></pre></div><h3 id="闭包的原理" tabindex="-1">闭包的原理 <a class="header-anchor" href="#闭包的原理" aria-label="Permalink to &quot;闭包的原理&quot;">​</a></h3><ul><li>在 <code>outer</code> 函数被调用时，创建了 <code>outer</code> 的执行上下文，其词法环境中包含了 <code>outerVar</code>。</li><li><code>inner</code> 函数在 <code>outer</code> 函数<strong>内部定义</strong>，所以 <code>inner</code> 的词法环境中的“外部环境引用”指向了 <code>outer</code> 的词法环境。</li><li>当 <code>outer</code> 函数返回 <code>inner</code> 函数时，<code>inner</code> 函数本身被赋值给了 <code>myClosure</code>。</li><li>关键点：由于 <code>inner</code> 函数仍然存活（被 <code>myClosure</code> 引用），并且它持有对其创建时所在词法环境（即 <code>outer</code> 的词法环境）的引用，<strong>垃圾回收机制（GC）就不会回收 <code>outer</code> 的词法环境</strong>，特别是被 <code>inner</code> 使用到的 <code>outerVar</code>。</li><li>因此，当 <code>myClosure()</code>（即 <code>inner</code> 函数）在全局作用域中被调用时，它仍然可以通过其内部的作用域链，找到并访问那个本应“消失”的 <code>outerVar</code>。</li></ul><h3 id="闭包的应用与注意事项" tabindex="-1">闭包的应用与注意事项 <a class="header-anchor" href="#闭包的应用与注意事项" aria-label="Permalink to &quot;闭包的应用与注意事项&quot;">​</a></h3><ul><li><strong>应用</strong>： <ul><li><strong>数据封装与私有变量</strong>：创建只有内部函数才能访问的“私有”变量。</li><li><strong>模块化</strong>：在模块模式中用于创建私有作用域。</li><li><strong>函数柯里化、高阶函数</strong>等。</li></ul></li><li><strong>注意事项</strong>： <ul><li><strong>内存泄漏</strong>：由于闭包会使其外部作用域的变量持续存在于内存中，如果不当使用（例如，在一个不再需要的闭包中意外地引用了一个大对象），可能会导致内存泄漏。</li></ul></li></ul><h3 id="闭包的经典陷阱-循环中的闭包" tabindex="-1">闭包的经典陷阱：循环中的闭包 <a class="header-anchor" href="#闭包的经典陷阱-循环中的闭包" aria-label="Permalink to &quot;闭包的经典陷阱：循环中的闭包&quot;">​</a></h3><p>这是一个非常经典的面试题，也是理解闭包与作用域交互的试金石。</p><p><strong>问题代码 (使用 <code>var</code>)</strong>:</p><div class="language-javascript vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">for</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">var</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> i </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">; i </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&lt;=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 5</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">; i</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">++</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">  setTimeout</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">function</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> timer</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    console.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">log</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(i);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  }, i </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">*</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 1000</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><p>很多人期望代码会每隔一秒依次输出 <code>1, 2, 3, 4, 5</code>，但实际结果是：大约5秒后，<strong>连续输出五个 <code>6</code></strong>。</p><p><strong>原因分析</strong>：</p><ul><li><code>for</code> 循环是同步代码，它会很快执行完毕。<code>setTimeout</code> 注册了5个宏任务（timer回调），但它们都会在循环结束后才开始执行。</li><li><code>var</code> 是函数作用域。在循环中，所有 <code>timer</code> 函数共享了同一个<strong>全局作用域</strong>中的变量 <code>i</code>。</li><li>当循环结束时，<code>i</code> 的值已经变成了 <code>6</code>。</li><li>大约1-5秒后，当 <code>timer</code> 回调函数真正被执行时，它们去自己的作用域链上查找 <code>i</code>，最终在全局作用域中找到了这个值为 <code>6</code> 的 <code>i</code>。因此，所有回调都输出了 <code>6</code>。</li></ul><p><strong>解决方案 (使用 <code>let</code>)</strong>:</p><div class="language-javascript vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">for</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">let</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> i </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">; i </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&lt;=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 5</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">; i</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">++</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">  setTimeout</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">function</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> timer</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    console.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">log</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(i);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  }, i </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">*</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 1000</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><p>将 <code>var</code> 换成 <code>let</code>，就能得到期望的结果。</p><p><strong>原因分析</strong>：</p><ul><li><code>let</code> 具有<strong>块级作用域</strong>。在 <code>for</code> 循环中使用 <code>let</code>，JavaScript 引擎会在<strong>每一次循环</strong>时，都创建一个新的、独立的词法作用域。</li><li>每个 <code>timer</code> 回调函数都“闭包”了<strong>当次循环</strong>的那个独立作用域，并捕获了那个作用域中的 <code>i</code> 值（分别是 1, 2, 3, 4, 5）。</li><li>因此，当回调函数后续执行时，它们会访问各自闭包中的、值不同的 <code>i</code>，从而得到正确的结果。</li></ul><h2 id="_4-深入理解-js-类型系统与转换" tabindex="-1">4. 深入理解 JS 类型系统与转换 <a class="header-anchor" href="#_4-深入理解-js-类型系统与转换" aria-label="Permalink to &quot;4. 深入理解 JS 类型系统与转换&quot;">​</a></h2><p>除了执行上下文和作用域，深刻理解 JavaScript 的类型系统同样是掌握这门语言的基石。JS 开发者日常遇到的很多“怪异”行为和 Bug，都源于对其类型和类型转换规则的误解。</p><h3 id="a-原始类型-primitives-vs-对象类型-objects" tabindex="-1">a. 原始类型 (Primitives) vs. 对象类型 (Objects) <a class="header-anchor" href="#a-原始类型-primitives-vs-对象类型-objects" aria-label="Permalink to &quot;a. 原始类型 (Primitives) vs. 对象类型 (Objects)&quot;">​</a></h3><p>JavaScript 的数据类型可分为两大类：</p><ul><li><p><strong>原始类型</strong>: <code>Number</code>, <code>String</code>, <code>Boolean</code>, <code>Null</code>, <code>Undefined</code>, <code>Symbol</code>, <code>BigInt</code>。</p><ul><li>它们是**不可变 (immutable)**的。</li><li>存储在**栈 (Stack)**内存中，访问速度快。</li><li>按值传递。</li></ul></li><li><p><strong>对象类型</strong>: <code>Object</code> (包括 <code>Array</code>, <code>Function</code>, <code>Date</code>, <code>RegExp</code> 等)。</p><ul><li>它们是**可变 (mutable)**的。</li><li>值本身存储在**堆 (Heap)**内存中，而其引用（内存地址）存储在栈中。</li><li>按引用传递。</li></ul></li></ul><h3 id="b-类型检查-type-checking" tabindex="-1">b. 类型检查 (Type Checking) <a class="header-anchor" href="#b-类型检查-type-checking" aria-label="Permalink to &quot;b. 类型检查 (Type Checking)&quot;">​</a></h3><ul><li><p><strong><code>typeof</code></strong>: 最适合用来检查原始类型（<code>&quot;number&quot;</code>, <code>&quot;string&quot;</code>, <code>&quot;boolean&quot;</code>, <code>&quot;symbol&quot;</code>, <code>&quot;bigint&quot;</code>, <code>&quot;undefined&quot;</code>）。但它有两个著名的怪癖：</p><ul><li><code>typeof null</code> 返回 <code>&quot;object&quot;</code>，这是一个历史遗留的 Bug。</li><li><code>typeof</code> 无法区分具体的对象类型，对于数组、函数、对象，它都会返回 <code>&quot;object&quot;</code>（函数除外，返回 <code>&quot;function&quot;</code>）。</li></ul></li><li><p><strong><code>instanceof</code></strong>: 用于检查一个对象是否是某个构造函数的实例。它通过检查对象的原型链 (<code>__proto__</code>) 来工作。</p><ul><li><code>[] instanceof Array</code> -&gt; <code>true</code></li><li><code>new Date() instanceof Date</code> -&gt; <code>true</code></li><li><strong>缺点</strong>：无法处理跨 <code>iframe</code> 或 <code>window</code> 的对象，因为每个窗口都有自己的全局执行环境。</li></ul></li><li><p><strong><code>Object.prototype.toString.call()</code></strong>: 这是最可靠、最通用的类型检查方法。</p><div class="language-javascript vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Object</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">prototype</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.toString.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">call</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">42</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">); </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// &quot;[object Number]&quot;</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Object</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">prototype</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.toString.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">call</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;hello&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">); </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// &quot;[object String]&quot;</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Object</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">prototype</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.toString.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">call</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">([]); </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// &quot;[object Array]&quot;</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Object</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">prototype</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.toString.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">call</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">({}); </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// &quot;[object Object]&quot;</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Object</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">prototype</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.toString.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">call</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">null</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">); </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// &quot;[object Null]&quot;</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Object</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">prototype</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.toString.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">call</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">undefined</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">); </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// &quot;[object Undefined]&quot;</span></span></code></pre></div></li></ul><h3 id="c-隐式类型转换-coercion" tabindex="-1">c. 隐式类型转换 (Coercion) <a class="header-anchor" href="#c-隐式类型转换-coercion" aria-label="Permalink to &quot;c. 隐式类型转换 (Coercion)&quot;">​</a></h3><p>这是 JavaScript 中最强大也最容易引起混淆的特性。当运算符在运算时，如果两边的类型不统一，JS 引擎会自动尝试将它们转换为相同的类型。</p><p><strong>转换规则</strong>:</p><ol><li><strong>转换为字符串</strong>: 如果 <code>+</code> 运算的一边是字符串，另一边也会被转换为字符串。 <ul><li><code>&#39;5&#39; + 1</code> -&gt; <code>&quot;51&quot;</code></li></ul></li><li><strong>转换为数字</strong>: <ul><li>对于 <code>-, *, /, %</code> 等算术运算符，操作数会被转换为数字。 <ul><li><code>&#39;5&#39; - 1</code> -&gt; <code>4</code></li><li><code>&#39;5&#39; * &#39;2&#39;</code> -&gt; <code>10</code></li></ul></li><li>对于关系比较 (<code>&gt;</code>, <code>&lt;</code>, <code>&gt;=</code>, <code>&lt;=</code>)，如果两边都是字符串，则按字典序比较。否则，转换为数字比较。 <ul><li><code>&#39;10&#39; &gt; 9</code> -&gt; <code>true</code></li></ul></li></ul></li><li><strong>转换为布尔值</strong>: 在逻辑上下文中（如 <code>if</code> 语句, <code>||</code>, <code>&amp;&amp;</code>），值会被转换为布尔值。除了 <code>undefined</code>, <code>null</code>, <code>false</code>, <code>NaN</code>, <code>0</code>, <code>&quot;&quot;</code> (空字符串) 这六个“虚值 (falsy values)”外，其他所有值都为 <code>true</code>。</li></ol><h3 id="d-vs-的终极对比" tabindex="-1">d. <code>==</code> vs. <code>===</code> 的终极对比 <a class="header-anchor" href="#d-vs-的终极对比" aria-label="Permalink to &quot;d. \`==\` vs. \`===\` 的终极对比&quot;">​</a></h3><ul><li><p><strong><code>===</code> (严格相等)</strong>：</p><ul><li><strong>不进行</strong>类型转换。</li><li>如果类型不同，直接返回 <code>false</code>。</li><li>如果类型相同，再比较值。</li><li><strong>行为可预测，是开发中的首选。</strong></li></ul></li><li><p><strong><code>==</code> (宽松相等)</strong>：</p><ul><li><strong>会进行</strong>隐式类型转换。</li><li>转换规则复杂且不直观，是许多“面试题”的来源。</li><li>例如，<code>[] == ![]</code> 为 <code>true</code> 的过程： <ol><li><code>![]</code> -&gt; <code>false</code> (数组是真值，取反为 false)</li><li><code>[] == false</code></li><li><code>[]</code> 转换为数字 <code>0</code></li><li><code>false</code> 转换为数字 <code>0</code></li><li><code>0 == 0</code> -&gt; <code>true</code></li></ol></li><li><strong>除非你非常清楚其转换规则，否则应避免在代码中使用。</strong></li></ul></li></ul><h2 id="总结" tabindex="-1">总结 <a class="header-anchor" href="#总结" aria-label="Permalink to &quot;总结&quot;">​</a></h2>`,55)])])}const g=s(o,[["render",n]]);export{k as __pageData,g as default};
