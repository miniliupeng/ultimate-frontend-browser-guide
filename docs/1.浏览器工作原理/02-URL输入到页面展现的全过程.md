# 02-URL输入到页面展现的全过程

这个过程是前端知识体系的完美串联，它清晰地展示了从网络通信到浏览器渲染的每一个细节。

## 1. 用户输入处理 (浏览器进程)

故事始于用户在浏览器地址栏输入内容。此阶段完全在**浏览器进程**的 **UI 线程**中进行。

*   **解析输入**：UI 线程判断用户输入的是一个**搜索查询**还是一个合法的 **URL**。
    *   如果是搜索查询，浏览器会使用默认的搜索引擎，将其拼接成一个新的 URL。
    *   如果是合法的 URL，浏览器会准备开始导航。

*   **`beforeunload` 事件**：在当前页面即将被导航离开时，UI 线程会触发 `beforeunload` 事件，允许页面在关闭前执行一些清理工作或向用户弹出确认提示。如果用户选择取消，后续的导航流程将终止。

*   **开始导航，准备渲染进程**：UI 线程通知网络线程准备发起请求。同时，浏览器会寻找一个合适的**渲染进程**来渲染即将到来的页面。如果可能，会复用已有的渲染进程，否则会创建一个新的。

## 2. 网络请求阶段 (网络进程)

浏览器进程通过 IPC (进程间通信) 将 URL 交给**网络进程**，由网络进程发起真正的网络请求。

1.  **HSTS 检查**：浏览器会检查当前域名是否在 HSTS (HTTP Strict Transport Security) 预加载列表中。如果在，浏览器会**强制将 HTTP 请求升级为 HTTPS 请求**，确保通信安全。

2.  **Service Worker 检查**：
    *   在发起请求之前，主线程会检查当前作用域下是否注册并激活了 **Service Worker**。
    *   如果存在活动的 Service Worker，它将获得拦截网络请求的机会。Service Worker 可以在 `fetch` 事件中决定是**直接从缓存中返回响应**（实现离线访问），还是**继续向网络发送请求**。这为 PWA (Progressive Web Apps) 提供了强大的能力。

3.  **查找缓存**：
    *   浏览器会首先检查**强缓存**（HTTP Headers 中的 `Expires` 和 `Cache-Control`）。如果资源在缓存中且未过期，就直接从本地缓存中读取，网络请求结束。这是最快的方式。
    *   如果强缓存失效，浏览器会继续检查**协商缓存**（HTTP Headers 中的 `Last-Modified`/`If-Modified-Since` 和 `ETag`/`If-None-Match`）。网络进程会向服务器发送一个请求，服务器根据这些头信息判断资源是否有更新。
        *   若无更新，服务器返回 `304 Not Modified` 响应，浏览器从缓存中加载资源。
        *   若有更新，服务器返回 `200 OK` 和最新的资源。

4.  **DNS 解析 (域名系统)**：
    *   如果缓存中没有，网络进程需要将 URL 中的域名（例如 `www.google.com`）解析成服务器的 IP 地址。
    *   解析顺序如下：
        *   **浏览器 DNS 缓存**：检查浏览器自身是否缓存了该域名的 IP。
        *   **操作系统 DNS 缓存**：检查操作系统（如 Windows 的 `hosts` 文件）是否有缓存。
        *   **路由器 DNS 缓存**：检查路由器的缓存。
        *   **ISP (网络服务提供商) DNS 服务器**：向网络运营商的 DNS 服务器发起请求。
        *   **根 DNS 服务器**：如果以上都没有，请求会逐级向上，从根服务器开始，进行递归或迭代查询，直到找到目标 IP 地址。

5.  **建立 TCP 连接**：
    *   拿到了服务器 IP 地址后，网络进程会与服务器建立一个 TCP 连接。这个过程就是著名的“**三次握手**”。
    *   **现代协议的演进**：
        *   传统的 TCP 连接受限于“队头阻塞”，并且建立连接需要多次往返。
        *   **HTTP/2** 通过**多路复用**缓解了应用层的队头阻塞，但依然基于单个 TCP 连接，无法解决 TCP 层的队头阻塞。
        *   最新的 **HTTP/3** 则基于 **QUIC** 协议，它建立在 UDP 之上，彻底解决了队头阻塞问题，并实现了更快的连接建立（0-RTT 或 1-RTT）。当浏览器和服务器都支持时，会优先使用 QUIC 连接。

6.  **发起 HTTP/HTTPS 请求**：
    *   连接建立后，浏览器就可以向服务器发送 HTTP 请求了。请求报文包括请求行、请求头和请求体。
    *   如果 URL 是 `https` 协议，还需要在 TCP 连接之上建立一个 TLS/SSL 安全层，进行加密通信，涉及证书验证和密钥交换。

## 3. 服务器处理与响应

服务器（如 Nginx, Apache）接收到 HTTP 请求后，进行处理并构建 HTTP 响应，然后将响应通过 TCP 连接发送回浏览器的**网络进程**。

## 4. 浏览器解析与渲染

这是整个流程中最核心、最复杂的阶段，涉及浏览器进程与渲染进程的多次协作。

1.  **响应解析与安全检查 (网络进程)**：网络进程接收到响应后，会进行初步解析。
    *   它会进行**安全检查**，如 `CORB` (Cross-Origin Read Blocking) 和 `MIME 类型嗅探`，以防止恶意跨站数据的攻击。
    *   根据响应头中的 `Content-Type` 判断资源类型。如果是 `text/html`，它会通知**浏览器进程**数据已准备好，可以提交给渲染进程了。如果是需要下载的类型，则会交给下载管理器。

2.  **提交导航与确认 (浏览器进程 <-> 渲染进程)**：
    *   浏览器进程接收到网络进程的通知后，通过 IPC 将导航指令和数据发送给之前准备好的**渲染进程**。
    *   渲染进程收到数据后，会开始准备解析和渲染。准备就绪后，它会**向浏览器进程发送一个“确认提交”的消息**。
    *   浏览器进程收到这个确认后，才会真正地更新地址栏 UI、更新会话历史，并销毁旧的页面（如果存在）。这个确认机制确保了导航的顺畅过渡。

3.  **渲染进程开始工作 (渲染进程)**：渲染进程的主线程开始执行**关键渲染路径 (Critical Rendering Path)** 的流程：

    *   **资源加载提示 (Resource Hints) 与预加载**：在主解析器工作前，浏览器其实已经开始进行优化。
        *   它会检查 HTML 头部是否存在 `link` 标签指定的预加载提示，如 `dns-prefetch`, `preconnect`, `preload`, `prefetch`。这些提示会指导浏览器更早地发起 DNS 解析、建立连接或下载关键资源。
        *   现代浏览器还会利用 **Speculation Rules API** 实现更智能的**预渲染 (prerender)**，提前在后台渲染好用户可能要访问的下一个页面。

    *   **构建 DOM 树**：解析 HTML 文本，生成一个树状结构的 DOM (Document Object Model)。在构建的同时，一个**预扫描器 (pre-scanner)** 会在后台运行，查找页面中的关键资源（如 CSS, JS, 图片），并提前通知网络进程去下载，从而与主解析流程并行，提升加载速度。

    *   **构建 CSSOM 树**：解析 CSS 文件和 `<style>` 标签，生成一个树状结构的 CSSOM (CSS Object Model)。CSSOM 的构建会**阻塞渲染**，但通常不会阻塞 DOM 的构建。
    *   **执行 JavaScript**：当解析器遇到 `<script>` 标签时，DOM 构建会暂停（除非脚本是 `async` 或 `defer` 的），**主线程**会接管控制权，开始执行脚本。JS 可能会通过 DOM API 来修改 DOM 结构。
    *   **构建渲染树 (Render Tree)**：将 DOM 树和 CSSOM 树结合起来，生成渲染树。渲染树只包含需要被渲染的节点（例如，`display: none` 的节点不会出现在渲染树中）。
    *   **布局 (Layout / Reflow)**：根据渲染树，计算出每个节点在屏幕上的精确位置和大小。
    *   **绘制 (Paint)**：根据布局阶段计算出的信息，将每个节点绘制成一系列的绘制指令。
    *   **合成 (Composite)**：**合成器线程**会将页面的不同部分提升到独立的图层（Layers）上，并进行栅格化。最后，它将这些图层信息提交给 **GPU 进程**，由 GPU 负责将这些图层按照正确的顺序合成，并最终显示在屏幕上。

## 5. 加载完成与连接管理

1.  **页面加载事件**：
    *   当初始的 HTML 文档被完全加载和解析完成之后，**`DOMContentLoaded`** 事件被触发，此时无需等待样式表、图像和子框架的完成。
    *   当页面上的所有资源（包括图片、脚本、样式表等）都已加载完成时，**`load`** 事件被触发。

2.  **连接关闭**：页面完全加载后，TCP 连接可能会根据 HTTP 的 `Keep-Alive` 机制保持连接以便复用，也可能通过“**四次挥手**”被关闭。
