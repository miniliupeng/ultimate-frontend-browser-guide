# 03-关键渲染路径（Critical Rendering Path）

关键渲染路径（CRP）是指浏览器从接收到 HTML、CSS 和 JavaScript 资源开始，到最终将它们渲染成像素显示在屏幕上所经历的一系列步骤。**优化关键渲染路径是提升页面首屏加载速度的核心**。

我们可以将 CRP 的核心依赖关系总结如下：
```
HTML -> DOM
CSS -> CSSOM
(DOM + CSSOM) -> Render Tree
Render Tree -> Layout -> Paint -> Composite
```
每个阶段都依赖于前一阶段的完成，优化 CRP 的本质就是加速这个链条的执行。

## 1. 构建对象模型 (Object Model)

当渲染进程接收到导航确认，开始解析数据时，主线程首先会将 HTML 和 CSS 文本转换成浏览器能够理解的内部数据结构。

### a. 构建 DOM 树 (Document Object Model)

*   **输入**：HTML 文本。
*   **过程**：UI 渲染线程自上而下解析 HTML 标记，逐个生成节点对象，并根据它们之间的嵌套关系构建起一个树状结构。
*   **输出**：DOM 树。

这个过程是**渐进式**的。浏览器不需要等到整个 HTML 文档下载完毕才开始解析和构建 DOM，而是一边接收数据一边进行。

### b. 构建 CSSOM 树 (CSS Object Model)

*   **输入**：CSS 代码（来自 `<link>` 标签、`<style>` 标签或内联样式）。
*   **过程**：UI 渲染线程解析 CSS 规则。与 HTML 不同，CSS 的解析**不是渐进式**的，因为后面的规则可能会覆盖前面的规则。浏览器需要下载并解析完所有的 CSS 代码，才能确认每个 DOM 节点的最终样式。
*   **输出**：CSSOM 树。

**注意：CSSOM 会阻塞渲染和 JS 执行。**
*   **阻塞渲染**：在 CSSOM 树完全构建完成之前，浏览器不会进入后续的渲染树构建、布局和绘制阶段。这就是为什么我们通常建议将 CSS `<link>` 标签放在 HTML 的 `<head>` 部分，以便浏览器能尽早发现并下载 CSS，从而缩短阻塞时间。
*   **阻塞 JS 执行**：如果 JS 在执行时试图查询节点的样式（例如 `getComputedStyle`），它必须等待所有 CSS 都被下载和解析完毕。因此，浏览器会推迟脚本执行，直到 CSSOM 构建完成。

## 2. JavaScript 的影响：解析器阻塞

当 HTML 解析器在构建 DOM 的过程中遇到 `<script>` 标签时，情况会变得特殊。

*   **默认行为（无 `async` 或 `defer`）**：
    1.  HTML 解析暂停。
    2.  浏览器开始下载 JavaScript 文件。
    3.  下载完成后，JS 引擎线程立即执行该脚本。
    4.  脚本执行完毕后，HTML 解析器才恢复工作。

**为什么 JS 会阻塞 DOM 构建？**
因为 JavaScript 可以通过 `document.write()` 或其他 DOM API 来修改 DOM 结构。浏览器无法预知脚本会做什么，所以它必须停下来，等待脚本执行完毕，以确保后续的 DOM 构建是基于一个确定的、未被修改的状态。

**JS 同样会被 CSSOM 阻塞**。如上所述，如果脚本试图查询一个节点的样式，它必须等待所有 CSS 都被下载和解析完毕。因此，JS 的执行也依赖于 CSSOM 的构建。

**优化方案：`async` 和 `defer`**
为了减少 JS 阻塞带来的性能影响，我们可以使用这两个属性：
*   **`async`**：脚本的下载和 HTML 解析可以并行进行。一旦脚本下载完成，HTML 解析会立即暂停，开始执行脚本。执行完毕后，再恢复 HTML 解析。它不保证脚本的执行顺序。
*   **`defer`**：脚本的下载和 HTML 解析也可以并行进行。但脚本的执行会被推迟到整个 HTML 文档解析完毕（DOM 构建完成）之后，`DOMContentLoaded` 事件触发之前。它会按照脚本在 HTML 中出现的顺序来执行。

## 3. 构建渲染树 (Render Tree)

当浏览器同时拥有了 DOM 树和 CSSOM 树之后，就可以将它们结合起来，创建**渲染树**。

*   **过程**：浏览器会从 DOM 树的根节点开始遍历，对于每个**可见**的节点，找到它在 CSSOM 树中对应的样式规则，并应用它们。
*   **关键点**：渲染树只包含页面上实际可见的元素。像 `<head>`、`<script>` 标签，或者设置了 `display: none;` 的节点，都不会被包含在渲染树中。而 `visibility: hidden;` 的节点虽然不可见，但仍然占据布局空间，所以会包含在渲染树里。

## 4. 布局 (Layout / Reflow)

有了渲染树，浏览器就知道了哪些节点需要被渲染以及它们的样式，但还不知道它们在屏幕上的确切位置和大小。**布局**阶段就是为了计算这些几何信息。

*   **过程**：浏览器从渲染树的根节点开始，递归地计算每个节点的几何信息（位置、尺寸）。
*   **输出**：一个包含了所有元素精确位置和大小信息的“盒子模型”。

页面上的任何一个微小的改动，比如窗口大小变化、元素尺寸变化、内容改变导致的高度变化等，都可能引发整个或部分渲染树的**重新布局**，这个过程也叫**回流 (Reflow)**。回流是一个非常耗费性能的操作。

## 5. 绘制 (Paint)

布局阶段完成后，浏览器知道了每个元素的几何信息和样式。**绘制**阶段就是将这些信息转换成屏幕上的实际像素。

*   **过程**：UI 渲染线程会遍历渲染树，调用图形库的 API，将每个节点的背景、颜色、边框、文字等内容绘制出来，生成一系列的绘制指令（Painting Records）。

当元素的样式改变不影响其几何位置时（例如 `background-color`, `color` 的改变），浏览器会跳过布局阶段，直接进入绘制阶段。这个过程称为**重绘 (Repaint)**。

## 6. 合成 (Compositing)

在绘制之后，为了进一步提升性能，现代浏览器引入了**图层 (Layer)** 和**合成**机制。这部分工作主要由**合成器线程**和 **GPU 进程**协作完成。

*   **图层提升 (Layer Promotion)**：在布局和绘制之后，主线程会识别出页面的某些部分（例如有 `transform: translateZ(0)` 或 `will-change` 属性的元素），并将它们提升为独立的图层。这个过程也被称为**显式合成**。
    *   **隐式合成**：此外，如果一个普通元素覆盖在一个合成层之上，那么这个普通元素也会被“隐式”地提升为一个新图层，以保证正确的层叠顺序。过度使用可能导致“图层爆炸”，消耗大量内存。
*   **栅格化 (Rasterization)**：主线程将图层信息提交给合成器线程。**合成器线程**会调度其内部的**光栅线程**，将每个图层的绘制指令列表转换成位图（Bitmap）。这个过程通常在 GPU 中进行以加速处理。
*   **合成与显示**：光栅化完成后，合成器线程会生成一个“合成器帧”，并通过 IPC 将其发送给 **GPU 进程**。GPU 进程负责将所有这些图层合成为一个完整的页面，然后显示在屏幕上。

**合成的优势**：对于那些只影响图层变换（如 `transform`, `opacity`）的动画，浏览器可以跳过主线程的布局和绘制，直接在合成器线程和 GPU 中进行处理。这极大地提高了动画的流畅度，因为它完全脱离了主线程的负担。

## 7. 优化 CRP 的最佳实践

*   **减少关键资源的数量和大小**：尽可能地压缩、合并 CSS 和 JS 文件，移除未使用的代码。
*   **优化关键资源的加载顺序**：
    *   将 CSS `<link>` 标签放在文档的 `<head>` 中，尽早开始下载。
    *   将阻塞渲染的 `<script>` 标签（特别是未使用 `async` 或 `defer` 的）放在 `<body>` 的末尾。
*   **避免阻塞渲染**：
    *   对非关键的 CSS（如打印样式、非首屏样式）使用 `media` 属性进行标记，或异步加载。
    *   对 JavaScript 使用 `async` 或 `defer` 属性，消除对 DOM 构建的阻塞。
*   **利用合成层优化动画和交互**：对于需要频繁变化的元素，使用 `will-change` 或 `transform: translateZ(0)` 将其提升到合成层，多使用 `transform` 和 `opacity` 来实现动画，以利用 GPU 加速。
