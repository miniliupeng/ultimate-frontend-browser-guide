# 04-浏览器的一帧：事件循环与渲染时机

前面几节，我们深入探讨了浏览器如何从零开始加载并渲染一个页面。但Web应用的生命周期远不止于此。页面加载完成后，它会持续响应用户交互、播放动画、更新数据。理解浏览器如何处理这些“运行时”的工作，是性能优化的后半场，而这一切都围绕着一个核心概念展开——**帧 (Frame)**。

## 1. 什么是帧？为什么是 16.6ms？

现代显示器的刷新率通常是 **60Hz**，这意味着屏幕上的画面每秒会刷新60次。为了让用户感知到流畅的视觉效果，浏览器必须跟上这个节奏，在每次屏幕刷新前都准备好新的一帧画面。

因此，留给浏览器完成一帧所有工作的时间就是：**1秒 / 60次 ≈ 16.67毫秒**。

如果在 16.67ms 内，浏览器没有完成画面的计算和绘制，那么这一帧就会被“丢弃”，屏幕会继续显示上一帧的内容。这就是我们常说的**掉帧 (Frame Drop)**，在用户看来就是**卡顿 (Jank)**。

## 2. 浏览器在一帧内会做什么？

浏览器的一帧可以看作是事件循环中一次特殊的、以渲染为目标的“tick”。它并非一个孤立的系统，而是与我们之前学习的事件循环模型紧密结合。

一帧的主要工作流程可以分解为以下几个阶段：

### 阶段一：任务处理 (Task Processing)

这是事件循环处理宏任务的阶段。浏览器会从宏任务队列中取出一个任务来执行。

1.  **处理输入事件 (Input Events)**：首先处理用户的交互，如 `click`, `scroll`, `wheel` 等。及时响应用户输入是保证交互体验的关键。
2.  **执行定时器 (Timers)**：检查并执行到期的 `setTimeout` 或 `setInterval` 的回调函数。

### 阶段二：帧开始 (Begin Frame)

在处理完一些宏任务后，如果浏览器判断需要进行一次新的渲染（例如，有样式变更、DOM 操作或上一帧错过了渲染），就会进入这个阶段。

3.  **执行 `requestAnimationFrame` (rAF) 回调**：
    *   这是执行动画更新的**黄金时机**。`rAF` 的回调函数会在每次页面重绘之前被调用。
    *   **为什么用 rAF 而不是 `setTimeout` 做动画？** 因为 `rAF` 的执行时机是由浏览器精确控制的，它能确保回调在最合适的时间点（紧邻渲染）执行，避免了不必要的计算和掉帧。而 `setTimeout` 的时间精度不高，且与渲染时机无关，容易导致动画卡顿。

### 阶段三：渲染管道 (Render Pipeline)

这个阶段的目标是计算并生成新的像素画面。它基本复用了我们在“关键渲染路径”中学到的流程，但通常是针对页面的局部变化。

4.  **样式计算 (Style)**：浏览器重新计算哪些元素的 CSS 规则受到了影响，并确定每个元素的最终样式。
5.  **布局 (Layout/Reflow)**：如果元素的几何属性（如宽度、高度、位置）发生变化，浏览器需要重新计算受影响元素的位置和大小。
6.  **绘制 (Paint)**：将元素的可见内容（背景、文字、边框等）的绘制指令记录下来。
7.  **合成 (Composite)**：合成器线程将所有图层按照正确的顺序合并，生成最终的图像，并提交给 GPU 渲染到屏幕上。

**注意**：微任务队列的清空会发生在**阶段一**的宏任务执行完毕后，以及**阶段二**的 rAF 回调执行完毕后。

### 阶段四：空闲时间处理 (Idle Period)

8.  **执行 `requestIdleCallback` (rIC) 回调**：
    *   如果在完成以上所有工作后，当前帧的 16.67ms 还有剩余时间，浏览器就会进入“空闲状态”。
    *   此时，`requestIdleCallback` 注册的回调函数会被调用。
    *   **适用场景**：非常适合用来处理那些**不紧急、但又需要执行**的低优先级任务，例如发送数据分析报告、进行本地数据预存储等。这样可以最大化地利用每一帧的资源，同时避免阻塞关键的渲染和交互任务。

## 3. 总结：一个完整的视图

将事件循环与帧渲染结合起来，我们可以得到一个更完整的浏览器工作模型：

1.  浏览器持续进行**事件循环**，处理宏任务队列中的任务（如用户输入、定时器）。
2.  在每个宏任务执行完毕后，立即**清空微任务队列**。
3.  在两次屏幕刷新之间（约16.6ms），浏览器会寻找一个合适的时机启动**渲染流程**。
4.  渲染流程开始时，首先执行 `requestAnimationFrame` 回调，然后依次进行**样式计算 -> 布局 -> 绘制 -> 合成**。
5.  如果在一帧的时间内完成了所有工作还有富余，浏览器会调用 `requestIdleCallback` 执行低优先级任务。
6.  这个过程周而复始，构成了 Web 应用流畅运行的脉搏。

理解这个“帧”模型，是从“让页面能看”到“让页面好用”的关键一步，也是所有高级性能优化的理论基石。
