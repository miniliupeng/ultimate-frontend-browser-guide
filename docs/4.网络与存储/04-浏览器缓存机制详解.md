# 13-浏览器缓存机制详解

浏览器缓存，也称为 HTTP 缓存，是 Web 性能优化的核心策略。它允许浏览器将一度请求过的资源（如图片、CSS、JS 文件）存储在本地，当再次需要该资源时，可以直接从本地存储中读取或通过简单的验证后使用，从而避免了不必要的网络请求。

浏览器缓存机制主要分为两大类：**强缓存** 和 **协商缓存**。

## 1. 强缓存 (Strong Cache)

*   **定义**：强缓存是指浏览器在请求资源时，如果发现本地缓存的副本**未过期**，就**不会向服务器发送任何请求**，而是直接从本地缓存中读取该资源。
*   **状态码**：在这种情况下，网络请求甚至不会发生，因此在 Chrome DevTools 的 Network 面板中，该资源的状态码会显示为 `200 OK (from disk cache)` 或 `200 OK (from memory cache)`。
*   **优点**：速度最快，因为它完全避免了网络往返。

强缓存是由服务器通过设置响应头中的特定字段来控制的。主要有两个相关的头部，它们可以同时存在，但优先级不同。

### a. `Expires` (HTTP/1.0)

*   **格式**：`Expires: Wed, 22 Oct 2025 08:28:00 GMT`
*   **原理**：`Expires` 的值是一个**绝对时间**的 GMT 格式字符串，它告诉浏览器该资源的缓存副本在此时间点之前都是有效的。
*   **缺点**：由于它是一个绝对时间，如果客户端的本地时间与服务器时间不一致（例如用户手动修改了本地时间），可能会导致缓存提前失效或永远有效，存在不确定性。

### b. `Cache-Control` (HTTP/1.1) - 优先级更高

*   **格式**：`Cache-Control: max-age=3600`
*   **原理**：`Cache-Control` 是 HTTP/1.1 中引入的，功能更强大。它使用一个**相对时间** `max-age`（单位为秒）来告诉浏览器，资源在被请求后的 `3600` 秒内都是有效的。
*   **优点**：`max-age` 使用相对时间，不受客户端本地时间的影响，比 `Expires` 更精确、更可靠。
*   **其他常用指令**：
    *   `no-cache`：**强制进行协商缓存**。浏览器在每次请求前，都必须向服务器发送验证请求，确认资源是否依然有效。
    *   `no-store`：**完全禁用缓存**。浏览器既不使用本地缓存，也不存储该资源的任何副本。
    *   `public`：表明该资源可以被任何中间代理（如 CDN、代理服务器）缓存。
    *   `private`：表明该资源是用户私有的，只能被最终用户的浏览器缓存，不允许中间代理缓存。

**当 `Cache-Control` 和 `Expires` 同时存在时，`Cache-Control` 的优先级更高。**

### c. 强缓存的存储位置：Memory Cache vs Disk Cache

当强缓存生效时，我们会在 Chrome DevTools 的 Network 面板中看到 `(from memory cache)` 或 `(from disk cache)`。这表示缓存资源是存储在**内存**还是**磁盘**中。

*   **Memory Cache (内存缓存)**
    *   **优点**：读取速度极快，因为数据直接存储在内存中，没有 I/O 开销。
    *   **缺点**：生命周期短。一旦我们关闭了浏览器标签页，该页面对应的内存缓存就会被清空。
    *   **存储内容**：浏览器会倾向于将体积小、访问频繁的资源（如脚本、字体、小图片）放入内存缓存。

*   **Disk Cache (磁盘缓存)**
    *   **优点**：容量大，持久性强。即使关闭浏览器甚至重启电脑，磁盘缓存依然存在（只要没过期）。
    *   **缺点**：读取速度比内存缓存慢，需要进行磁盘 I/O 操作。
    *   **存储内容**：体积较大的资源（如大的图片、CSS/JS 文件）会被优先存入磁盘缓存。

**读取顺序**：当浏览器请求一个资源时，会**优先在内存缓存中查找**，如果找到则直接使用。如果内存中没有，再去磁盘缓存中查找。如果两者都没有，才会发起网络请求。这种“内存优先”的策略确保了最快的响应速度。

## 2. 协商缓存 (Negotiation Cache)

*   **定义**：当资源的强缓存失效后（或者 `Cache-Control` 设置为 `no-cache`），浏览器在请求该资源时，会**向服务器发送一个验证请求**。服务器会根据请求中携带的缓存标识来判断资源是否有更新。
*   **工作流程**：
    *   如果资源**未更新**，服务器会返回一个 `304 Not Modified` 的响应，响应体为空。浏览器接收到后，就知道可以使用本地缓存的副本。
    *   如果资源**已更新**，服务器会返回一个 `200 OK` 的响应，并在响应体中包含最新的资源内容。
*   **优点**：虽然仍然有一次网络请求，但如果资源未变更，可以避免传输完整的响应体，从而节省网络带宽。

协商缓存也是通过一对对的请求头和响应头来工作的。

### a. `Last-Modified` / `If-Modified-Since`

1.  **首次请求**：服务器在响应头中返回 `Last-Modified` 字段，表示该资源在服务器上的最后修改时间。
    `Last-Modified: Tue, 12 Oct 2025 10:00:00 GMT`
2.  **后续请求**：当缓存过期后，浏览器在请求头中携带 `If-Modified-Since` 字段，其值就是上次收到的 `Last-Modified` 的值。
    `If-Modified-Since: Tue, 12 Oct 2025 10:00:00 GMT`
3.  **服务器验证**：服务器比较 `If-Modified-Since` 的值和资源的实际最后修改时间。
    *   如果一致，说明资源未变，返回 `304`。
    *   如果不一致，说明资源已更新，返回 `200` 和新资源，并附带一个新的 `Last-Modified` 值。

*   **缺点**：
    *   **精度问题**：时间戳的精度只能到秒，如果在 1 秒内文件被多次修改，服务器无法检测到变化。
    *   **内容未变但时间戳改变**：有时文件内容没有实际变化，但其修改时间却变了（例如重新保存），这会导致缓存失效。

### b. `ETag` / `If-None-Match` - 优先级更高

为了解决 `Last-Modified` 的问题，HTTP/1.1 引入了 `ETag` (Entity Tag)。

1.  **首次请求**：服务器在响应头中返回 `ETag` 字段，这是一个根据资源内容生成的**唯一标识符**（类似于文件内容的哈希值）。
    `ETag: "33a64df551425fcc55e4d42a148795d9"`
2.  **后续请求**：当缓存过期后，浏览器在请求头中携带 `If-None-Match` 字段，其值就是上次收到的 `ETag` 的值。
    `If-None-Match: "33a64df551425fcc55e4d42a148795d9"`
3.  **服务器验证**：服务器比较 `If-None-Match` 的值和资源当前的 `ETag` 值。
    *   如果一致，说明资源未变，返回 `304`。
    *   如果不一致，说明资源已更新，返回 `200` 和新资源，并附带一个新的 `ETag` 值。

*   **优点**：`ETag` 基于内容生成，比基于时间戳的 `Last-Modified` 更精确、更可靠。

**当 `ETag` 和 `Last-Modified` 同时存在时，服务器会优先验证 `ETag`。**

## 3. 缓存决策流程总结

当浏览器请求一个资源时，会按照以下流程来决策：

1.  **检查强缓存**：查看本地缓存副本，根据 `Cache-Control` 和 `Expires` 判断是否过期。
    *   如果**未过期**，直接使用缓存（`200 from cache`），流程结束。
    *   如果**已过期**，进入下一步。
2.  **发起协商缓存请求**：向服务器发送请求，并在请求头中携带 `If-Modified-Since` 和 `If-None-Match`。
3.  **服务器验证**：服务器根据收到的缓存标识进行判断。
    *   如果资源**未更新**，返回 `304`。浏览器使用本地缓存，流程结束。
    *   如果资源**已更新**，返回 `200` 和最新的资源内容。浏览器使用新资源，并更新本地缓存及其过期信息，流程结束。

## 4. 用户行为对缓存的影响

*   **地址栏输入 URL / 书签 / 前进后退**：正常检查缓存。
*   **F5 / 点击刷新按钮**：会跳过**强缓存**，直接发起**协商缓存**请求（请求头会带 `If-Modified-Since` / `If-None-Match`）。
*   **Ctrl + F5 强制刷新**：会**完全忽略**所有缓存，直接向服务器请求全新的资源（请求头不会带任何缓存标识）。

## 5. 现代前端工程化缓存策略

理论知识需要结合工程实践才能发挥最大价值。在现代前端开发（如使用 Webpack/Vite）中，我们通常采用一种被称为“**持久化缓存 + 文件指纹**”的最佳实践策略，来最大化地利用缓存并确保内容能被可靠地更新。

*   **核心思想**：
    1.  对静态资源（JS, CSS, 图片等），在文件名中加入根据其内容计算出的 **Hash（文件指纹）**。
    2.  为这些带指纹的静态资源设置一个**超长时间的强缓存**。
    3.  作为入口的 `index.html` 文件，**绝不设置强缓存**，而是使用协商缓存或禁用缓存。

*   **具体做法**：
    1.  **文件名 Hash**：构建工具（如 Webpack）在打包时，会根据文件内容计算出一个唯一的哈希值，并将其作为文件名的一部分（例如 `app.a1b2c3d4.js`）。
    2.  **长效强缓存**：服务器对所有带哈希的静态资源文件（如 `*.js`, `*.css`）设置一个极长的 `Cache-Control` 值，例如：
        `Cache-Control: max-age=31536000` (一年)
    3.  **入口文件控制**：服务器对 `index.html` 文件设置协商缓存，以确保浏览器每次都能获取到最新的 HTML 内容：
        `Cache-Control: no-cache`

*   **工作流程**：
    *   当网站内容更新，某个 JS 文件的内容发生变化时，其文件名中的哈希值也会随之改变（例如从 `app.a1b2c3d4.js` 变为 `app.e5f6g7h8.js`）。
    *   由于 `index.html` 没有被强缓存，浏览器会通过协商缓存获取到最新的 HTML 内容。
    *   最新的 HTML 中引用了新的 JS 文件名。浏览器在请求这个新文件时，会因为文件名不同而发生一次全新的网络请求，从而加载到最新的资源。
    *   对于那些内容**未发生变化**的静态资源，它们的文件名和哈希值保持不变，浏览器将继续从本地缓存中以极快的速度（强缓存）加载它们，无需任何网络请求。

*   **优势**：这种策略完美地结合了强缓存的“快”和内容更新的“准”，实现了**最大化的缓存利用率**和**可靠、即时的内容更新**，是当前前端工程化领域的黄金标准。