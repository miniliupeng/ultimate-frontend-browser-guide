# 11-HTTP协议的前世今生

HTTP (HyperText Transfer Protocol, 超文本传输协议) 是 Web 通信的基石。从最初简单的文本请求，到如今支持高效、安全、复杂交互的现代化协议，HTTP 的演进史就是 Web 发展的缩影。

## HTTP/0.9 - 单行协议 (1991)

*   **诞生背景**：最早期的版本，由蒂姆·伯纳斯-李设计，旨在从服务器获取简单的 HTML 文档。
*   **核心特点**：
    *   **极其简单**：只有一个命令 `GET`，例如 `GET /index.html`。
    *   **无协议头**：请求中没有任何头信息，服务器也只响应纯粹的 HTML 内容，没有状态码或响应头。
    *   **无状态、无连接**：每个请求都需要建立一个新的 TCP 连接，请求完成后连接立即关闭。

## HTTP/1.0 - 构建基础 (1996)

*   **诞生背景**：随着 Web 内容的丰富（如图片、样式表），单行协议已无法满足需求。
*   **报文结构示例**：
    ```
    // 请求报文
    GET /index.html HTTP/1.0
    User-Agent: Mozilla/5.0
    Host: www.example.com

    // 响应报文
    HTTP/1.0 200 OK
    Content-Type: text/html
    Content-Length: 1270

    <html>
      ...
    </html>
    ```
*   **核心改进**：
    *   **引入请求头和响应头**：使得协议更具灵活性。例如，可以通过 `Content-Type` 头来传输除 HTML 以外的多种类型文件。
    *   **增加了请求方法**：除了 `GET`，还引入了 `POST` 和 `HEAD` 等方法。
    *   **增加了状态码**：如 `200 OK`, `404 Not Found` 等，使得客户端可以了解请求的结果。
    *   **缓存机制**：引入了 `Expires` 和 `If-Modified-Since` 等头部，允许浏览器缓存资源。
*   **主要缺陷**：
    *   **短连接**：默认情况下，每个请求仍然需要建立一个新的 TCP 连接，请求完成后就关闭。如果一个页面包含多张图片，就需要建立多次 TCP 连接，开销巨大。

## HTTP/1.1 - 成熟与标准化 (1999)

HTTP/1.1 是目前使用最广泛的版本，它引入了大量优化来解决 HTTP/1.0 的性能问题，是 Web 发展的一个里程碑。

*   **核心改进**：
    *   **长连接 (Persistent Connections)**：默认开启 `Connection: keep-alive`，允许多个 HTTP 请求**复用同一个 TCP 连接**，极大地减少了 TCP 连接建立和关闭的开销。
    *   **管道化 (Pipelining)**：允许客户端在收到上一个响应之前，就连续发送多个请求。
        *   **现实中的失败**：尽管理论上可以减少延迟，但管道化要求服务器必须严格按顺序返回响应，这并未解决队头阻塞问题。同时，由于其在代理服务器和实现上的诸多困难，该特性在现实中**几乎未被使用，且被大多数现代浏览器默认禁用**。
    *   **更完善的缓存控制**：引入了 `Cache-Control`, `ETag`, `If-None-Match` 等更强大、更灵活的缓存头。
    *   **增加了 HOST 头**：允许一台服务器托管多个不同域名的网站（虚拟主机）。
    *   **增加了更多请求方法**：如 `PUT`, `DELETE`, `OPTIONS`, `TRACE` 等。

### 核心概念深化：HTTP 请求方法

| 方法      | 描述                                       | 特性                                                         |
| --------- | ------------------------------------------ | ------------------------------------------------------------ |
| **GET**   | 获取资源                                   | 安全、幂等、可缓存                                           |
| **POST**  | 创建或提交数据，通常会导致服务器状态的改变 | **不安全**、**非幂等**、通常不可缓存                         |
| **PUT**   | **替换**或**完整更新**一个已知的资源       | 幂等                                                         |
| **DELETE**| 删除一个资源                               | 幂等                                                         |
| **PATCH** | 对资源进行**部分更新**                     | **非幂等**                                                   |
| **HEAD**  | 获取资源的元信息（头部），响应体为空       | 安全、幂等、可缓存                                           |
| **OPTIONS**| 获取服务器支持的方法和配置（用于 CORS 预检） | 安全、幂等                                                   |

*   **安全 (Safe)**：指请求方法不会改变服务器上的资源状态。
*   **幂等 (Idempotent)**：指多次执行相同的请求，服务器上的资源状态结果都是相同的。`POST` 和 `PATCH` 不是幂等的，因为多次调用会产生副作用（如多次创建资源、多次修改数值）。

### 核心概念深化：HTTP 状态码分类

| 分类 | 描述                                       | 常见状态码                                    |
| ---- | ------------------------------------------ | --------------------------------------------- |
| **1xx** | **信息性响应** - 表示请求已接收，继续处理    | `100 Continue`, `101 Switching Protocols` (用于 WebSocket 升级) |
| **2xx** | **成功** - 表示请求已被成功接收、理解、接受    | `200 OK`, `201 Created`, `204 No Content`     |
| **3xx** | **重定向** - 需要采取进一步操作才能完成请求  | `301 Moved Permanently`, `302 Found`, `304 Not Modified` |
| **4xx** | **客户端错误** - 请求包含语法错误或无法完成  | `400 Bad Request`, `401 Unauthorized`, `403 Forbidden`, `404 Not Found` |
| **5xx** | **服务器错误** - 服务器在处理请求时发生错误  | `500 Internal Server Error`, `502 Bad Gateway`, `503 Service Unavailable` |

*   **`401 Unauthorized` vs `403 Forbidden`**
    *   `401`: 表示“未认证”。客户端需要提供有效的身份凭证（如登录）。
    *   `403`: 表示“已认证，但无权限”。服务器理解了请求，但拒绝执行，因为当前用户没有访问该资源的权限。

*   **主要缺陷**：
    *   **队头阻塞 (Head-of-Line Blocking)**：尽管管道化允许同时发送多个请求，但服务器必须**按顺序**响应它们。如果第一个请求耗时很长（例如一个大的 API 查询），后面的请求（即使是小的图片）也必须等待它完成才能收到响应，从而造成阻塞。

## HTTP/2 - 性能革命 (2015)

HTTP/2 的主要目标是解决 HTTP/1.1 的性能瓶颈，特别是队头阻塞问题，从而全面提升 Web 加载速度。

*   **核心改进**：
    *   **二进制分帧 (Binary Framing)**：这是 HTTP/2 的基础。它将所有传输的信息（请求、响应、头部等）分割成更小的二进制**帧 (Frame)**，并为它们打上流标识（Stream ID）。
    *   **多路复用 (Multiplexing)**：基于二进制分帧，浏览器可以在**同一个 TCP 连接**上同时发送和接收多个独立的请求和响应，而不会相互干扰。不同的流（Stream）在逻辑上是独立的，一个流的阻塞不会影响其他流。**这从根本上解决了 HTTP/1.1 的队头阻塞问题。**
    *   **头部压缩 (Header Compression)**：使用 HPACK 算法来压缩请求和响应的头部。对于多个相似的请求，可以只发送差异部分, 极大地减少了传输的头部数据大小。
    *   **服务器推送 (Server Push)**：服务器可以在客户端请求之前，主动将它认为客户端会需要的资源（如 CSS, JS）推送过去，减少了请求的往返次数。
        *   **现实中的挑战**：尽管理论上很美好，但服务器推送在实践中被证明**非常难以正确使用**。核心问题在于服务器很难知道客户端缓存中到底已经有了哪些资源，因此很容易推送一些客户端已经拥有或不需要的资源，反而浪费了带宽。鉴于此，该特性并未被广泛采纳，甚至有被浏览器废弃的趋势。
*   **主要缺陷**：
    *   **TCP 队头阻塞**：虽然 HTTP/2 解决了应用层的队头阻塞，但它依然基于 TCP 协议。TCP 是一个可靠的协议，它要求数据包按顺序到达。如果在一个 TCP 连接中，某个数据包丢失了，TCP 会暂停该连接上的所有流，直到这个丢失的数据包被重传并成功接收。这就导致了底层的 **TCP 队头阻塞**。

## HTTP/3 - 面向未来 (进行中)

HTTP/3 的核心目标是解决 HTTP/2 遗留的 TCP 队头阻塞问题。为了实现这一目标，它做出了一个革命性的改变：**放弃 TCP，转向 QUIC 协议**。

*   **核心改进**：
    *   **基于 QUIC 协议**：QUIC (Quick UDP Internet Connections) 是一个基于 **UDP** 的、可靠的、低延迟的多路复用传输协议。
    *   **彻底解决队头阻塞**：QUIC 实现了在连接层面上的多路复用。每个流都是完全独立的。如果一个流中的某个 UDP 数据包丢失，它只会影响到当前这一个流，而不会阻塞该 QUIC 连接上的任何其他流。
    *   **更快的连接建立**：QUIC 将 TCP 的三次握手和 TLS 的加密握手（在 HTTPS 中需要）结合在了一起，大多数情况下只需要 **1 RTT**（往返时间）甚至 **0 RTT** 就可以建立一个安全的连接。
    *   **连接迁移 (Connection Migration)**：当用户的网络发生变化时（例如从 Wi-Fi 切换到 4G），QUIC 可以无缝地迁移连接，保持通信不中断，而 TCP 连接则需要重新建立。
