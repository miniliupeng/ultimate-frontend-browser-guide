# 21-键盘导航与焦点管理

确保所有交互功能都可以通过键盘来访问，是 Web 可访问性（a11y）中最核心、最基本的要求之一。对于无法使用鼠标的用户（如运动障碍者、高级键盘用户、屏幕阅读器用户），键盘是他们与网页交互的主要甚至唯一途径。

键盘导航的核心在于**焦点（Focus）**。焦点决定了当前页面上哪一个元素正在接收键盘的输入。

## 1. 保证所有交互元素都可聚焦

一个元素必须能够接收焦点，才能通过键盘（主要是 `Tab` 键）导航到并进行交互。

### a. 天生可聚焦的元素

正如我们在“语义化HTML”一章中提到的，许多原生 HTML 元素默认就是可聚焦的：
*   `<a>` (带 `href` 属性)
*   `<button>`
*   `<input>`, `<select>`, `<textarea>`
*   `<summary>` (用于 `<details>` 元素)
*   等...

**优先使用这些原生元素是保证可聚焦性的最简单方法。**

### b. 让任意元素可聚焦：`tabindex` 属性

`tabindex` 属性可以控制一个元素是否可聚焦，以及它是否应该被包含在 `Tab` 键的导航顺序中。

*   **`tabindex="0"`**
    *   **作用**：让一个**原本不可聚焦**的元素（如 `<div>`, `<span>`）变得**可聚焦**，并将其**按照 DOM 顺序**放入 `Tab` 键的导航序列中。
    *   **何时使用**：当你使用非交互元素来构建自定义的交互组件时（例如，用 `<div>` 模拟一个按钮），你必须为它添加 `tabindex="0"`。
    *   **重要**：仅仅让它可聚焦是不够的，你还必须通过 JavaScript 为它添加相应的键盘事件监听（如 `keydown` 事件来响应 `Enter` 和 `Space` 键）。

*   **`tabindex="-1"`**
    *   **作用**：让一个元素变得**可通过脚本聚焦**（即通过 `element.focus()` 方法），但**不会**将它放入 `Tab` 键的自然导航顺序中。
    *   **何时使用**：常用于管理复杂组件的内部焦点。例如，在一个弹窗（Modal）打开后，你希望通过脚本将焦点立即设置到弹窗内的某个元素上，但又不希望用户能通过 `Tab` 键从页面背景中意外地 `Tab` 进这个元素。

*   **`tabindex` > 0 (反模式，避免使用)**
    *   **作用**：任何大于 0 的 `tabindex` 都会创建一个独立的 `Tab` 导航序列，浏览器会优先遍历所有 `tabindex > 0` 的元素（从 1 开始按序遍历），然后再回到 `tabindex="0"` 和原生可聚焦元素的正常文档流。
    *   **为什么是反模式**：这会完全打乱用户预期的、基于 DOM 结构的自然导航顺序，造成巨大的困惑和糟糕的用户体验。**应该始终避免使用大于 0 的 `tabindex`。**

## 2. 维持一个合理的焦点顺序

焦点的移动顺序应该是**符合逻辑的、可预测的**。通常，它应该与页面的视觉阅读顺序保持一致（从上到下，从左到右）。

**最佳实践**：通过**合理地组织你的 DOM 结构**，来创建一个自然的、符合逻辑的 `Tab` 顺序。DOM 元素的顺序就是 `Tab` 键导航的默认顺序。

## 3. 设计清晰的焦点指示器

“我当前在哪里？”——这是键盘用户最常问的问题。当一个元素接收到焦点时，必须有一个**清晰的、视觉上可见**的指示器来表明它的位置。

浏览器默认会为聚焦的元素提供一个轮廓（outline），通常是一条虚线或蓝色的辉光。

**要点**：
*   **永远不要移除 `outline`**：绝对不要为了“美观”而使用 `outline: none;` 或 `outline: 0;` 来全局性地移除焦点轮廓，除非你提供了效果更佳的替代方案。
*   **设计自定义焦点样式**：使用 `:focus` 和 `:focus-visible` 伪类来设计一个既美观又清晰的自定义焦点样式。`:focus-visible` 是一个现代的伪类，它只在浏览器认为需要显示焦点指示器时（例如通过键盘导航时）才生效，而通过鼠标点击时则不显示，体验更佳。

```css
/* 为所有可聚焦元素提供一个清晰的自定义焦点环 */
:focus-visible {
  outline: 3px solid blue;
  outline-offset: 2px;
}

/* 移除那些在鼠标点击时不必要的默认焦点环 */
:focus:not(:focus-visible) {
  outline: none;
}
```

*   **处理粘性头部遮挡**：如果页面有固定的页眉（`position: sticky`），页面内锚点或元素聚焦时可能会被页眉遮挡。可以使用 `scroll-margin-top` 属性为所有可聚焦元素添加一个滚动边距，确保它们在聚焦时能完整地显示在页眉下方。

## 4. 复合组件与漫游 `tabindex`

对于一些复杂的**复合组件 (Composite Widgets)**，如菜单、选项卡、树形视图等，其内部的导航不应使用 `Tab` 键，而应使用**方向键 (Arrow Keys)**。

**核心原则**：整个复合组件在页面的 `Tab` 序列中**只应该有一个停靠点**。一旦焦点进入组件，用户就使用方向键等在组件内部导航，`Tab` 键则用于离开整个组件。

这种交互模式可以通过**漫游 `tabindex` (Roving `tabindex`)** 技术来实现：
1.  **单一入口**：在组件内部，有且仅有**一个**当前活动的子元素被设置为 `tabindex="0"`，使其成为 `Tab` 键的唯一停靠点。
2.  **内部导航**：所有其他可聚焦的子元素都被设置为 `tabindex="-1"`。它们虽然无法通过 `Tab` 键导航到，但可以通过脚本的 `.focus()` 方法聚焦。
3.  **脚本控制**：开发者监听组件的 `keydown` 事件（特别是方向键）。当用户按下方向键时，脚本会：
    a.  找到下一个应该被聚焦的目标元素。
    b.  将当前元素的 `tabindex` 修改为 `-1`。
    c.  将目标元素的 `tabindex` 修改为 `0`。
    d.  调用目标元素的 `.focus()` 方法，将焦点移动过去。

这种模式极大地提升了复杂组件的键盘导航效率和体验，是构建高级可访问性组件的标准实践。

## 5. 焦点管理与键盘陷阱

对于一些复杂的动态组件，如弹窗（Modal）、抽屉（Drawer）或菜单，我们需要通过 JavaScript 来主动管理焦点，以提供流畅的键盘体验并避免“键盘陷阱”。

### a. 弹窗 (Modal) 的焦点管理

一个可访问的弹窗必须满足以下要求：
1.  **打开时**：焦点必须被**立即移动**到弹窗内部的第一个可聚焦元素上。
2.  **焦点捕获 (Focus Trap)**：当弹窗处于打开状态时，`Tab` 键的导航必须被**限制**在弹窗内部，不能让焦点跑到弹窗背后的页面内容上。
3.  **关闭时**：焦点必须被**归还**到弹窗**打开之前**的那个元素上。

**实现思路**：
*   在弹窗打开前，记录下当前的活动元素：`const lastFocusedElement = document.activeElement;`
*   弹窗打开后，找到弹窗内第一个可聚焦元素，并调用 `element.focus()`。
*   监听弹窗内部的 `keydown` 事件。如果用户按下了 `Tab` 键，检查当前焦点是否在弹窗的第一个或最后一个可聚焦元素上。如果是，并且用户试图向外导航（`Shift+Tab` 或 `Tab`），则手动将焦点循环到弹窗的另一端，从而将焦点“捕获”在内部。
*   弹窗关闭时，调用 `lastFocusedElement.focus()` 来归还焦点。

### b. 避免键盘陷阱

**键盘陷阱**是指一个键盘用户 `Tab` 进入一个组件后，无法再通过 `Tab` 键离开的现象。这通常发生在一些复杂的自定义组件中（如嵌入的第三方小部件），如果没有正确处理焦点管理，就会造成灾难性的用户体验。

**核心原则**：确保任何可聚焦的区域，都有一个可以通过键盘（`Tab`, `Shift+Tab`, `Esc`）退出的方式。
